From c270bbecb0aae563c9ac06b60f2320b8fa04e228 Mon Sep 17 00:00:00 2001
From: SkyFire <admin@projectskyfire.org>
Date: Sun, 13 Jan 2013 11:45:08 -0600
Subject: [PATCH] Upgraded MySQL to version 5.5.29 Stable. Release notes.
 http://dev.mysql.com/doc/relnotes/mysql/5.5/en/news-5-5-29.html

Signed-off-by: SkyFire <admin@projectskyfire.org>
---
 dep/PackageList.txt                            |    3 +-
 dep/mysqllite/VERSION                          |    2 +-
 dep/mysqllite/dbug/dbug.c                      |   33 +-
 dep/mysqllite/include/decimal.h                |    9 +
 dep/mysqllite/include/internal/my_base.h       |   15 +-
 dep/mysqllite/include/internal/my_stacktrace.h |   65 ++-
 dep/mysqllite/include/internal/violite.h       |    9 +-
 dep/mysqllite/include/m_ctype.h                |    6 +-
 dep/mysqllite/include/m_string.h               |    4 +-
 dep/mysqllite/include/my_getopt.h              |    4 +-
 dep/mysqllite/include/my_global.h              |   32 +-
 dep/mysqllite/include/mysql.h                  |    3 +-
 dep/mysqllite/include/mysql/plugin.h           |   15 +-
 dep/mysqllite/include/sql_common.h             |    9 +-
 dep/mysqllite/libmysql/client_settings.h       |    5 +
 dep/mysqllite/libmysql/errmsg.c                |    3 +-
 dep/mysqllite/libmysql/get_password.c          |   25 +-
 dep/mysqllite/libmysql/libmysql.c              |  261 ++++++---
 dep/mysqllite/mysys/array.c                    |   51 +-
 dep/mysqllite/mysys/base64.c                   |   10 +-
 dep/mysqllite/mysys/charset-def.c              |   17 +-
 dep/mysqllite/mysys/charset.c                  |  141 +++--
 dep/mysqllite/mysys/checksum.c                 |    4 +-
 dep/mysqllite/mysys/default.c                  |  198 +++----
 dep/mysqllite/mysys/errors.c                   |    2 +-
 dep/mysqllite/mysys/hash.c                     |  205 +++----
 dep/mysqllite/mysys/lf_alloc-pin.c             |   10 +-
 dep/mysqllite/mysys/lf_dynarray.c              |    3 +-
 dep/mysqllite/mysys/lf_hash.c                  |    2 +-
 dep/mysqllite/mysys/list.c                     |   11 +-
 dep/mysqllite/mysys/md5.c                      |   17 +-
 dep/mysqllite/mysys/mf_arr_appstr.c            |    3 +-
 dep/mysqllite/mysys/mf_cache.c                 |   47 +-
 dep/mysqllite/mysys/mf_dirname.c               |   12 +-
 dep/mysqllite/mysys/mf_fn_ext.c                |    3 +-
 dep/mysqllite/mysys/mf_format.c                |   13 +-
 dep/mysqllite/mysys/mf_getdate.c               |   43 +-
 dep/mysqllite/mysys/mf_iocache.c               |  248 +++++----
 dep/mysqllite/mysys/mf_iocache2.c              |   59 +-
 dep/mysqllite/mysys/mf_keycache.c              |  148 +++--
 dep/mysqllite/mysys/mf_keycaches.c             |   30 +-
 dep/mysqllite/mysys/mf_loadpath.c              |   22 +-
 dep/mysqllite/mysys/mf_pack.c                  |  185 ++++---
 dep/mysqllite/mysys/mf_path.c                  |   39 +-
 dep/mysqllite/mysys/mf_qsort.c                 |   41 +-
 dep/mysqllite/mysys/mf_qsort2.c                |    2 +-
 dep/mysqllite/mysys/mf_radix.c                 |    6 +-
 dep/mysqllite/mysys/mf_same.c                  |   12 +-
 dep/mysqllite/mysys/mf_sort.c                  |    2 +-
 dep/mysqllite/mysys/mf_soundex.c               |   17 +-
 dep/mysqllite/mysys/mf_tempdir.c               |    4 +-
 dep/mysqllite/mysys/mf_tempfile.c              |   27 +-
 dep/mysqllite/mysys/mf_unixpath.c              |    2 +-
 dep/mysqllite/mysys/mf_wcomp.c                 |    2 +-
 dep/mysqllite/mysys/mulalloc.c                 |    8 +-
 dep/mysqllite/mysys/my_access.c                |   37 +-
 dep/mysqllite/mysys/my_aes.c                   |   41 +-
 dep/mysqllite/mysys/my_alloc.c                 |   28 +-
 dep/mysqllite/mysys/my_atomic.c                |    4 +-
 dep/mysqllite/mysys/my_bit.c                   |    3 +-
 dep/mysqllite/mysys/my_bitmap.c                |   34 +-
 dep/mysqllite/mysys/my_chsize.c                |    8 +-
 dep/mysqllite/mysys/my_compress.c              |    8 +-
 dep/mysqllite/mysys/my_conio.c                 |   44 +-
 dep/mysqllite/mysys/my_copy.c                  |   15 +-
 dep/mysqllite/mysys/my_create.c                |   27 +-
 dep/mysqllite/mysys/my_delete.c                |    9 +-
 dep/mysqllite/mysys/my_div.c                   |    2 +-
 dep/mysqllite/mysys/my_error.c                 |   13 +-
 dep/mysqllite/mysys/my_file.c                  |   12 +-
 dep/mysqllite/mysys/my_fopen.c                 |   75 +--
 dep/mysqllite/mysys/my_fstream.c               |   50 +-
 dep/mysqllite/mysys/my_gethwaddr.c             |    3 +-
 dep/mysqllite/mysys/my_getncpus.c              |    2 +-
 dep/mysqllite/mysys/my_getopt.c                |  633 +++++++++++-----------
 dep/mysqllite/mysys/my_getpagesize.c           |    3 +-
 dep/mysqllite/mysys/my_getsystime.c            |    9 +-
 dep/mysqllite/mysys/my_getwd.c                 |   18 +-
 dep/mysqllite/mysys/my_handler_errors.h        |   11 +-
 dep/mysqllite/mysys/my_init.c                  |   74 +--
 dep/mysqllite/mysys/my_lib.c                   |   50 +-
 dep/mysqllite/mysys/my_lock.c                  |   24 +-
 dep/mysqllite/mysys/my_malloc.c                |    8 +-
 dep/mysqllite/mysys/my_memmem.c                |    4 +-
 dep/mysqllite/mysys/my_mess.c                  |    2 +-
 dep/mysqllite/mysys/my_mkdir.c                 |    2 +-
 dep/mysqllite/mysys/my_mmap.c                  |    3 +-
 dep/mysqllite/mysys/my_once.c                  |    9 +-
 dep/mysqllite/mysys/my_open.c                  |   26 +-
 dep/mysqllite/mysys/my_pread.c                 |    7 +-
 dep/mysqllite/mysys/my_pthread.c               |   75 +--
 dep/mysqllite/mysys/my_quick.c                 |    9 +-
 dep/mysqllite/mysys/my_rdtsc.c                 |    3 +-
 dep/mysqllite/mysys/my_read.c                  |    4 +-
 dep/mysqllite/mysys/my_redel.c                 |   27 +-
 dep/mysqllite/mysys/my_rename.c                |    6 +-
 dep/mysqllite/mysys/my_seek.c                  |   11 +-
 dep/mysqllite/mysys/my_sleep.c                 |    2 +-
 dep/mysqllite/mysys/my_static.c                |   27 +-
 dep/mysqllite/mysys/my_symlink.c               |   16 +-
 dep/mysqllite/mysys/my_symlink2.c              |   22 +-
 dep/mysqllite/mysys/my_sync.c                  |    6 +-
 dep/mysqllite/mysys/my_thr_init.c              |   21 +-
 dep/mysqllite/mysys/my_wincond.c               |   67 ++-
 dep/mysqllite/mysys/my_windac.c                |    3 +-
 dep/mysqllite/mysys/my_winerr.c                |   10 +-
 dep/mysqllite/mysys/my_winfile.c               |   69 ++-
 dep/mysqllite/mysys/my_winthread.c             |    9 +-
 dep/mysqllite/mysys/my_write.c                 |   20 +-
 dep/mysqllite/mysys/ptr_cmp.c                  |   16 +-
 dep/mysqllite/mysys/queues.c                   |   72 +--
 dep/mysqllite/mysys/rijndael.c                 |  280 +++++-----
 dep/mysqllite/mysys/sha1.c                     |   33 +-
 dep/mysqllite/mysys/stacktrace.c               |  377 ++++++++++---
 dep/mysqllite/mysys/string.c                   |   16 +-
 dep/mysqllite/mysys/thr_alarm.c                |  206 +++----
 dep/mysqllite/mysys/thr_lock.c                 |  685 ++++++++++++------------
 dep/mysqllite/mysys/thr_mutex.c                |   60 ++-
 dep/mysqllite/mysys/thr_rwlock.c               |   38 +-
 dep/mysqllite/mysys/tree.c                     |  245 ++++-----
 dep/mysqllite/mysys/typelib.c                  |   45 +-
 dep/mysqllite/sql-common/client.c              |  673 +++++++++++++----------
 dep/mysqllite/sql-common/client_plugin.c       |   18 +-
 dep/mysqllite/sql-common/my_time.c             |   53 +-
 dep/mysqllite/sql-common/pack.c                |    3 +-
 dep/mysqllite/sql/net_serv.cc                  |  425 ++++++++-------
 dep/mysqllite/sql/password.c                   |   53 +-
 dep/mysqllite/strings/bchange.c                |    4 +-
 dep/mysqllite/strings/bmove_upp.c              |    2 +-
 dep/mysqllite/strings/ctype-big5.c             |   85 +--
 dep/mysqllite/strings/ctype-bin.c              |  180 ++++---
 dep/mysqllite/strings/ctype-cp932.c            |   64 ++-
 dep/mysqllite/strings/ctype-czech.c            |  244 +++++----
 dep/mysqllite/strings/ctype-euc_kr.c           |   59 +-
 dep/mysqllite/strings/ctype-extra.c            |    2 +-
 dep/mysqllite/strings/ctype-gb2312.c           |  108 ++--
 dep/mysqllite/strings/ctype-gbk.c              |   73 ++-
 dep/mysqllite/strings/ctype-latin1.c           |   55 +-
 dep/mysqllite/strings/ctype-mb.c               |  279 +++++-----
 dep/mysqllite/strings/ctype-simple.c           |  378 +++++++------
 dep/mysqllite/strings/ctype-tis620.c           |   92 ++--
 dep/mysqllite/strings/ctype-uca.c              |  563 ++++++++++---------
 dep/mysqllite/strings/ctype-ucs2.c             |  436 +++++++++------
 dep/mysqllite/strings/ctype-utf8.c             |  458 +++++++++++++---
 dep/mysqllite/strings/ctype-win1250ch.c        |  166 +++---
 dep/mysqllite/strings/ctype.c                  |   61 ++-
 dep/mysqllite/strings/decimal.c                |   59 +-
 dep/mysqllite/strings/dtoa.c                   |  169 ++++--
 dep/mysqllite/strings/int2str.c                |   20 +-
 dep/mysqllite/strings/is_prefix.c              |    2 +-
 dep/mysqllite/strings/llstr.c                  |    3 +-
 dep/mysqllite/strings/longlong2str.c           |    6 +-
 dep/mysqllite/strings/my_strchr.c              |    3 +-
 dep/mysqllite/strings/my_strtoll10.c           |   21 +-
 dep/mysqllite/strings/my_vsnprintf.c           |   37 +-
 dep/mysqllite/strings/str2int.c                |   19 +-
 dep/mysqllite/strings/str_alloc.c              |    2 +-
 dep/mysqllite/strings/strappend.c              |    3 +-
 dep/mysqllite/strings/strcend.c                |    3 +-
 dep/mysqllite/strings/strcont.c                |    4 +-
 dep/mysqllite/strings/strend.c                 |    9 +-
 dep/mysqllite/strings/strfill.c                |    2 +-
 dep/mysqllite/strings/strmake.c                |    2 +-
 dep/mysqllite/strings/strmov.c                 |    3 +-
 dep/mysqllite/strings/strnmov.c                |    2 +-
 dep/mysqllite/strings/strxmov.c                |    8 +-
 dep/mysqllite/strings/strxnmov.c               |   10 +-
 dep/mysqllite/strings/xml.c                    |   82 +--
 dep/mysqllite/vio/vio.c                        |   19 +-
 dep/mysqllite/vio/viosocket.c                  |   93 +++-
 dep/mysqllite/vio/viossl.c                     |   22 +-
 dep/mysqllite/vio/viosslfactories.c            |  125 +++--
 172 files changed, 6708 insertions(+), 4481 deletions(-)

diff --git a/dep/PackageList.txt b/dep/PackageList.txt
index eb769ab..bd475a7 100644
--- a/dep/PackageList.txt
+++ b/dep/PackageList.txt
@@ -22,7 +22,8 @@ libMPQ (a library for reading MPQ files)
 
 MySQL (the world's most popular open source database software)
   http://www.mysql.com/
-  Version: 5.5.15 (GA)
+  Release notes http://dev.mysql.com/doc/relnotes/mysql/5.5/en/news-5-5-29.html
+  Version: 5.5.29 (GA)
 
 SFMT (SIMD-oriented Fast Mersenne Twister)
   Based on http://agner.org/random/
diff --git a/dep/mysqllite/VERSION b/dep/mysqllite/VERSION
index 796544a..1889f4c 100644
--- a/dep/mysqllite/VERSION
+++ b/dep/mysqllite/VERSION
@@ -1,4 +1,4 @@
 MYSQL_VERSION_MAJOR=5
 MYSQL_VERSION_MINOR=5
-MYSQL_VERSION_PATCH=15
+MYSQL_VERSION_PATCH=29
 MYSQL_VERSION_EXTRA=
diff --git a/dep/mysqllite/dbug/dbug.c b/dep/mysqllite/dbug/dbug.c
index b5b275a..d551952 100644
--- a/dep/mysqllite/dbug/dbug.c
+++ b/dep/mysqllite/dbug/dbug.c
@@ -101,6 +101,7 @@
 
 #ifndef DBUG_OFF
 
+
 /*
  *            Manifest constants which may be "tuned" if desired.
  */
@@ -233,6 +234,7 @@ struct settings {
  *      Local variables not seen by user.
  */
 
+
 static BOOLEAN init_done= FALSE; /* Set to TRUE when initialization done */
 static struct settings init_settings;
 static const char *db_process= 0;/* Pointer to process name; argv[0] */
@@ -286,7 +288,7 @@ struct settings {
 static void DBUGCloseFile(CODE_STATE *cs, FILE *fp);
         /* Push current debug settings */
 static void PushState(CODE_STATE *cs);
-    /* Free memory associated with debug state. */
+	/* Free memory associated with debug state. */
 static void FreeState (CODE_STATE *cs, struct settings *state, int free_state);
         /* Test for tracing enabled */
 static int DoTrace(CODE_STATE *cs);
@@ -339,6 +341,7 @@ struct settings {
 #define WRITABLE(pathname)       (access(pathname, W_OK) == 0)
 #endif
 
+
 /*
 ** Macros to allow dbugging with threads
 */
@@ -827,6 +830,7 @@ void _db_push_(const char *control)
     FixTraceFlags(old_fflags, cs);
 }
 
+
 /**
   Returns TRUE if session-local settings have been set.
 */
@@ -1175,7 +1179,7 @@ void _db_return_(uint _line_, struct _db_stack_frame_ *_stack_frame_)
         pthread_mutex_lock(&THR_LOCK_dbug);
       DoPrefix(cs, _line_);
       Indent(cs, cs->level);
-      (void) fprintf(cs->stack->out_file, "<%s\n", cs->func);
+      (void) fprintf(cs->stack->out_file, "<%s %u\n", cs->func, _line_);
       DbugFlush(cs);
     }
   }
@@ -1191,6 +1195,7 @@ void _db_return_(uint _line_, struct _db_stack_frame_ *_stack_frame_)
   errno=save_errno;
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1219,6 +1224,7 @@ void _db_pargs_(uint _line_, const char *keyword)
   cs->u_keyword= keyword;
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1273,7 +1279,7 @@ void _db_doprnt_(const char *format,...)
 
 /*
  * This function is intended as a
- * vfprintf clone with consistent, platform independent output for
+ * vfprintf clone with consistent, platform independent output for 
  * problematic formats like %p, %zd and %lld.
  */
 static void DbugVfprintf(FILE *stream, const char* format, va_list args)
@@ -1283,6 +1289,7 @@ static void DbugVfprintf(FILE *stream, const char* format, va_list args)
   (void) fprintf(stream, "%s\n", cvtbuf);
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1343,6 +1350,7 @@ void _db_dump_(uint _line_, const char *keyword,
   }
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1587,6 +1595,7 @@ static void FreeState(CODE_STATE *cs, struct settings *state, int free_state)
     free((void*) state);
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1641,6 +1650,7 @@ void _db_end_()
   FreeState(cs, &tmp, 0);
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1743,6 +1753,7 @@ static void Indent(CODE_STATE *cs, int indent)
   }
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1772,6 +1783,7 @@ static void FreeList(struct link *linkp)
   }
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1839,6 +1851,7 @@ static void DoPrefix(CODE_STATE *cs, uint _line_)
     (void) fprintf(cs->stack->out_file, "%4d: ", cs->level);
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1931,6 +1944,7 @@ static void DBUGCloseFile(CODE_STATE *cs, FILE *fp)
   }
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1958,6 +1972,7 @@ static void DbugExit(const char *why)
   DBUG_ABORT();
 }
 
+
 /*
  *  FUNCTION
  *
@@ -1988,6 +2003,7 @@ static char *DbugMalloc(size_t size)
   return new_malloc;
 }
 
+
 /*
  *     strtok lookalike - splits on ':', magically handles ::, :\ and :/
  */
@@ -2000,6 +2016,7 @@ static const char *DbugStrTok(const char *s)
   return s;
 }
 
+
 /*
  *  FUNCTION
  *
@@ -2028,6 +2045,7 @@ static const char *BaseName(const char *pathname)
   return base;
 }
 
+
 /*
  *  FUNCTION
  *
@@ -2051,6 +2069,7 @@ static const char *BaseName(const char *pathname)
  *
  */
 
+
 #ifndef Writable
 
 static BOOLEAN Writable(const char *pathname)
@@ -2080,6 +2099,7 @@ static BOOLEAN Writable(const char *pathname)
 }
 #endif
 
+
 /*
  *  FUNCTION
  *
@@ -2174,6 +2194,7 @@ static void perror(s)
 }
 #endif /* HAVE_PERROR */
 
+
         /* flush dbug-stream, free mutex lock & wait delay */
         /* This is because some systems (MSDOS!!) dosn't flush fileheader */
         /* and dbug-file isn't readable after a system crash !! */
@@ -2190,6 +2211,7 @@ static void DbugFlush(CODE_STATE *cs)
     pthread_mutex_unlock(&THR_LOCK_dbug);
 } /* DbugFlush */
 
+
 /* For debugging */
 
 void _db_flush_()
@@ -2199,6 +2221,7 @@ void _db_flush_()
   (void) fflush(cs->stack->out_file);
 }
 
+
 #ifndef __WIN__
 void _db_suicide_()
 {
@@ -2217,6 +2240,7 @@ void _db_suicide_()
 }
 #endif  /* ! __WIN__ */
 
+
 void _db_lock_file_()
 {
   CODE_STATE *cs;
@@ -2240,6 +2264,7 @@ const char* _db_get_func_(void)
   return cs->func;
 }
 
+
 #else
 
 /*
@@ -2254,4 +2279,4 @@ int i_am_a_dummy_function() {
        return 0;
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/include/decimal.h b/dep/mysqllite/include/decimal.h
index 7a77b6a..0257242 100644
--- a/dep/mysqllite/include/decimal.h
+++ b/dep/mysqllite/include/decimal.h
@@ -21,6 +21,15 @@
   decimal_round_mode;
 typedef int32 decimal_digit_t;
 
+/**
+    intg is the number of *decimal* digits (NOT number of decimal_digit_t's !)
+         before the point
+    frac is the number of decimal digits after the point
+    len  is the length of buf (length of allocated space) in decimal_digit_t's,
+         not in bytes
+    sign false means positive, true means negative
+    buf  is an array of decimal_digit_t's
+ */
 typedef struct st_decimal_t {
   int    intg, frac, len;
   my_bool sign;
diff --git a/dep/mysqllite/include/internal/my_base.h b/dep/mysqllite/include/internal/my_base.h
index f6afc89..c10a325 100644
--- a/dep/mysqllite/include/internal/my_base.h
+++ b/dep/mysqllite/include/internal/my_base.h
@@ -1,5 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved. 
-   reserved
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -11,8 +10,9 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */
+
 
 /* This file includes constants used with all databases */
 
@@ -446,8 +446,11 @@ enum ha_base_keytype {
 #define HA_ERR_FILE_TOO_SHORT	  175	 /* File too short */
 #define HA_ERR_WRONG_CRC	  176	 /* Wrong CRC on page */
 #define HA_ERR_TOO_MANY_CONCURRENT_TRXS 177 /*Too many active concurrent transactions */
-#define HA_ERR_INDEX_COL_TOO_LONG 178	/* Index column length exceeds limit */
-#define HA_ERR_LAST               178    /* Copy of last error nr */
+#define HA_ERR_INDEX_COL_TOO_LONG 178	 /* Index column length exceeds limit */
+#define HA_ERR_INDEX_CORRUPT      179	 /* Index corrupted */
+#define HA_ERR_UNDO_REC_TOO_BIG   180    /* Undo log record too big */
+#define HA_ERR_TABLE_IN_FK_CHECK  181    /* Table being used in foreign key check */
+#define HA_ERR_LAST               181    /* Copy of last error nr */
 
 /* Number of different errors */
 #define HA_ERR_ERRORS            (HA_ERR_LAST - HA_ERR_FIRST + 1)
diff --git a/dep/mysqllite/include/internal/my_stacktrace.h b/dep/mysqllite/include/internal/my_stacktrace.h
index df5741f..ee03867 100644
--- a/dep/mysqllite/include/internal/my_stacktrace.h
+++ b/dep/mysqllite/include/internal/my_stacktrace.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -59,6 +59,69 @@
 void my_write_core(int sig);
 #endif
 
+
+
+/**
+  Async-signal-safe utility functions used by signal handler routines.
+  Declared here in order to unit-test them.
+  These are not general-purpose, but tailored to the signal handling routines.
+*/
+/**
+  Converts a longlong value to string.
+  @param   base 10 for decimal, 16 for hex values (0..9a..f)
+  @param   val  The value to convert
+  @param   buf  Assumed to point to the *end* of the buffer.
+  @returns Pointer to the first character of the converted string.
+           Negative values:
+           for base-10 the return string will be prepended with '-'
+           for base-16 the return string will contain 16 characters
+  Implemented with simplicity, and async-signal-safety in mind.
+*/
+char *my_safe_itoa(int base, longlong val, char *buf);
+
+/**
+  Converts a ulonglong value to string.
+  @param   base 10 for decimal, 16 for hex values (0..9a..f)
+  @param   val  The value to convert
+  @param   buf  Assumed to point to the *end* of the buffer.
+  @returns Pointer to the first character of the converted string.
+  Implemented with simplicity, and async-signal-safety in mind.
+*/
+char *my_safe_utoa(int base, ulonglong val, char *buf);
+
+/**
+  A (very) limited version of snprintf.
+  @param   to   Destination buffer.
+  @param   n    Size of destination buffer.
+  @param   fmt  printf() style format string.
+  @returns Number of bytes written, including terminating '\0'
+  Supports 'd' 'i' 'u' 'x' 'p' 's' conversion.
+  Supports 'l' and 'll' modifiers for integral types.
+  Does not support any width/precision.
+  Implemented with simplicity, and async-signal-safety in mind.
+*/
+size_t my_safe_snprintf(char* to, size_t n, const char* fmt, ...)
+  ATTRIBUTE_FORMAT(printf, 3, 4);
+
+/**
+  A (very) limited version of snprintf, which writes the result to STDERR.
+  @sa my_safe_snprintf
+  Implemented with simplicity, and async-signal-safety in mind.
+  @note Has an internal buffer capacity of 512 bytes,
+  which should suffice for our signal handling routines.
+*/
+size_t my_safe_printf_stderr(const char* fmt, ...)
+  ATTRIBUTE_FORMAT(printf, 1, 2);
+
+/**
+  Writes up to count bytes from buffer to STDERR.
+  Implemented with simplicity, and async-signal-safety in mind.
+  @param   buf   Buffer containing data to be written.
+  @param   count Number of bytes to write.
+  @returns Number of bytes written.
+*/
+size_t my_write_stderr(const void *buf, size_t count);
+
 C_MODE_END
 
 #endif /* _my_stacktrace_h_ */
diff --git a/dep/mysqllite/include/internal/violite.h b/dep/mysqllite/include/internal/violite.h
index ba05702..b35295c 100644
--- a/dep/mysqllite/include/internal/violite.h
+++ b/dep/mysqllite/include/internal/violite.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -10,8 +10,8 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */
 
 /*
  * Vio Lite.
@@ -59,6 +59,9 @@ Vio* vio_new_win32shared_memory(HANDLE handle_file_map,
 #define HANDLE void *
 #endif /* __WIN__ */
 
+/* backport from 5.6 where it is part of PSI, not vio_*() */
+int	mysql_socket_shutdown(my_socket mysql_socket, int how);
+
 void	vio_delete(Vio* vio);
 int	vio_close(Vio* vio);
 void    vio_reset(Vio* vio, enum enum_vio_type type,
diff --git a/dep/mysqllite/include/m_ctype.h b/dep/mysqllite/include/m_ctype.h
index 140233b..ac4b5d1 100644
--- a/dep/mysqllite/include/m_ctype.h
+++ b/dep/mysqllite/include/m_ctype.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -66,6 +66,8 @@
 
 extern MY_UNICASE_INFO *my_unicase_default[256];
 extern MY_UNICASE_INFO *my_unicase_turkish[256];
+extern MY_UNICASE_INFO *my_unicase_mysql500[256];
+
 
 typedef struct uni_ctype_st
 {
@@ -337,6 +339,7 @@ typedef size_t (*my_charset_conv_case)(struct charset_info_st *,
 extern CHARSET_INFO my_charset_ucs2_general_ci;
 extern CHARSET_INFO my_charset_ucs2_bin;
 extern CHARSET_INFO my_charset_ucs2_unicode_ci;
+extern CHARSET_INFO my_charset_ucs2_general_mysql500_ci;
 extern CHARSET_INFO my_charset_ujis_japanese_ci;
 extern CHARSET_INFO my_charset_ujis_bin;
 extern CHARSET_INFO my_charset_utf16_bin;
@@ -349,6 +352,7 @@ typedef size_t (*my_charset_conv_case)(struct charset_info_st *,
 extern MYSQL_PLUGIN_IMPORT CHARSET_INFO my_charset_utf8_general_ci;
 extern CHARSET_INFO my_charset_utf8_unicode_ci;
 extern CHARSET_INFO my_charset_utf8_bin;
+extern CHARSET_INFO my_charset_utf8_general_mysql500_ci;
 extern CHARSET_INFO my_charset_utf8mb4_bin;
 extern CHARSET_INFO my_charset_utf8mb4_general_ci;
 extern CHARSET_INFO my_charset_utf8mb4_unicode_ci;
diff --git a/dep/mysqllite/include/m_string.h b/dep/mysqllite/include/m_string.h
index e1a4efd..5e74325 100644
--- a/dep/mysqllite/include/m_string.h
+++ b/dep/mysqllite/include/m_string.h
@@ -60,7 +60,9 @@
 # define bfill(A,B,C)           memset((A),(C),(B))
 #endif
 
-#if !defined(bzero) && !defined(HAVE_BZERO)
+#if !defined(bzero) && (!defined(HAVE_BZERO) || !HAVE_DECL_BZERO || defined(_AIX))
+/* See autoconf doku: "HAVE_DECL_symbol" will be defined after configure, to 0 or 1 */
+/* AIX has bzero() as a function, but the declaration prototype is strangely hidden */
 # define bzero(A,B)             memset((A),0,(B))
 #endif
 
diff --git a/dep/mysqllite/include/my_getopt.h b/dep/mysqllite/include/my_getopt.h
index 092accc..04278c0 100644
--- a/dep/mysqllite/include/my_getopt.h
+++ b/dep/mysqllite/include/my_getopt.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -79,7 +79,7 @@ struct my_option
   enum get_opt_arg_type arg_type;       /**< e.g. REQUIRED_ARG or OPT_ARG */
   longlong   def_value;                 /**< Default value */
   longlong   min_value;                 /**< Min allowed value (for numbers) */
-  longlong   max_value;                 /**< Max allowed value (for numbers) */
+  ulonglong  max_value;                 /**< Max allowed value (for numbers) */
   longlong   sub_size;                  /**< Unused                          */
   long       block_size;                /**< Value should be a mult. of this (for numbers) */
   void       *app_type;                 /**< To be used by an application */
diff --git a/dep/mysqllite/include/my_global.h b/dep/mysqllite/include/my_global.h
index f465d03..031c42c 100644
--- a/dep/mysqllite/include/my_global.h
+++ b/dep/mysqllite/include/my_global.h
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -603,6 +603,8 @@
 #define FN_LIBCHAR	'\\'
 #define FN_LIBCHAR2	'/'
 #define FN_DIRSEP       "/\\"               /* Valid directory separators */
+#define FN_EXEEXT   ".exe"
+#define FN_SOEXT    ".dll"
 #define FN_ROOTDIR	"\\"
 #define FN_DEVCHAR	':'
 #define FN_NETWORK_DRIVES	/* Uses \\ to indicate network drives */
@@ -611,6 +613,8 @@
 #define FN_LIBCHAR	'/'
 #define FN_LIBCHAR2	'/'
 #define FN_DIRSEP       "/"     /* Valid directory separators */
+#define FN_EXEEXT   ""
+#define FN_SOEXT    ".so"
 #define FN_ROOTDIR	"/"
 #endif
 
@@ -1360,11 +1364,31 @@ static inline double my_isinf(double x)
 
 #ifndef HAVE_DLERROR
 #ifdef _WIN32
+#define DLERROR_GENERATE(errmsg, error_number) \
+  char win_errormsg[2048]; \
+  if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, \
+                   0, error_number, 0, win_errormsg, 2048, NULL)) \
+  { \
+    char *ptr; \
+    for (ptr= &win_errormsg[0] + strlen(win_errormsg) - 1; \
+         ptr >= &win_errormsg[0] && strchr("\r\n\t\0x20", *ptr); \
+         ptr--) \
+      *ptr= 0; \
+    errmsg= win_errormsg; \
+  } \
+  else \
+    errmsg= ""
 #define dlerror() ""
-#else
+#define dlopen_errno GetLastError()
+#else /* _WIN32 */
 #define dlerror() "No support for dynamic loading (static build?)"
-#endif
-#endif
+#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()
+#define dlopen_errno errno
+#endif /* _WIN32 */
+#else /* HAVE_DLERROR */
+#define DLERROR_GENERATE(errmsg, error_number) errmsg= dlerror()
+#define dlopen_errno errno
+#endif /* HAVE_DLERROR */
 
 
 /*
diff --git a/dep/mysqllite/include/mysql.h b/dep/mysqllite/include/mysql.h
index cff8c64..0ed3541 100644
--- a/dep/mysqllite/include/mysql.h
+++ b/dep/mysqllite/include/mysql.h
@@ -166,7 +166,8 @@ enum mysql_option
   MYSQL_OPT_USE_REMOTE_CONNECTION, MYSQL_OPT_USE_EMBEDDED_CONNECTION,
   MYSQL_OPT_GUESS_CONNECTION, MYSQL_SET_CLIENT_IP, MYSQL_SECURE_AUTH,
   MYSQL_REPORT_DATA_TRUNCATION, MYSQL_OPT_RECONNECT,
-  MYSQL_OPT_SSL_VERIFY_SERVER_CERT, MYSQL_PLUGIN_DIR, MYSQL_DEFAULT_AUTH
+  MYSQL_OPT_SSL_VERIFY_SERVER_CERT, MYSQL_PLUGIN_DIR, MYSQL_DEFAULT_AUTH,
+  MYSQL_ENABLE_CLEARTEXT_PLUGIN
 };
 
 /**
diff --git a/dep/mysqllite/include/mysql/plugin.h b/dep/mysqllite/include/mysql/plugin.h
index 1254a45..c8cdfe2 100644
--- a/dep/mysqllite/include/mysql/plugin.h
+++ b/dep/mysqllite/include/mysql/plugin.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -71,7 +71,7 @@ struct st_mysql_xid {
   Plugin API. Common for all plugin types.
 */
 
-#define MYSQL_PLUGIN_INTERFACE_VERSION 0x0102
+#define MYSQL_PLUGIN_INTERFACE_VERSION 0x0103
 
 /*
   The allowable types of plugins
@@ -120,7 +120,7 @@ struct st_mysql_xid {
                  builtin_ ## NAME ## _sizeof_struct_st_plugin, \
                  builtin_ ## NAME ## _plugin)
 
-#define mysql_declare_plugin_end ,{0,0,0,0,0,0,0,0,0,0,0,0}}
+#define mysql_declare_plugin_end ,{0,0,0,0,0,0,0,0,0,0,0,0,0}}
 
 /*
   declarations for SHOW STATUS support in plugins
@@ -144,6 +144,14 @@ struct st_mysql_show_var {
 
 
 /*
+  Constants for plugin flags.
+ */
+
+#define PLUGIN_OPT_NO_INSTALL   1UL   /* Not dynamically loadable */
+#define PLUGIN_OPT_NO_UNINSTALL 2UL   /* Not dynamically unloadable */
+
+
+/*
   declarations for server variables and command line options
 */
 
@@ -415,6 +423,7 @@ struct st_mysql_plugin
   struct st_mysql_show_var *status_vars;
   struct st_mysql_sys_var **system_vars;
   void * __reserved1;   /* reserved for dependency checking             */
+  unsigned long flags;  /* flags for plugin */
 };
 
 /*************************************************************************
diff --git a/dep/mysqllite/include/sql_common.h b/dep/mysqllite/include/sql_common.h
index c27767b..a2ea3ac 100644
--- a/dep/mysqllite/include/sql_common.h
+++ b/dep/mysqllite/include/sql_common.h
@@ -1,7 +1,7 @@
 #ifndef SQL_COMMON_INCLUDED
 #define SQL_COMMON_INCLUDED
 
-/* Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -31,6 +31,7 @@
 struct st_mysql_options_extention {
   char *plugin_dir;
   char *default_auth;
+  my_bool enable_cleartext_plugin;
 };
 
 typedef struct st_mysql_methods
@@ -72,8 +73,9 @@ struct st_mysql_options_extention {
                                         0, arg, length, 1, stmt)
 
 extern CHARSET_INFO *default_client_charset_info;
-MYSQL_FIELD *unpack_fields(MYSQL_DATA *data,MEM_ROOT *alloc,uint fields,
-			   my_bool default_value, uint server_capabilities);
+MYSQL_FIELD *unpack_fields(MYSQL *mysql, MYSQL_DATA *data,MEM_ROOT *alloc,
+                           uint fields, my_bool default_value, 
+                           uint server_capabilities);
 void free_rows(MYSQL_DATA *cur);
 void free_old_query(MYSQL *mysql);
 void end_server(MYSQL *mysql);
@@ -103,6 +105,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
 void mysql_client_plugin_deinit();
 struct st_mysql_client_plugin;
 extern struct st_mysql_client_plugin *mysql_client_builtins[];
+extern my_bool libmysql_cleartext_plugin_enabled;
 
 #ifdef	__cplusplus
 }
diff --git a/dep/mysqllite/libmysql/client_settings.h b/dep/mysqllite/libmysql/client_settings.h
index d04d610..ecc9a77 100644
--- a/dep/mysqllite/libmysql/client_settings.h
+++ b/dep/mysqllite/libmysql/client_settings.h
@@ -22,6 +22,11 @@
 extern uint		mysql_port;
 extern char *	mysql_unix_port;
 
+/*
+ Note: CLIENT_CAPABILITIES is also defined in sql/client_settings.h.
+ When adding capabilities here, consider if they should be also added to
+ the server's version.
+*/
 #define CLIENT_CAPABILITIES (CLIENT_LONG_PASSWORD | \
                              CLIENT_LONG_FLAG |     \
                              CLIENT_TRANSACTIONS |  \
diff --git a/dep/mysqllite/libmysql/errmsg.c b/dep/mysqllite/libmysql/errmsg.c
index 5e10cfc..498ba6e 100644
--- a/dep/mysqllite/libmysql/errmsg.c
+++ b/dep/mysqllite/libmysql/errmsg.c
@@ -108,6 +108,7 @@ void init_client_errs(void)
   (void) my_error_register(get_client_errmsgs, CR_ERROR_FIRST, CR_ERROR_LAST);
 }
 
+
 /*
   Unregister client error messages.
 
@@ -121,4 +122,4 @@ void init_client_errs(void)
 void finish_client_errs(void)
 {
   (void) my_error_unregister(CR_ERROR_FIRST, CR_ERROR_LAST);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/libmysql/get_password.c b/dep/mysqllite/libmysql/get_password.c
index d69f009..55b7bf4 100644
--- a/dep/mysqllite/libmysql/get_password.c
+++ b/dep/mysqllite/libmysql/get_password.c
@@ -79,9 +79,9 @@ char *get_tty_password(const char *opt_message)
     {
       if (pos != to)
       {
-    _cputs("\b \b");
-    pos--;
-    continue;
+	_cputs("\b \b");
+	pos--;
+	continue;
       }
     }
     if (tmp == '\n' || tmp == '\r' || tmp == 3)
@@ -120,13 +120,13 @@ static void get_password(char *to,uint length,int fd, my_bool echo)
     {
       if (pos != to)
       {
-    if (echo)
-    {
-      fputs("\b \b",stdout);
-      fflush(stdout);
-    }
-    pos--;
-    continue;
+	if (echo)
+	{
+	  fputs("\b \b",stdout);
+	  fflush(stdout);
+	}
+	pos--;
+	continue;
       }
     }
     if (tmp == '\n' || tmp == '\r' || tmp == 3)
@@ -147,6 +147,7 @@ static void get_password(char *to,uint length,int fd, my_bool echo)
 }
 #endif /* ! HAVE_GETPASS */
 
+
 char *get_tty_password(const char *opt_message)
 {
 #ifdef HAVE_GETPASS
@@ -166,7 +167,7 @@ char *get_tty_password(const char *opt_message)
 #ifdef _PASSWORD_LEN
   memset(passbuff, 0, _PASSWORD_LEN);
 #endif
-#else
+#else 
   if (isatty(fileno(stdout)))
   {
     fputs(opt_message ? opt_message : "Enter password: ",stdout);
@@ -205,4 +206,4 @@ char *get_tty_password(const char *opt_message)
 
   DBUG_RETURN(my_strdup(buff,MYF(MY_FAE)));
 }
-#endif /*__WIN__*/
\ No newline at end of file
+#endif /*__WIN__*/
diff --git a/dep/mysqllite/libmysql/libmysql.c b/dep/mysqllite/libmysql/libmysql.c
index 7de6b64..ed1a85f 100644
--- a/dep/mysqllite/libmysql/libmysql.c
+++ b/dep/mysqllite/libmysql/libmysql.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -67,6 +67,7 @@
 ulong 		net_buffer_length=8192;
 ulong		max_allowed_packet= 1024L*1024L*1024L;
 
+
 #ifdef EMBEDDED_LIBRARY
 #undef net_flush
 my_bool	net_flush(NET *net);
@@ -98,6 +99,7 @@
   MEM_ROOT fields_mem_root;
 } MYSQL_STMT_EXT;
 
+
 /*
   Initialize the MySQL client library
 
@@ -117,8 +119,8 @@
 */
 
 int STDCALL mysql_server_init(int argc __attribute__((unused)),
-                  char **argv __attribute__((unused)),
-                  char **groups __attribute__((unused)))
+			      char **argv __attribute__((unused)),
+			      char **groups __attribute__((unused)))
 {
   int result= 0;
   if (!mysql_client_init)
@@ -164,7 +166,7 @@ int STDCALL mysql_server_init(int argc __attribute__((unused)),
       mysql_unix_port = (char*) MYSQL_UNIX_ADDR;
 #endif
       if ((env = getenv("MYSQL_UNIX_PORT")))
-    mysql_unix_port = env;
+	mysql_unix_port = env;
     }
     mysql_debug(NullS);
 #if defined(SIGPIPE) && !defined(__WIN__)
@@ -180,6 +182,7 @@ int STDCALL mysql_server_init(int argc __attribute__((unused)),
   return result;
 }
 
+
 /*
   Free all memory and resources used by the client library
 
@@ -191,6 +194,7 @@ int STDCALL mysql_server_init(int argc __attribute__((unused)),
     function automaticly), it's safe to call this function multiple times.
 */
 
+
 void STDCALL mysql_server_end()
 {
   if (!mysql_client_init)
@@ -236,6 +240,7 @@ void STDCALL mysql_thread_end()
   my_thread_end();
 }
 
+
 /*
   Expand wildcard to a sql string
 */
@@ -250,7 +255,7 @@ void STDCALL mysql_thread_end()
     while (*wild && to < end)
     {
       if (*wild == '\\' || *wild == '\'')
-    *to++='\\';
+	*to++='\\';
       *to++= *wild++;
     }
     if (*wild)					/* Too small buffer */
@@ -260,6 +265,7 @@ void STDCALL mysql_thread_end()
   }
 }
 
+
 /**************************************************************************
   Init debugging if MYSQL_DEBUG environment variable is found
 **************************************************************************/
@@ -293,6 +299,7 @@ void STDCALL mysql_thread_end()
 #endif
 }
 
+
 /**************************************************************************
   Ignore SIGPIPE handler
    ARGSUSED
@@ -307,6 +314,7 @@ void STDCALL mysql_thread_end()
 #endif
 }
 
+
 /**************************************************************************
   Connect to sql server
   If host == 0 then use localhost
@@ -315,7 +323,7 @@ void STDCALL mysql_thread_end()
 #ifdef USE_OLD_FUNCTIONS
 MYSQL * STDCALL
 mysql_connect(MYSQL *mysql,const char *host,
-          const char *user, const char *passwd)
+	      const char *user, const char *passwd)
 {
   MYSQL *res;
   mysql=mysql_init(mysql);			/* Make it thread safe */
@@ -324,7 +332,7 @@ void STDCALL mysql_thread_end()
     if (!(res=mysql_real_connect(mysql,host,user,passwd,NullS,0,NullS,0)))
     {
       if (mysql->free_me)
-    my_free(mysql);
+	my_free(mysql);
     }
     mysql->reconnect= 1;
     DBUG_RETURN(res);
@@ -332,12 +340,13 @@ void STDCALL mysql_thread_end()
 }
 #endif
 
+
 /**************************************************************************
   Change user and database
 **************************************************************************/
 
 my_bool	STDCALL mysql_change_user(MYSQL *mysql, const char *user,
-                  const char *passwd, const char *db)
+				  const char *passwd, const char *db)
 {
   int rc;
   CHARSET_INFO *saved_cs= mysql->charset;
@@ -411,10 +420,10 @@ void read_user_name(char *name)
     if ((str=getlogin()) == NULL)
     {
       if ((skr=getpwuid(geteuid())) != NULL)
-    str=skr->pw_name;
+	str=skr->pw_name;
       else if (!(str=getenv("USER")) && !(str=getenv("LOGNAME")) &&
-           !(str=getenv("LOGIN")))
-    str="UNKNOWN_USER";
+	       !(str=getenv("LOGIN")))
+	str="UNKNOWN_USER";
     }
     (void) strmake(name,str,USERNAME_LENGTH);
 #elif HAVE_CUSERID
@@ -449,9 +458,9 @@ my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
 
   /* check that we've got valid callback functions */
   if (!(options->local_infile_init &&
-    options->local_infile_read &&
-    options->local_infile_end &&
-    options->local_infile_error))
+	options->local_infile_read &&
+	options->local_infile_end &&
+	options->local_infile_error))
   {
     /* if any of the functions is invalid, set the default */
     mysql_set_local_infile_default(mysql);
@@ -480,13 +489,13 @@ my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
 
   /* read blocks of data from local infile callback */
   while ((readcount =
-      (*options->local_infile_read)(li_ptr, buf,
-                    packet_length)) > 0)
+	  (*options->local_infile_read)(li_ptr, buf,
+					packet_length)) > 0)
   {
     if (my_net_write(net, (uchar*) buf, readcount))
     {
       DBUG_PRINT("error",
-         ("Lost connection to MySQL server during LOAD DATA of local file"));
+		 ("Lost connection to MySQL server during LOAD DATA of local file"));
       set_mysql_error(mysql, CR_SERVER_LOST, unknown_sqlstate);
       goto err;
     }
@@ -517,6 +526,7 @@ my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
   DBUG_RETURN(result);
 }
 
+
 /****************************************************************************
   Default handlers for LOAD LOCAL INFILE
 ****************************************************************************/
@@ -529,6 +539,7 @@ my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
   char error_msg[LOCAL_INFILE_ERROR_LEN];
 } default_local_infile_data;
 
+
 /*
   Open file for LOAD LOCAL INFILE
 
@@ -537,6 +548,7 @@ my_bool handle_local_infile(MYSQL *mysql, const char *net_filename)
     ptr			Store pointer to internal data here
     filename		File name to open. This may be in unix format !
 
+
   NOTES
     Even if this function returns an error, the load data interface
     guarantees that default_local_infile_end() is called.
@@ -553,7 +565,7 @@ static int default_local_infile_init(void **ptr, const char *filename,
   char tmp_name[FN_REFLEN];
 
   if (!(*ptr= data= ((default_local_infile_data *)
-             my_malloc(sizeof(default_local_infile_data),  MYF(0)))))
+		     my_malloc(sizeof(default_local_infile_data),  MYF(0)))))
     return 1; /* out of memory */
 
   data->error_msg[0]= 0;
@@ -571,6 +583,7 @@ static int default_local_infile_init(void **ptr, const char *filename,
   return 0; /* ok */
 }
 
+
 /*
   Read data for LOAD LOCAL INFILE
 
@@ -595,19 +608,20 @@ static int default_local_infile_read(void *ptr, char *buf, uint buf_len)
   {
     data->error_num= EE_READ; /* the errmsg for not entire file read */
     my_snprintf(data->error_msg, sizeof(data->error_msg)-1,
-        EE(EE_READ),
-        data->filename, my_errno);
+		EE(EE_READ),
+		data->filename, my_errno);
   }
   return count;
 }
 
+
 /*
   Read data for LOAD LOCAL INFILE
 
   SYNOPSIS
     default_local_infile_end()
     ptr			Points to handle allocated by _init
-            May be NULL if _init failed!
+			May be NULL if _init failed!
 
   RETURN
 */
@@ -623,13 +637,14 @@ static void default_local_infile_end(void *ptr)
   }
 }
 
+
 /*
   Return error from LOAD LOCAL INFILE
 
   SYNOPSIS
     default_local_infile_end()
     ptr			Points to handle allocated by _init
-            May be NULL if _init failed!
+			May be NULL if _init failed!
     error_msg		Store error text here
     error_msg_len	Max lenght of error_msg
 
@@ -651,6 +666,7 @@ static void default_local_infile_end(void *ptr)
   return CR_OUT_OF_MEMORY;
 }
 
+
 void
 mysql_set_local_infile_handler(MYSQL *mysql,
                                int (*local_infile_init)(void **, const char *,
@@ -667,6 +683,7 @@ static void default_local_infile_end(void *ptr)
   mysql->options.local_infile_userdata = userdata;
 }
 
+
 void mysql_set_local_infile_default(MYSQL *mysql)
 {
   mysql->options.local_infile_init=  default_local_infile_init;
@@ -675,6 +692,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   mysql->options.local_infile_error= default_local_infile_error;
 }
 
+
 /**************************************************************************
   Do a query. If query returned rows, free old rows.
   Read data by mysql_store_result or by repeat call of mysql_fetch_row
@@ -686,6 +704,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   return mysql_real_query(mysql,query, (uint) strlen(query));
 }
 
+
 /**************************************************************************
   Return next field of the query results
 **************************************************************************/
@@ -698,6 +717,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   return &result->fields[result->current_field++];
 }
 
+
 /**************************************************************************
   Move to a specific row and column
 **************************************************************************/
@@ -713,6 +733,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   result->data_cursor = tmp;
 }
 
+
 /*************************************************************************
   put the row or field cursor one a position one got from mysql_row_tell()
   This doesn't restore any data. The next mysql_fetch_row or
@@ -728,6 +749,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   return return_value;
 }
 
+
 MYSQL_FIELD_OFFSET STDCALL
 mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET field_offset)
 {
@@ -736,6 +758,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   return return_value;
 }
 
+
 /*****************************************************************************
   List all databases
 *****************************************************************************/
@@ -752,6 +775,7 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   DBUG_RETURN (mysql_store_result(mysql));
 }
 
+
 /*****************************************************************************
   List all tables in a database
   If wild is given then only the tables matching wild is returned
@@ -769,18 +793,20 @@ void mysql_set_local_infile_default(MYSQL *mysql)
   DBUG_RETURN (mysql_store_result(mysql));
 }
 
+
 MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
 {
   MYSQL_DATA *query;
-  if (!(query= cli_read_rows(mysql,(MYSQL_FIELD*) 0,
-                 protocol_41(mysql) ? 8 : 6)))
+  if (!(query= cli_read_rows(mysql,(MYSQL_FIELD*) 0, 
+			     protocol_41(mysql) ? 8 : 6)))
     return NULL;
 
   mysql->field_count= (uint) query->rows;
-  return unpack_fields(query,&mysql->field_alloc,
-               mysql->field_count, 1, mysql->server_capabilities);
+  return unpack_fields(mysql, query,&mysql->field_alloc,
+		       mysql->field_count, 1, mysql->server_capabilities);
 }
 
+
 /**************************************************************************
   List all fields in a table
   If wild is given then only the fields matching wild is returned
@@ -805,7 +831,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
     DBUG_RETURN(NULL);
 
   if (!(result = (MYSQL_RES *) my_malloc(sizeof(MYSQL_RES),
-                     MYF(MY_WME | MY_ZEROFILL))))
+					 MYF(MY_WME | MY_ZEROFILL))))
     DBUG_RETURN(NULL);
 
   result->methods= mysql->methods;
@@ -834,16 +860,17 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   pos=(uchar*) mysql->net.read_pos;
   field_count=(uint) net_field_length(&pos);
   if (!(fields = (*mysql->methods->read_rows)(mysql,(MYSQL_FIELD*) 0,
-                          protocol_41(mysql) ? 7 : 5)))
+					      protocol_41(mysql) ? 7 : 5)))
     DBUG_RETURN(NULL);
-  if (!(mysql->fields=unpack_fields(fields,&mysql->field_alloc,field_count,0,
-                    mysql->server_capabilities)))
+  if (!(mysql->fields=unpack_fields(mysql, fields,&mysql->field_alloc,field_count,0,
+				    mysql->server_capabilities)))
     DBUG_RETURN(0);
   mysql->status=MYSQL_STATUS_GET_RESULT;
   mysql->field_count=field_count;
   DBUG_RETURN(mysql_store_result(mysql));
 }
 
+
 #ifdef USE_OLD_FUNCTIONS
 int  STDCALL
 mysql_create_db(MYSQL *mysql, const char *db)
@@ -853,6 +880,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql,COM_CREATE_DB,db, (ulong) strlen(db),0));
 }
 
+
 int  STDCALL
 mysql_drop_db(MYSQL *mysql, const char *db)
 {
@@ -862,6 +890,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
 }
 #endif
 
+
 int STDCALL
 mysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)
 {
@@ -871,6 +900,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql, COM_SHUTDOWN, level, 1, 0));
 }
 
+
 int STDCALL
 mysql_refresh(MYSQL *mysql,uint options)
 {
@@ -880,6 +910,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql, COM_REFRESH, bits, 1, 0));
 }
 
+
 int STDCALL
 mysql_kill(MYSQL *mysql,ulong pid)
 {
@@ -889,6 +920,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql,COM_PROCESS_KILL,buff,sizeof(buff),0));
 }
 
+
 int STDCALL
 mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)
 {
@@ -898,6 +930,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql, COM_SET_OPTION, buff, sizeof(buff), 0));
 }
 
+
 int STDCALL
 mysql_dump_debug_info(MYSQL *mysql)
 {
@@ -905,6 +938,7 @@ MYSQL_FIELD *cli_list_fields(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql,COM_DEBUG,0,0,0));
 }
 
+
 const char *cli_read_statistics(MYSQL *mysql)
 {
   mysql->net.read_pos[mysql->packet_length]=0;	/* End of stat string */
@@ -916,6 +950,7 @@ const char *cli_read_statistics(MYSQL *mysql)
   return (char*) mysql->net.read_pos;
 }
 
+
 const char * STDCALL
 mysql_stat(MYSQL *mysql)
 {
@@ -925,6 +960,7 @@ const char *cli_read_statistics(MYSQL *mysql)
   DBUG_RETURN((*mysql->methods->read_statistics)(mysql));
 }
 
+
 int STDCALL
 mysql_ping(MYSQL *mysql)
 {
@@ -936,18 +972,21 @@ const char *cli_read_statistics(MYSQL *mysql)
   DBUG_RETURN(res);
 }
 
+
 const char * STDCALL
 mysql_get_server_info(MYSQL *mysql)
 {
   return((char*) mysql->server_version);
 }
 
+
 const char * STDCALL
 mysql_get_host_info(MYSQL *mysql)
 {
   return(mysql->host_info);
 }
 
+
 uint STDCALL
 mysql_get_proto_info(MYSQL *mysql)
 {
@@ -1053,6 +1092,7 @@ uint STDCALL mysql_thread_safe(void)
   return 1;
 }
 
+
 my_bool STDCALL mysql_embedded(void)
 {
 #ifdef EMBEDDED_LIBRARY
@@ -1084,10 +1124,10 @@ void my_net_local_init(NET *net)
   can use in a SQL statement in of the either ways:
     INSERT INTO blob_column VALUES (0xAABBCC);  (any MySQL version)
     INSERT INTO blob_column VALUES (X'AABBCC'); (4.1 and higher)
-
+  
   The string in "from" is encoded to a HEX string.
   The result is placed in "to" and a terminating null byte is appended.
-
+  
   The string pointed to by "from" must be "length" bytes long.
   You must allocate the "to" buffer to be at least length*2+1 bytes long.
   Each character needs two bytes, and you need room for the terminating
@@ -1104,7 +1144,7 @@ void my_net_local_init(NET *net)
 {
   char *to0= to;
   const char *end;
-
+            
   for (end= from + length; from < end; from++)
   {
     *to++= _dig_vec_upper[((unsigned char) *from) >> 4];
@@ -1128,7 +1168,7 @@ void my_net_local_init(NET *net)
 
 ulong STDCALL
 mysql_real_escape_string(MYSQL *mysql, char *to,const char *from,
-             ulong length)
+			 ulong length)
 {
   if (mysql->server_status & SERVER_STATUS_NO_BACKSLASH_ESCAPES)
     return (uint) escape_quotes_for_mysql(mysql->charset, to, 0, from, length);
@@ -1153,7 +1193,7 @@ void my_net_local_init(NET *net)
     if (use_mb_flag && (l = my_ismbchar( mysql->charset, name , end ) ) )
     {
       while (l--)
-    *to++ = *name++;
+	*to++ = *name++;
       name--;
       continue;
     }
@@ -1284,6 +1324,7 @@ static my_bool my_realloc_str(NET *net, ulong length)
   DBUG_RETURN(res);
 }
 
+
 static void stmt_clear_error(MYSQL_STMT *stmt)
 {
   if (stmt->last_errno)
@@ -1316,6 +1357,7 @@ void set_stmt_error(MYSQL_STMT * stmt, int errcode,
   DBUG_VOID_RETURN;
 }
 
+
 /**
   Set statement error code, sqlstate, and error message from NET.
 
@@ -1392,9 +1434,9 @@ my_bool cli_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
 
     if (!(fields_data= (*mysql->methods->read_rows)(mysql,(MYSQL_FIELD*)0,7)))
       DBUG_RETURN(1);
-    if (!(stmt->fields= unpack_fields(fields_data,&stmt->mem_root,
-                      field_count,0,
-                      mysql->server_capabilities)))
+    if (!(stmt->fields= unpack_fields(mysql, fields_data,&stmt->mem_root,
+				      field_count,0,
+				      mysql->server_capabilities)))
       DBUG_RETURN(1);
   }
   stmt->field_count=  field_count;
@@ -1405,6 +1447,7 @@ my_bool cli_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
   DBUG_RETURN(0);
 }
 
+
 /*
   Allocate memory and init prepared statement structure.
 
@@ -1471,6 +1514,7 @@ my_bool cli_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
   DBUG_RETURN(stmt);
 }
 
+
 /*
   Prepare server side statement with query.
 
@@ -1577,7 +1621,7 @@ my_bool cli_read_prepare_result(MYSQL *mysql, MYSQL_STMT *stmt)
     result set.
   */
   if (!(stmt->params= (MYSQL_BIND *) alloc_root(&stmt->mem_root,
-                        sizeof(MYSQL_BIND)*
+						sizeof(MYSQL_BIND)*
                                                 (stmt->param_count +
                                                  stmt->field_count))))
   {
@@ -1612,18 +1656,18 @@ static void alloc_stmt_fields(MYSQL_STMT *stmt)
     like SHOW and DESCRIBE commands
   */
   if (!(stmt->fields= (MYSQL_FIELD *) alloc_root(fields_mem_root,
-                         sizeof(MYSQL_FIELD) *
-                         stmt->field_count)) ||
+						 sizeof(MYSQL_FIELD) *
+						 stmt->field_count)) ||
       !(stmt->bind= (MYSQL_BIND *) alloc_root(fields_mem_root,
-                          sizeof(MYSQL_BIND) *
-                          stmt->field_count)))
+					      sizeof(MYSQL_BIND) *
+					      stmt->field_count)))
   {
     set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);
     return;
   }
 
   for (fields= mysql->fields, end= fields+stmt->field_count,
-     field= stmt->fields;
+	 field= stmt->fields;
        field && fields < end; fields++, field++)
   {
     *field= *fields; /* To copy all numeric parts. */
@@ -1662,6 +1706,7 @@ static void alloc_stmt_fields(MYSQL_STMT *stmt)
   }
 }
 
+
 /**
   Update result set columns metadata if it was sent again in
   reply to COM_STMT_EXECUTE.
@@ -1765,6 +1810,7 @@ static void update_stmt_fields(MYSQL_STMT *stmt)
   DBUG_RETURN(result);
 }
 
+
 /*
   Returns parameter columns meta information in the form of
   result set.
@@ -1795,9 +1841,10 @@ static void update_stmt_fields(MYSQL_STMT *stmt)
     TODO: Fix this when server sends the information.
     Till then keep a dummy prototype.
   */
-  DBUG_RETURN(0);
+  DBUG_RETURN(0); 
 }
 
+
 /* Store type of parameter in network buffer. */
 
 static void store_param_type(unsigned char **pos, MYSQL_BIND *param)
@@ -1807,6 +1854,7 @@ static void store_param_type(unsigned char **pos, MYSQL_BIND *param)
   *pos+= 2;
 }
 
+
 /*
   Functions to store parameter data in network packet.
 
@@ -1936,6 +1984,7 @@ static void store_param_str(NET *net, MYSQL_BIND *param)
   net->write_pos= to+length;
 }
 
+
 /*
   Mark if the parameter is NULL.
 
@@ -1956,6 +2005,7 @@ static void store_param_null(NET *net, MYSQL_BIND *param)
   net->buff[pos/8]|=  (uchar) (1 << (pos & 7));
 }
 
+
 /*
   Store one parameter in network packet: data is read from
   client buffer and saved in network packet by means of one
@@ -1967,8 +2017,8 @@ static my_bool store_param(MYSQL_STMT *stmt, MYSQL_BIND *param)
   NET *net= &stmt->mysql->net;
   DBUG_ENTER("store_param");
   DBUG_PRINT("enter",("type: %d  buffer: 0x%lx  length: %lu  is_null: %d",
-              param->buffer_type,
-              (long) (param->buffer ? param->buffer : NullS),
+		      param->buffer_type,
+		      (long) (param->buffer ? param->buffer : NullS),
                       *param->length, *param->is_null));
 
   if (*param->is_null)
@@ -1989,6 +2039,7 @@ static my_bool store_param(MYSQL_STMT *stmt, MYSQL_BIND *param)
   DBUG_RETURN(0);
 }
 
+
 /*
   Auxilary function to send COM_STMT_EXECUTE packet to server and read reply.
   Used from cli_stmt_execute, which is in turn used by mysql_stmt_execute.
@@ -2016,9 +2067,9 @@ static my_bool execute(MYSQL_STMT *stmt, char *packet, ulong length)
   stmt->insert_id= mysql->insert_id;
   if (res)
   {
-    /*
-      Don't set stmt error if stmt->mysql is NULL, as the error in this case
-      has already been set by mysql_prune_stmt_list().
+    /* 
+      Don't set stmt error if stmt->mysql is NULL, as the error in this case 
+      has already been set by mysql_prune_stmt_list(). 
     */
     if (stmt->mysql)
       set_stmt_errmsg(stmt, net);
@@ -2029,6 +2080,7 @@ static my_bool execute(MYSQL_STMT *stmt, char *packet, ulong length)
   DBUG_RETURN(0);
 }
 
+
 int cli_stmt_execute(MYSQL_STMT *stmt)
 {
   DBUG_ENTER("cli_stmt_execute");
@@ -2077,8 +2129,8 @@ int cli_stmt_execute(MYSQL_STMT *stmt)
         DBUG_RETURN(1);
       }
       /*
-    Store types of parameters in first in first package
-    that is sent to the server.
+	Store types of parameters in first in first package
+	that is sent to the server.
       */
       for (param= stmt->params;	param < param_end ; param++)
         store_param_type(&net->write_pos, param);
@@ -2088,9 +2140,9 @@ int cli_stmt_execute(MYSQL_STMT *stmt)
     {
       /* check if mysql_stmt_send_long_data() was used */
       if (param->long_data_used)
-    param->long_data_used= 0;	/* Clear for next execute call */
+	param->long_data_used= 0;	/* Clear for next execute call */
       else if (store_param(stmt, param))
-    DBUG_RETURN(1);
+	DBUG_RETURN(1);
     }
     length= (ulong) (net->write_pos - net->buff);
     /* TODO: Look into avoding the following memdup */
@@ -2195,6 +2247,7 @@ static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row)
   return rc;
 }
 
+
 /*
   Fetch statement row using server side cursor.
 
@@ -2232,9 +2285,9 @@ static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row)
                                             buff, sizeof(buff), (uchar*) 0, 0,
                                             1, stmt))
     {
-      /*
-        Don't set stmt error if stmt->mysql is NULL, as the error in this case
-        has already been set by mysql_prune_stmt_list().
+      /* 
+        Don't set stmt error if stmt->mysql is NULL, as the error in this case 
+        has already been set by mysql_prune_stmt_list(). 
       */
       if (stmt->mysql)
         set_stmt_errmsg(stmt, net);
@@ -2251,6 +2304,7 @@ static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row)
   return MYSQL_NO_DATA;
 }
 
+
 /*
   Default read row function to not SIGSEGV in client in
   case of wrong sequence of API calls.
@@ -2271,6 +2325,7 @@ static int stmt_read_row_unbuffered(MYSQL_STMT *stmt, unsigned char **row)
   return 1;
 }
 
+
 /*
   Get/set statement attributes
 
@@ -2320,6 +2375,7 @@ my_bool STDCALL mysql_stmt_attr_set(MYSQL_STMT *stmt,
   return TRUE;
 }
 
+
 my_bool STDCALL mysql_stmt_attr_get(MYSQL_STMT *stmt,
                                     enum enum_stmt_attr_type attr_type,
                                     void *value)
@@ -2340,6 +2396,7 @@ my_bool STDCALL mysql_stmt_attr_get(MYSQL_STMT *stmt,
   return FALSE;
 }
 
+
 /**
   Update statement result set metadata from with the new field
   information sent during statement execute.
@@ -2386,6 +2443,7 @@ static void reinit_result_set_metadata(MYSQL_STMT *stmt)
   }
 }
 
+
 static void prepare_to_fetch_result(MYSQL_STMT *stmt)
 {
   if (stmt->server_status & SERVER_STATUS_CURSOR_EXISTS)
@@ -2412,6 +2470,7 @@ static void prepare_to_fetch_result(MYSQL_STMT *stmt)
   }
 }
 
+
 /*
   Send placeholders data to server (if there are placeholders)
   and execute prepared statement.
@@ -2484,6 +2543,7 @@ int STDCALL mysql_stmt_execute(MYSQL_STMT *stmt)
   DBUG_RETURN(test(stmt->last_errno));
 }
 
+
 /*
   Return total parameters count in the statement
 */
@@ -2503,6 +2563,7 @@ my_ulonglong STDCALL mysql_stmt_affected_rows(MYSQL_STMT *stmt)
   return stmt->affected_rows;
 }
 
+
 /*
   Returns the number of result columns for the most recent query
   run on this statement.
@@ -2534,9 +2595,11 @@ my_ulonglong STDCALL mysql_stmt_insert_id(MYSQL_STMT *stmt)
   return stmt->insert_id;
 }
 
+
 static my_bool int_is_null_true= 1;		/* Used for MYSQL_TYPE_NULL */
 static my_bool int_is_null_false= 0;
 
+
 /*
   Set up input data buffers for a statement.
 
@@ -2724,7 +2787,7 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
 
   /* Allocated on prepare */
   memcpy((char*) stmt->params, (char*) my_bind,
-     sizeof(MYSQL_BIND) * stmt->param_count);
+	 sizeof(MYSQL_BIND) * stmt->param_count);
 
   for (param= stmt->params, end= param+stmt->param_count;
        param < end ;
@@ -2804,8 +2867,8 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
     default:
       strmov(stmt->sqlstate, unknown_sqlstate);
       sprintf(stmt->last_error,
-          ER(stmt->last_errno= CR_UNSUPPORTED_PARAM_TYPE),
-          param->buffer_type, count);
+	      ER(stmt->last_errno= CR_UNSUPPORTED_PARAM_TYPE),
+	      param->buffer_type, count);
       DBUG_RETURN(1);
     }
     /*
@@ -2821,6 +2884,7 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
   DBUG_RETURN(0);
 }
 
+
 /********************************************************************
  Long data implementation
 *********************************************************************/
@@ -2866,13 +2930,13 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
 
 my_bool STDCALL
 mysql_stmt_send_long_data(MYSQL_STMT *stmt, uint param_number,
-             const char *data, ulong length)
+		     const char *data, ulong length)
 {
   MYSQL_BIND *param;
   DBUG_ENTER("mysql_stmt_send_long_data");
   DBUG_ASSERT(stmt != 0);
   DBUG_PRINT("enter",("param no: %d  data: 0x%lx, length : %ld",
-              param_number, (long) data, length));
+		      param_number, (long) data, length));
 
   /*
     We only need to check for stmt->param_count, if it's not null
@@ -2890,7 +2954,7 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
     /* Long data handling should be used only for string/binary types */
     strmov(stmt->sqlstate, unknown_sqlstate);
     sprintf(stmt->last_error, ER(stmt->last_errno= CR_INVALID_BUFFER_USE),
-        param->param_number);
+	    param->param_number);
     DBUG_RETURN(1);
   }
 
@@ -2916,9 +2980,9 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
                                             buff, sizeof(buff), (uchar*) data,
                                             length, 1, stmt))
     {
-      /*
-        Don't set stmt error if stmt->mysql is NULL, as the error in this case
-        has already been set by mysql_prune_stmt_list().
+      /* 
+        Don't set stmt error if stmt->mysql is NULL, as the error in this case 
+        has already been set by mysql_prune_stmt_list(). 
       */
       if (stmt->mysql)
         set_stmt_errmsg(stmt, &mysql->net);
@@ -2928,6 +2992,7 @@ my_bool STDCALL mysql_stmt_bind_param(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
   DBUG_RETURN(0);
 }
 
+
 /********************************************************************
  Fetch and conversion of result set rows (binary protocol).
 *********************************************************************/
@@ -3030,6 +3095,7 @@ static void read_binary_date(MYSQL_TIME *tm, uchar **pos)
     set_zero_time(tm, MYSQL_TIMESTAMP_DATE);
 }
 
+
 /*
   Convert string to supplied buffer of any type.
 
@@ -3155,6 +3221,7 @@ static void fetch_string_with_conversion(MYSQL_BIND *param, char *value,
   }
 }
 
+
 /*
   Convert integer value to client buffer of any type.
 
@@ -3383,6 +3450,7 @@ static void fetch_float_with_conversion(MYSQL_BIND *param, MYSQL_FIELD *field,
   }
 }
 
+
 /*
   Fetch time/date/datetime to supplied buffer of any type
 
@@ -3448,6 +3516,7 @@ static void fetch_datetime_with_conversion(MYSQL_BIND *param,
   }
 }
 
+
 /*
   Fetch and convert result set column to output buffer.
 
@@ -3560,6 +3629,7 @@ static void fetch_result_with_conversion(MYSQL_BIND *param, MYSQL_FIELD *field,
   }
 }
 
+
 /*
   Functions to fetch data to application buffers without conversion.
 
@@ -3692,31 +3762,34 @@ static void fetch_result_str(MYSQL_BIND *param,
   *row+= length;
 }
 
+
 /*
   functions to calculate max lengths for strings during
   mysql_stmt_store_result()
 */
 
 static void skip_result_fixed(MYSQL_BIND *param,
-                  MYSQL_FIELD *field __attribute__((unused)),
-                  uchar **row)
+			      MYSQL_FIELD *field __attribute__((unused)),
+			      uchar **row)
 
 {
   (*row)+= param->pack_length;
 }
 
+
 static void skip_result_with_length(MYSQL_BIND *param __attribute__((unused)),
-                    MYSQL_FIELD *field __attribute__((unused)),
-                    uchar **row)
+				    MYSQL_FIELD *field __attribute__((unused)),
+				    uchar **row)
 
 {
   ulong length= net_field_length(row);
   (*row)+= length;
 }
 
+
 static void skip_result_string(MYSQL_BIND *param __attribute__((unused)),
-                   MYSQL_FIELD *field,
-                   uchar **row)
+			       MYSQL_FIELD *field,
+			       uchar **row)
 
 {
   ulong length= net_field_length(row);
@@ -3725,6 +3798,7 @@ static void skip_result_string(MYSQL_BIND *param __attribute__((unused)),
     field->max_length= length;
 }
 
+
 /*
   Check that two field types are binary compatible i. e.
   have equal representation in the binary protocol and
@@ -3772,6 +3846,7 @@ static my_bool is_binary_compatible(enum enum_field_types type1,
   return FALSE;
 }
 
+
 /*
   Setup a fetch function for one column of a result set.
 
@@ -3944,6 +4019,7 @@ static my_bool setup_one_fetch_function(MYSQL_BIND *param, MYSQL_FIELD *field)
   DBUG_RETURN(FALSE);
 }
 
+
 /*
   Setup the bind buffers for resultset processing
 */
@@ -4014,6 +4090,7 @@ my_bool STDCALL mysql_stmt_bind_result(MYSQL_STMT *stmt, MYSQL_BIND *my_bind)
   DBUG_RETURN(0);
 }
 
+
 /*
   Fetch row data to bind buffers
 */
@@ -4078,16 +4155,18 @@ static int stmt_fetch_row(MYSQL_STMT *stmt, uchar *row)
   return 0;
 }
 
+
 int cli_unbuffered_fetch(MYSQL *mysql, char **row)
 {
   if (packet_error == cli_safe_read(mysql))
     return 1;
 
   *row= ((mysql->net.read_pos[0] == 254) ? NULL :
-     (char*) (mysql->net.read_pos+1));
+	 (char*) (mysql->net.read_pos+1));
   return 0;
 }
 
+
 /*
   Fetch and return row data to bound buffers, if any
 */
@@ -4102,7 +4181,7 @@ int STDCALL mysql_stmt_fetch(MYSQL_STMT *stmt)
       ((rc= stmt_fetch_row(stmt, row)) && rc != MYSQL_DATA_TRUNCATED))
   {
     stmt->state= MYSQL_STMT_PREPARE_DONE;       /* XXX: this is buggy */
-    stmt->read_row_func= (rc == MYSQL_NO_DATA) ?
+    stmt->read_row_func= (rc == MYSQL_NO_DATA) ? 
       stmt_read_row_no_data : stmt_read_row_no_result_set;
   }
   else
@@ -4113,6 +4192,7 @@ int STDCALL mysql_stmt_fetch(MYSQL_STMT *stmt)
   DBUG_RETURN(rc);
 }
 
+
 /*
   Fetch data for one specified column data
 
@@ -4120,10 +4200,10 @@ int STDCALL mysql_stmt_fetch(MYSQL_STMT *stmt)
     mysql_stmt_fetch_column()
     stmt		Prepared statement handler
     my_bind		Where data should be placed. Should be filled in as
-            when calling mysql_stmt_bind_result()
+			when calling mysql_stmt_bind_result()
     column		Column to fetch (first column is 0)
     ulong offset	Offset in result data (to fetch blob in pieces)
-            This is normally 0
+			This is normally 0
   RETURN
     0	ok
     1	error
@@ -4138,7 +4218,7 @@ int STDCALL mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *my_bind,
   if ((int) stmt->state < (int) MYSQL_STMT_FETCH_DONE)
   {
     set_stmt_error(stmt, CR_NO_DATA, unknown_sqlstate, NULL);
-    return 1;
+    DBUG_RETURN(1);
   }
   if (column >= stmt->field_count)
   {
@@ -4170,6 +4250,7 @@ int STDCALL mysql_stmt_fetch_column(MYSQL_STMT *stmt, MYSQL_BIND *my_bind,
   DBUG_RETURN(0);
 }
 
+
 /*
   Read all rows of data from server  (binary format)
 */
@@ -4228,6 +4309,7 @@ int cli_read_binary_rows(MYSQL_STMT *stmt)
   DBUG_RETURN(1);
 }
 
+
 /*
   Update meta data for statement
 
@@ -4270,6 +4352,7 @@ static void stmt_update_metadata(MYSQL_STMT *stmt, MYSQL_ROWS *data)
   }
 }
 
+
 /*
   Store or buffer the binary results to stmt
 */
@@ -4318,9 +4401,9 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
     if (cli_advanced_command(mysql, COM_STMT_FETCH, buff, sizeof(buff),
                              (uchar*) 0, 0, 1, stmt))
     {
-      /*
-        Don't set stmt error if stmt->mysql is NULL, as the error in this case
-        has already been set by mysql_prune_stmt_list().
+      /* 
+        Don't set stmt error if stmt->mysql is NULL, as the error in this case 
+        has already been set by mysql_prune_stmt_list(). 
       */
       if (stmt->mysql)
         set_stmt_errmsg(stmt, net);
@@ -4345,8 +4428,8 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
 
     for (my_bind= stmt->bind, end= my_bind + stmt->field_count,
            field= stmt->fields;
-     my_bind < end ;
-     my_bind++, field++)
+	 my_bind < end ;
+	 my_bind++, field++)
     {
       my_bind->buffer_type= MYSQL_TYPE_NULL;
       my_bind->buffer_length=1;
@@ -4385,6 +4468,7 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
   DBUG_RETURN(0); /* Data buffered, must be fetched with mysql_stmt_fetch() */
 }
 
+
 /*
   Seek to desired row in the statement result set
 */
@@ -4399,6 +4483,7 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
   DBUG_RETURN(offset);
 }
 
+
 /*
   Return the current statement row cursor position
 */
@@ -4411,6 +4496,7 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
   DBUG_RETURN(stmt->data_cursor);
 }
 
+
 /*
   Move the stmt result set data cursor to specified row
 */
@@ -4434,6 +4520,7 @@ int STDCALL mysql_stmt_store_result(MYSQL_STMT *stmt)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Return total rows the current statement result set
 */
@@ -4445,6 +4532,7 @@ my_ulonglong STDCALL mysql_stmt_num_rows(MYSQL_STMT *stmt)
   DBUG_RETURN(stmt->result.rows);
 }
 
+
 /*
   Free the client side memory buffers, reset long data state
   on client if necessary, and reset the server side statement if
@@ -4638,6 +4726,7 @@ const char *STDCALL mysql_stmt_error(MYSQL_STMT * stmt)
   DBUG_RETURN(stmt->last_error);
 }
 
+
 /********************************************************************
  Transactional APIs
 *********************************************************************/
@@ -4662,6 +4751,7 @@ my_bool STDCALL mysql_rollback(MYSQL * mysql)
   DBUG_RETURN((my_bool) mysql_real_query(mysql, "rollback", 8));
 }
 
+
 /*
   Set autocommit to either true or false
 */
@@ -4676,6 +4766,7 @@ my_bool STDCALL mysql_autocommit(MYSQL * mysql, my_bool auto_mode)
                                          16));
 }
 
+
 /********************************************************************
  Multi query execution + SPs APIs
 *********************************************************************/
@@ -4695,6 +4786,7 @@ my_bool STDCALL mysql_more_results(MYSQL *mysql)
   DBUG_RETURN(res);
 }
 
+
 /*
   Reads and returns the next query results
 */
@@ -4717,6 +4809,7 @@ int STDCALL mysql_next_result(MYSQL *mysql)
   DBUG_RETURN(-1);				/* No more results */
 }
 
+
 int STDCALL mysql_stmt_next_result(MYSQL_STMT *stmt)
 {
   MYSQL *mysql= stmt->mysql;
@@ -4759,6 +4852,7 @@ int STDCALL mysql_stmt_next_result(MYSQL_STMT *stmt)
   DBUG_RETURN(0);
 }
 
+
 MYSQL_RES * STDCALL mysql_use_result(MYSQL *mysql)
 {
   return (*mysql->methods->use_result)(mysql);
@@ -4767,4 +4861,5 @@ MYSQL_RES * STDCALL mysql_use_result(MYSQL *mysql)
 my_bool STDCALL mysql_read_query_result(MYSQL *mysql)
 {
   return (*mysql->methods->read_query_result)(mysql);
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/array.c b/dep/mysqllite/mysys/array.c
index c5785e3..f7ec126 100644
--- a/dep/mysqllite/mysys/array.c
+++ b/dep/mysqllite/mysys/array.c
@@ -30,8 +30,8 @@
       alloc_increment	Increment for adding new elements
 
   DESCRIPTION
-    init_dynamic_array() initiates array and allocate space for
-    init_alloc eilements.
+    init_dynamic_array() initiates array and allocate space for 
+    init_alloc eilements. 
     Array is usable even if space allocation failed, hence, the
     function never returns TRUE.
     Static buffers must begin immediately after the array structure.
@@ -41,7 +41,7 @@
 */
 
 my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,
-                            void *init_buffer, uint init_alloc,
+                            void *init_buffer, uint init_alloc, 
                             uint alloc_increment)
 {
   DBUG_ENTER("init_dynamic_array");
@@ -63,20 +63,20 @@ my_bool init_dynamic_array2(DYNAMIC_ARRAY *array, uint element_size,
   array->size_of_element=element_size;
   if ((array->buffer= init_buffer))
     DBUG_RETURN(FALSE);
-  /*
+  /* 
     Since the dynamic array is usable even if allocation fails here malloc
     should not throw an error
   */
   if (!(array->buffer= (uchar*) my_malloc(element_size*init_alloc, MYF(0))))
     array->max_element=0;
   DBUG_RETURN(FALSE);
-}
+} 
 
 my_bool init_dynamic_array(DYNAMIC_ARRAY *array, uint element_size,
                            uint init_alloc, uint alloc_increment)
 {
   /* placeholder to preserve ABI */
-  return my_init_dynamic_array_ci(array, element_size, init_alloc,
+  return my_init_dynamic_array_ci(array, element_size, init_alloc, 
                                   alloc_increment);
 }
 /*
@@ -109,8 +109,9 @@ my_bool insert_dynamic(DYNAMIC_ARRAY *array, uchar* element)
   return FALSE;
 }
 
+
 /*
-  Alloc space for next element(s)
+  Alloc space for next element(s) 
 
   SYNOPSIS
     alloc_dynamic()
@@ -142,7 +143,7 @@ uchar *alloc_dynamic(DYNAMIC_ARRAY *array)
                                         array->size_of_element,
                                         MYF(MY_WME))))
         return 0;
-      memcpy(new_ptr, array->buffer,
+      memcpy(new_ptr, array->buffer, 
              array->elements * array->size_of_element);
     }
     else
@@ -157,14 +158,15 @@ uchar *alloc_dynamic(DYNAMIC_ARRAY *array)
   return array->buffer+(array->elements++ * array->size_of_element);
 }
 
+
 /*
   Pop last element from array.
 
   SYNOPSIS
     pop_dynamic()
       array
-
-  RETURN VALUE
+  
+  RETURN VALUE    
     pointer	Ok
     0		Array is empty
 */
@@ -186,9 +188,9 @@ uchar *pop_dynamic(DYNAMIC_ARRAY *array)
       idx	Index where element is to be inserted
 
   DESCRIPTION
-    set_dynamic() replaces element in array.
-    If idx > max_element insert new element. Allocate memory if needed.
-
+    set_dynamic() replaces element in array. 
+    If idx > max_element insert new element. Allocate memory if needed. 
+ 
   RETURN VALUE
     TRUE	Idx was out of range and allocation of new memory failed
     FALSE	Ok
@@ -201,14 +203,15 @@ my_bool set_dynamic(DYNAMIC_ARRAY *array, uchar* element, uint idx)
     if (idx >= array->max_element && allocate_dynamic(array, idx))
       return TRUE;
     bzero((uchar*) (array->buffer+array->elements*array->size_of_element),
-      (idx - array->elements)*array->size_of_element);
+	  (idx - array->elements)*array->size_of_element);
     array->elements=idx+1;
   }
   memcpy(array->buffer+(idx * array->size_of_element),element,
-     (size_t) array->size_of_element);
+	 (size_t) array->size_of_element);
   return FALSE;
 }
 
+
 /*
   Ensure that dynamic array has enough elements
 
@@ -243,11 +246,12 @@ my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements)
                                          array->size_of_element,
                                          MYF(MY_WME))))
          return 0;
-       memcpy(new_ptr, array->buffer,
+       memcpy(new_ptr, array->buffer, 
               array->elements * array->size_of_element);
      }
      else
 
+
     if (!(new_ptr= (uchar*) my_realloc(array->buffer,size*
                                        array->size_of_element,
                                        MYF(MY_WME | MY_ALLOW_ZERO_PTR))))
@@ -258,14 +262,15 @@ my_bool allocate_dynamic(DYNAMIC_ARRAY *array, uint max_elements)
   return FALSE;
 }
 
+
 /*
   Get an element from array by given index
 
   SYNOPSIS
     get_dynamic()
-      array
+      array	
       uchar*	Element to be returned. If idx > elements contain zeroes.
-      idx	Index of element wanted.
+      idx	Index of element wanted. 
 */
 
 void get_dynamic(DYNAMIC_ARRAY *array, uchar* element, uint idx)
@@ -281,6 +286,7 @@ void get_dynamic(DYNAMIC_ARRAY *array, uchar* element, uint idx)
          (size_t) array->size_of_element);
 }
 
+
 /*
   Empty array by freeing all memory
 
@@ -322,6 +328,7 @@ void delete_dynamic_element(DYNAMIC_ARRAY *array, uint idx)
           (array->elements-idx)*array->size_of_element);
 }
 
+
 /*
   Free unused memory
 
@@ -340,7 +347,7 @@ void freeze_size(DYNAMIC_ARRAY *array)
   */
   if (array->buffer == (uchar *)(array + 1))
     return;
-
+    
   if (array->buffer && array->max_element != elements)
   {
     array->buffer=(uchar*) my_realloc(array->buffer,
@@ -350,13 +357,14 @@ void freeze_size(DYNAMIC_ARRAY *array)
   }
 }
 
+
 /*
   Get the index of a dynamic element
 
   SYNOPSIS
     get_index_dynamic()
      array	Array
-     element Whose element index
+     element Whose element index 
 
 */
 
@@ -371,4 +379,5 @@ int get_index_dynamic(DYNAMIC_ARRAY *array, uchar* element)
     return -1;
 
   return ret;
-}
\ No newline at end of file
+
+}
diff --git a/dep/mysqllite/mysys/base64.c b/dep/mysqllite/mysys/base64.c
index ecdabd7..b48bcb8 100644
--- a/dep/mysqllite/mysys/base64.c
+++ b/dep/mysqllite/mysys/base64.c
@@ -25,6 +25,7 @@
                              "abcdefghijklmnopqrstuvwxyz"
                              "0123456789+/";
 
+
 int
 base64_needed_encoded_length(int length_of_data)
 {
@@ -37,12 +38,14 @@
     1;                           /* NUL termination of string */
 }
 
+
 int
 base64_needed_decoded_length(int length_of_encoded_data)
 {
   return (int) ceil(length_of_encoded_data * 3 / 4);
 }
 
+
 /*
   Encode a data as base64.
 
@@ -97,12 +100,14 @@
   return 0;
 }
 
+
 static inline uint
 pos(unsigned char c)
 {
   return (uint) (strchr(base64_table, c) - base64_table);
 }
 
+
 #define SKIP_SPACE(src, i, size)                                \
 {                                                               \
   while (i < size && my_isspace(&my_charset_latin1, * src))     \
@@ -116,6 +121,7 @@
   }                                                             \
 }
 
+
 /*
   Decode a base64 string
 
@@ -221,6 +227,7 @@
   return i != len ? -1 : (int) (d - dst_base);
 }
 
+
 #else /* MAIN */
 
 #define require(b) { \
@@ -230,6 +237,7 @@
   } \
 }
 
+
 int
 main(void)
 {
@@ -301,4 +309,4 @@
   return 0;
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/charset-def.c b/dep/mysqllite/mysys/charset-def.c
index 2867b3e..987b071 100644
--- a/dep/mysqllite/mysys/charset-def.c
+++ b/dep/mysqllite/mysys/charset-def.c
@@ -1,5 +1,4 @@
-/* Copyright (c) 2000, 2003-2007 MySQL AB, 2009, 2010 Sun Microsystems, Inc.
-   Use is subject to license terms.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -46,6 +45,7 @@
 extern CHARSET_INFO my_charset_ucs2_sinhala_uca_ci;
 #endif
 
+
 #ifdef HAVE_CHARSET_utf32
 extern CHARSET_INFO my_charset_utf32_icelandic_uca_ci;
 extern CHARSET_INFO my_charset_utf32_latvian_uca_ci;
@@ -68,6 +68,7 @@
 extern CHARSET_INFO my_charset_utf32_sinhala_uca_ci;
 #endif /* HAVE_CHARSET_utf32 */
 
+
 #ifdef HAVE_CHARSET_utf16
 extern CHARSET_INFO my_charset_utf16_icelandic_uca_ci;
 extern CHARSET_INFO my_charset_utf16_latvian_uca_ci;
@@ -90,6 +91,7 @@
 extern CHARSET_INFO my_charset_utf16_sinhala_uca_ci;
 #endif  /* HAVE_CHARSET_utf16 */
 
+
 #ifdef HAVE_CHARSET_utf8
 extern CHARSET_INFO my_charset_utf8_icelandic_uca_ci;
 extern CHARSET_INFO my_charset_utf8_latvian_uca_ci;
@@ -145,7 +147,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 
   add_compiled_collation(&my_charset_bin);
   add_compiled_collation(&my_charset_filename);
-
+  
   add_compiled_collation(&my_charset_latin1);
   add_compiled_collation(&my_charset_latin1_bin);
   add_compiled_collation(&my_charset_latin1_german2_ci);
@@ -201,6 +203,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 #ifdef HAVE_CHARSET_ucs2
   add_compiled_collation(&my_charset_ucs2_general_ci);
   add_compiled_collation(&my_charset_ucs2_bin);
+  add_compiled_collation(&my_charset_ucs2_general_mysql500_ci);
 #ifdef HAVE_UCA_COLLATIONS
   add_compiled_collation(&my_charset_ucs2_unicode_ci);
   add_compiled_collation(&my_charset_ucs2_icelandic_uca_ci);
@@ -233,6 +236,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 #ifdef HAVE_CHARSET_utf8
   add_compiled_collation(&my_charset_utf8_general_ci);
   add_compiled_collation(&my_charset_utf8_bin);
+  add_compiled_collation(&my_charset_utf8_general_mysql500_ci);
 #ifdef HAVE_UTF8_GENERAL_CS
   add_compiled_collation(&my_charset_utf8_general_cs);
 #endif
@@ -260,6 +264,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 #endif
 #endif /* HAVE_CHARSET_utf8 */
 
+
 #ifdef HAVE_CHARSET_utf8mb4
   add_compiled_collation(&my_charset_utf8mb4_general_ci);
   add_compiled_collation(&my_charset_utf8mb4_bin);
@@ -287,6 +292,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 #endif /* HAVE_UCA_COLLATIONS  */
 #endif /* HAVE_CHARSET_utf8mb4 */
 
+
 #ifdef HAVE_CHARSET_utf16
   add_compiled_collation(&my_charset_utf16_general_ci);
   add_compiled_collation(&my_charset_utf16_bin);
@@ -314,6 +320,7 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
 #endif /* HAVE_UCA_COLLATIOINS */
 #endif /* HAVE_CHARSET_utf16 */
 
+
 #ifdef HAVE_CHARSET_utf32
   add_compiled_collation(&my_charset_utf32_general_ci);
   add_compiled_collation(&my_charset_utf32_bin);
@@ -344,6 +351,6 @@ my_bool init_compiled_charsets(myf flags __attribute__((unused)))
   /* Copy compiled charsets */
   for (cs=compiled_charsets; cs->name; cs++)
     add_compiled_collation(cs);
-
+  
   return FALSE;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/charset.c b/dep/mysqllite/mysys/charset.c
index 7698d35..9f9a96a 100644
--- a/dep/mysqllite/mysys/charset.c
+++ b/dep/mysqllite/mysys/charset.c
@@ -20,12 +20,13 @@
 #include <my_dir.h>
 #include <my_xml.h>
 
+
 /*
   The code below implements this functionality:
-
+  
     - Initializing charset related structures
     - Loading dynamic charsets
-    - Searching for a proper CHARSET_INFO
+    - Searching for a proper CHARSET_INFO 
       using charset name, collation name or collation ID
     - Setting server default character set
 */
@@ -35,6 +36,7 @@ my_bool my_charset_same(CHARSET_INFO *cs1, CHARSET_INFO *cs2)
   return ((cs1 == cs2) || !strcmp(cs1->csname,cs2->csname));
 }
 
+
 static uint
 get_collation_number_internal(const char *name)
 {
@@ -43,13 +45,14 @@ my_bool my_charset_same(CHARSET_INFO *cs1, CHARSET_INFO *cs2)
        cs < all_charsets + array_elements(all_charsets);
        cs++)
   {
-    if ( cs[0] && cs[0]->name &&
+    if ( cs[0] && cs[0]->name && 
          !my_strcasecmp(&my_charset_latin1, cs[0]->name, name))
       return cs[0]->number;
-  }
+  }  
   return 0;
 }
 
+
 static my_bool init_state_maps(CHARSET_INFO *cs)
 {
   uint i;
@@ -58,13 +61,13 @@ static my_bool init_state_maps(CHARSET_INFO *cs)
 
   if (!(cs->state_map= (uchar*) my_once_alloc(256, MYF(MY_WME))))
     return 1;
-
+    
   if (!(cs->ident_map= (uchar*) my_once_alloc(256, MYF(MY_WME))))
     return 1;
 
   state_map= cs->state_map;
   ident_map= cs->ident_map;
-
+  
   /* Fill state_map with states to get a faster parser */
   for (i=0; i < 256 ; i++)
   {
@@ -104,7 +107,7 @@ static my_bool init_state_maps(CHARSET_INFO *cs)
   for (i=0; i < 256 ; i++)
   {
     ident_map[i]= (uchar) (state_map[i] == MY_LEX_IDENT ||
-               state_map[i] == MY_LEX_NUMBER_IDENT);
+			   state_map[i] == MY_LEX_NUMBER_IDENT);
   }
 
   /* Special handling of hex and binary strings */
@@ -114,16 +117,19 @@ static my_bool init_state_maps(CHARSET_INFO *cs)
   return 0;
 }
 
+
 static void simple_cs_init_functions(CHARSET_INFO *cs)
 {
   if (cs->state & MY_CS_BINSORT)
     cs->coll= &my_collation_8bit_bin_handler;
   else
     cs->coll= &my_collation_8bit_simple_ci_handler;
-
+  
   cs->cset= &my_charset_8bit_handler;
 }
 
+
+
 static int cs_copy_data(CHARSET_INFO *to, CHARSET_INFO *from)
 {
   to->number= from->number ? from->number : to->number;
@@ -131,47 +137,48 @@ static int cs_copy_data(CHARSET_INFO *to, CHARSET_INFO *from)
   if (from->csname)
     if (!(to->csname= my_once_strdup(from->csname,MYF(MY_WME))))
       goto err;
-
+  
   if (from->name)
     if (!(to->name= my_once_strdup(from->name,MYF(MY_WME))))
       goto err;
-
+  
   if (from->comment)
     if (!(to->comment= my_once_strdup(from->comment,MYF(MY_WME))))
       goto err;
-
+  
   if (from->ctype)
   {
     if (!(to->ctype= (uchar*) my_once_memdup((char*) from->ctype,
-                         MY_CS_CTYPE_TABLE_SIZE,
-                         MYF(MY_WME))))
+					     MY_CS_CTYPE_TABLE_SIZE,
+					     MYF(MY_WME))))
       goto err;
     if (init_state_maps(to))
       goto err;
   }
   if (from->to_lower)
     if (!(to->to_lower= (uchar*) my_once_memdup((char*) from->to_lower,
-                        MY_CS_TO_LOWER_TABLE_SIZE,
-                        MYF(MY_WME))))
+						MY_CS_TO_LOWER_TABLE_SIZE,
+						MYF(MY_WME))))
       goto err;
 
   if (from->to_upper)
     if (!(to->to_upper= (uchar*) my_once_memdup((char*) from->to_upper,
-                        MY_CS_TO_UPPER_TABLE_SIZE,
-                        MYF(MY_WME))))
+						MY_CS_TO_UPPER_TABLE_SIZE,
+						MYF(MY_WME))))
       goto err;
   if (from->sort_order)
   {
     if (!(to->sort_order= (uchar*) my_once_memdup((char*) from->sort_order,
-                          MY_CS_SORT_ORDER_TABLE_SIZE,
-                          MYF(MY_WME))))
+						  MY_CS_SORT_ORDER_TABLE_SIZE,
+						  MYF(MY_WME))))
       goto err;
+
   }
   if (from->tab_to_uni)
   {
     uint sz= MY_CS_TO_UNI_TABLE_SIZE*sizeof(uint16);
     if (!(to->tab_to_uni= (uint16*)  my_once_memdup((char*)from->tab_to_uni,
-                            sz, MYF(MY_WME))))
+						    sz, MYF(MY_WME))))
       goto err;
   }
   if (from->tailoring)
@@ -184,14 +191,17 @@ static int cs_copy_data(CHARSET_INFO *to, CHARSET_INFO *from)
   return 1;
 }
 
+
+
 static my_bool simple_cs_is_full(CHARSET_INFO *cs)
 {
   return ((cs->csname && cs->tab_to_uni && cs->ctype && cs->to_upper &&
-       cs->to_lower) &&
-      (cs->number && cs->name &&
-      (cs->sort_order || (cs->state & MY_CS_BINSORT) )));
+	   cs->to_lower) &&
+	  (cs->number && cs->name &&
+	  (cs->sort_order || (cs->state & MY_CS_BINSORT) )));
 }
 
+
 static void
 copy_uca_collation(CHARSET_INFO *to, CHARSET_INFO *from)
 {
@@ -206,6 +216,7 @@ static my_bool simple_cs_is_full(CHARSET_INFO *cs)
               MY_CS_STRNXFRM  | MY_CS_UNICODE;
 }
 
+
 static int add_collation(CHARSET_INFO *cs)
 {
   if (cs->name && (cs->number ||
@@ -219,15 +230,15 @@ static int add_collation(CHARSET_INFO *cs)
         return MY_XML_ERROR;
       bzero((void*)all_charsets[cs->number],sizeof(CHARSET_INFO));
     }
-
+    
     if (cs->primary_number == cs->number)
       cs->state |= MY_CS_PRIMARY;
-
+      
     if (cs->binary_number == cs->number)
       cs->state |= MY_CS_BINSORT;
-
+    
     all_charsets[cs->number]->state|= cs->state;
-
+    
     if (!(all_charsets[cs->number]->state & MY_CS_COMPILED))
     {
       CHARSET_INFO *newcs= all_charsets[cs->number];
@@ -241,7 +252,7 @@ static int add_collation(CHARSET_INFO *cs)
 #if defined(HAVE_CHARSET_ucs2) && defined(HAVE_UCA_COLLATIONS)
         copy_uca_collation(newcs, &my_charset_ucs2_unicode_ci);
         newcs->state|= MY_CS_AVAILABLE | MY_CS_LOADED | MY_CS_NONASCII;
-#endif
+#endif        
       }
       else if (!strcmp(cs->csname, "utf8") || !strcmp(cs->csname, "utf8mb3"))
       {
@@ -285,16 +296,16 @@ static int add_collation(CHARSET_INFO *cs)
           all_charsets[cs->number]->state |= MY_CS_LOADED;
         }
         all_charsets[cs->number]->state|= MY_CS_AVAILABLE;
-
+        
         /*
           Check if case sensitive sort order: A < a < B.
           We need MY_CS_FLAG for regex library, and for
           case sensitivity flag for 5.0 client protocol,
-          to support isCaseSensitive() method in JDBC driver
+          to support isCaseSensitive() method in JDBC driver 
         */
         if (sort_order && sort_order['A'] < sort_order['a'] &&
                           sort_order['a'] < sort_order['B'])
-          all_charsets[cs->number]->state|= MY_CS_CSSORT;
+          all_charsets[cs->number]->state|= MY_CS_CSSORT; 
 
         if (my_charset_is_8bit_pure_ascii(all_charsets[cs->number]))
           all_charsets[cs->number]->state|= MY_CS_PUREASCII;
@@ -316,14 +327,14 @@ static int add_collation(CHARSET_INFO *cs)
       CHARSET_INFO *dst= all_charsets[cs->number];
       dst->number= cs->number;
       if (cs->comment)
-    if (!(dst->comment= my_once_strdup(cs->comment,MYF(MY_WME))))
-      return MY_XML_ERROR;
+	if (!(dst->comment= my_once_strdup(cs->comment,MYF(MY_WME))))
+	  return MY_XML_ERROR;
       if (cs->csname)
         if (!(dst->csname= my_once_strdup(cs->csname,MYF(MY_WME))))
-      return MY_XML_ERROR;
+	  return MY_XML_ERROR;
       if (cs->name)
-    if (!(dst->name= my_once_strdup(cs->name,MYF(MY_WME))))
-      return MY_XML_ERROR;
+	if (!(dst->name= my_once_strdup(cs->name,MYF(MY_WME))))
+	  return MY_XML_ERROR;
     }
     cs->number= 0;
     cs->primary_number= 0;
@@ -336,40 +347,42 @@ static int add_collation(CHARSET_INFO *cs)
   return MY_XML_OK;
 }
 
+
 #define MY_MAX_ALLOWED_BUF 1024*1024
 #define MY_CHARSET_INDEX "Index.xml"
 
 const char *charsets_dir= NULL;
 
+
 static my_bool my_read_charset_file(const char *filename, myf myflags)
 {
   uchar *buf;
   int  fd;
   size_t len, tmp_len;
   MY_STAT stat_info;
-
+  
   if (!my_stat(filename, &stat_info, MYF(myflags)) ||
        ((len= (uint)stat_info.st_size) > MY_MAX_ALLOWED_BUF) ||
        !(buf= (uchar*) my_malloc(len,myflags)))
     return TRUE;
-
+  
   if ((fd= mysql_file_open(key_file_charset, filename, O_RDONLY, myflags)) < 0)
     goto error;
   tmp_len= mysql_file_read(fd, buf, len, myflags);
   mysql_file_close(fd, myflags);
   if (tmp_len != len)
     goto error;
-
+  
   if (my_parse_charset_xml((char*) buf,len,add_collation))
   {
 #ifdef NOT_YET
     printf("ERROR at line %d pos %d '%s'\n",
-       my_xml_error_lineno(&p)+1,
-       my_xml_error_pos(&p),
-       my_xml_error_string(&p));
+	   my_xml_error_lineno(&p)+1,
+	   my_xml_error_pos(&p),
+	   my_xml_error_string(&p));
 #endif
   }
-
+  
   my_free(buf);
   return FALSE;
 
@@ -378,6 +391,7 @@ static my_bool my_read_charset_file(const char *filename, myf myflags)
   return TRUE;
 }
 
+
 char *get_charsets_dir(char *buf)
 {
   const char *sharedir= SHAREDIR;
@@ -389,11 +403,11 @@ char *get_charsets_dir(char *buf)
   else
   {
     if (test_if_hard_path(sharedir) ||
-    is_prefix(sharedir, DEFAULT_CHARSET_HOME))
+	is_prefix(sharedir, DEFAULT_CHARSET_HOME))
       strxmov(buf, sharedir, "/", CHARSET_DIR, NullS);
     else
       strxmov(buf, DEFAULT_CHARSET_HOME, "/", sharedir, "/", CHARSET_DIR,
-          NullS);
+	      NullS);
   }
   res= convert_dirname(buf,buf,NullS);
   DBUG_PRINT("info",("charsets dir: '%s'", buf));
@@ -415,6 +429,7 @@ static void *cs_alloc(size_t size)
   return my_once_alloc(size, MYF(MY_WME));
 }
 
+
 static my_pthread_once_t charsets_initialized= MY_PTHREAD_ONCE_INIT;
 static my_pthread_once_t charsets_template= MY_PTHREAD_ONCE_INIT;
 
@@ -443,11 +458,13 @@ static void init_available_charsets(void)
   my_read_charset_file(fname, MYF(0));
 }
 
+
 void free_charsets(void)
 {
   charsets_initialized= charsets_template;
 }
 
+
 static const char*
 get_collation_name_alias(const char *name, char *buf, size_t bufsize)
 {
@@ -459,6 +476,7 @@ void free_charsets(void)
   return NULL;
 }
 
+
 uint get_collation_number(const char *name)
 {
   uint id;
@@ -471,11 +489,12 @@ uint get_collation_number(const char *name)
   return 0;
 }
 
+
 static uint
 get_charset_number_internal(const char *charset_name, uint cs_flags)
 {
   CHARSET_INFO **cs;
-
+  
   for (cs= all_charsets;
        cs < all_charsets + array_elements(all_charsets);
        cs++)
@@ -483,10 +502,11 @@ uint get_collation_number(const char *name)
     if ( cs[0] && cs[0]->csname && (cs[0]->state & cs_flags) &&
          !my_strcasecmp(&my_charset_latin1, cs[0]->csname, charset_name))
       return cs[0]->number;
-  }
+  }  
   return 0;
 }
 
+
 static const char*
 get_charset_name_alias(const char *name)
 {
@@ -495,6 +515,7 @@ uint get_collation_number(const char *name)
   return NULL;
 }
 
+
 uint get_charset_number(const char *charset_name, uint cs_flags)
 {
   uint id;
@@ -505,6 +526,7 @@ uint get_charset_number(const char *charset_name, uint cs_flags)
     return get_charset_number_internal(charset_name, cs_flags);
   return 0;
 }
+                  
 
 const char *get_charset_name(uint charset_number)
 {
@@ -517,10 +539,11 @@ const char *get_charset_name(uint charset_number)
     if (cs && (cs->number == charset_number) && cs->name)
       return (char*) cs->name;
   }
-
+  
   return "?";   /* this mimics find_type() */
 }
 
+
 static CHARSET_INFO *get_internal_charset(uint cs_number, myf flags)
 {
   char  buf[FN_REFLEN];
@@ -564,6 +587,7 @@ static CHARSET_INFO *get_internal_charset(uint cs_number, myf flags)
   return cs;
 }
 
+
 CHARSET_INFO *get_charset(uint cs_number, myf flags)
 {
   CHARSET_INFO *cs;
@@ -571,10 +595,10 @@ CHARSET_INFO *get_charset(uint cs_number, myf flags)
     return default_charset_info;
 
   my_pthread_once(&charsets_initialized, init_available_charsets);
-
-  if (cs_number >= array_elements(all_charsets))
+ 
+  if (cs_number >= array_elements(all_charsets)) 
     return NULL;
-
+  
   cs=get_internal_charset(cs_number, flags);
 
   if (!cs && (flags & MY_WME))
@@ -607,9 +631,10 @@ CHARSET_INFO *get_charset_by_name(const char *cs_name, myf flags)
   return cs;
 }
 
+
 CHARSET_INFO *get_charset_by_csname(const char *cs_name,
-                    uint cs_flags,
-                    myf flags)
+				    uint cs_flags,
+				    myf flags)
 {
   uint cs_number;
   CHARSET_INFO *cs;
@@ -631,6 +656,7 @@ CHARSET_INFO *get_charset_by_csname(const char *cs_name,
   DBUG_RETURN(cs);
 }
 
+
 /**
   Resolve character set by the character set name (utf8, latin1, ...).
 
@@ -662,6 +688,7 @@ my_bool resolve_charset(const char *cs_name,
   return FALSE;
 }
 
+
 /**
   Resolve collation by the collation name (utf8_general_ci, ...).
 
@@ -693,6 +720,7 @@ my_bool resolve_collation(const char *cl_name,
   return FALSE;
 }
 
+
 /*
   Escape string with backslashes (\)
 
@@ -741,7 +769,7 @@ size_t escape_string_for_mysql(CHARSET_INFO *charset_info,
         break;
       }
       while (tmp_length--)
-    *to++= *from++;
+	*to++= *from++;
       from--;
       continue;
     }
@@ -807,6 +835,7 @@ size_t escape_string_for_mysql(CHARSET_INFO *charset_info,
   return overflow ? (size_t) -1 : (size_t) (to - to_start);
 }
 
+
 #ifdef BACKSLASH_MBTAIL
 static CHARSET_INFO *fs_cset_cache= NULL;
 
@@ -879,7 +908,7 @@ size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,
         break;
       }
       while (tmp_length--)
-    *to++= *from++;
+	*to++= *from++;
       from--;
       continue;
     }
@@ -911,4 +940,4 @@ size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,
   }
   *to= 0;
   return overflow ? (ulong)~0 : (ulong) (to - to_start);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/checksum.c b/dep/mysqllite/mysys/checksum.c
index 682e2eb..87f3056 100644
--- a/dep/mysqllite/mysys/checksum.c
+++ b/dep/mysqllite/mysys/checksum.c
@@ -13,6 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
+
 #include <my_global.h>
 #include <my_sys.h>
 #include <zlib.h>
@@ -30,4 +31,5 @@
 ha_checksum my_checksum(ha_checksum crc, const uchar *pos, size_t length)
 {
   return (ha_checksum)crc32((uint)crc, pos, (uint)length);
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/default.c b/dep/mysqllite/mysys/default.c
index 7a14260..fe070f4 100644
--- a/dep/mysqllite/mysys/default.c
+++ b/dep/mysqllite/mysys/default.c
@@ -119,11 +119,12 @@ struct handle_option_ctx
 };
 
 static int search_default_file(Process_option_func func, void *func_ctx,
-                   const char *dir, const char *config_file);
+			       const char *dir, const char *config_file);
 static int search_default_file_with_ext(Process_option_func func,
                                         void *func_ctx,
-                    const char *dir, const char *ext,
-                    const char *config_file, int recursion_level);
+					const char *dir, const char *ext,
+					const char *config_file, int recursion_level);
+
 
 /**
   Create the list of default directories.
@@ -153,8 +154,10 @@ static int search_default_file_with_ext(Process_option_func func,
 
 static const char **init_default_directories(MEM_ROOT *alloc);
 
+
 static char *remove_end_comment(char *ptr);
 
+
 /*
   Expand a file name so that the current working directory is added if
   the name is relative.
@@ -205,6 +208,7 @@ static int search_default_file_with_ext(Process_option_func func,
     --defaults-group-suffix is only processed if we are called from
     load_defaults().
 
+
   RETURN
     0  ok
     1  given cinf_file doesn't exist
@@ -260,37 +264,37 @@ int my_search_option_files(const char *conf_file, int *argc, char ***argv,
     /* Handle --defaults-group-suffix= */
     uint i;
     const char **extra_groups;
-    const size_t instance_len= strlen(my_defaults_group_suffix);
+    const size_t instance_len= strlen(my_defaults_group_suffix); 
     struct handle_option_ctx *ctx= (struct handle_option_ctx*) func_ctx;
     char *ptr;
     TYPELIB *group= ctx->group;
-
-    if (!(extra_groups=
-      (const char**)alloc_root(ctx->alloc,
+    
+    if (!(extra_groups= 
+	  (const char**)alloc_root(ctx->alloc,
                                    (2*group->count+1)*sizeof(char*))))
       DBUG_RETURN(2);
-
+    
     for (i= 0; i < group->count; i++)
     {
       size_t len;
       extra_groups[i]= group->type_names[i]; /** copy group */
-
+      
       len= strlen(extra_groups[i]);
       if (!(ptr= alloc_root(ctx->alloc, (uint) (len+instance_len+1))))
        DBUG_RETURN(2);
-
+      
       extra_groups[i+group->count]= ptr;
-
+      
       /** Construct new group */
       memcpy(ptr, extra_groups[i], len);
       memcpy(ptr+len, my_defaults_group_suffix, instance_len+1);
     }
-
+    
     group->count*= 2;
     group->type_names= extra_groups;
     group->type_names[group->count]= 0;
   }
-
+  
   if (my_defaults_file)
   {
     if ((error= search_default_file_with_ext(func, func_ctx, "", "",
@@ -314,14 +318,14 @@ int my_search_option_files(const char *conf_file, int *argc, char ***argv,
     {
       if (**dirs)
       {
-    if (search_default_file(func, func_ctx, *dirs, conf_file) < 0)
-      goto err;
+	if (search_default_file(func, func_ctx, *dirs, conf_file) < 0)
+	  goto err;
       }
       else if (my_defaults_extra_file)
       {
         if ((error= search_default_file_with_ext(func, func_ctx, "", "",
                                                 my_defaults_extra_file, 0)) < 0)
-      goto err;				/* Fatal error */
+	  goto err;				/* Fatal error */
         if (error > 0)
         {
           fprintf(stderr, "Could not open required defaults file: %s\n",
@@ -339,6 +343,7 @@ int my_search_option_files(const char *conf_file, int *argc, char ***argv,
   DBUG_RETURN(1);
 }
 
+
 /*
   The option handler for load_defaults.
 
@@ -383,6 +388,7 @@ static int handle_default_option(void *in_ctx, const char *group_name,
   return 0;
 }
 
+
 /*
   Gets options from the command line
 
@@ -440,9 +446,9 @@ int get_defaults_options(int argc, char **argv,
   SYNOPSIS
     load_defaults()
     conf_file			Basename for configuration file to search for.
-                    If this is a path, then only this file is read.
+    				If this is a path, then only this file is read.
     groups			Which [group] entrys to read.
-                Points to an null terminated array of pointers
+				Points to an null terminated array of pointers
     argc			Pointer to argc of original program
     argv			Pointer to argv of original program
 
@@ -467,9 +473,9 @@ int load_defaults(const char *conf_file, const char **groups,
   SYNOPSIS
     my_load_defaults()
     conf_file			Basename for configuration file to search for.
-                    If this is a path, then only this file is read.
+    				If this is a path, then only this file is read.
     groups			Which [group] entrys to read.
-                Points to an null terminated array of pointers
+				Points to an null terminated array of pointers
     argc			Pointer to argc of original program
     argv			Pointer to argv of original program
     default_directories         Pointer to a location where a pointer to the list
@@ -484,7 +490,7 @@ int load_defaults(const char *conf_file, const char **groups,
    NOTES
     In case of fatal error, the function will print a warning and do
     exit(1)
-
+ 
     To free used memory one should call free_defaults() with the argument
     that was put in *argv
 
@@ -493,11 +499,12 @@ int load_defaults(const char *conf_file, const char **groups,
      a pointer to the array of default directory paths is stored to a location
      it points to. That stored value must be passed to my_search_option_files()
      later.
-
+     
      - 1 is returned if the given conf_file didn't exist. In this case, the
      value pointed to by default_directories is undefined.
 */
 
+
 int my_load_defaults(const char *conf_file, const char **groups,
                   int *argc, char ***argv, const char ***default_directories)
 {
@@ -525,7 +532,7 @@ int my_load_defaults(const char *conf_file, const char **groups,
     /* remove the --no-defaults argument and return only the other arguments */
     uint i, j;
     if (!(ptr=(char*) alloc_root(&alloc,sizeof(alloc)+
-                 (*argc + 1)*sizeof(char*))))
+				 (*argc + 1)*sizeof(char*))))
       goto err;
     res= (char**) (ptr+sizeof(alloc));
     res[0]= **argv;				/* Copy program name */
@@ -578,7 +585,7 @@ int my_load_defaults(const char *conf_file, const char **groups,
     or a forced default file
   */
   if (!(ptr=(char*) alloc_root(&alloc,sizeof(alloc)+
-                   (args.elements + *argc + 1 + args_sep) *sizeof(char*))))
+			       (args.elements + *argc + 1 + args_sep) *sizeof(char*))))
     goto err;
   res= (char**) (ptr+sizeof(alloc));
 
@@ -608,7 +615,7 @@ int my_load_defaults(const char *conf_file, const char **groups,
 
   if (*argc)
     memcpy((uchar*) (res+1+args.elements+args_sep), (char*) ((*argv)+1),
-       (*argc-1)*sizeof(char*));
+	   (*argc-1)*sizeof(char*));
   res[args.elements+ *argc+args_sep]=0;                /* last null */
 
   (*argc)+=args.elements+args_sep;
@@ -619,7 +626,7 @@ int my_load_defaults(const char *conf_file, const char **groups,
   {
     int i;
     printf("%s would have been started with the following arguments:\n",
-       **argv);
+	   **argv);
     for (i=1 ; i < *argc ; i++)
       if (!my_getopt_is_args_separator((*argv)[i])) /* skip arguments separator */
         printf("%s ", (*argv)[i]);
@@ -638,6 +645,7 @@ int my_load_defaults(const char *conf_file, const char **groups,
   return 0;					/* Keep compiler happy */
 }
 
+
 void free_defaults(char **argv)
 {
   MEM_ROOT ptr;
@@ -645,10 +653,11 @@ void free_defaults(char **argv)
   free_root(&ptr,MYF(0));
 }
 
+
 static int search_default_file(Process_option_func opt_handler,
                                void *handler_ctx,
-                   const char *dir,
-                   const char *config_file)
+			       const char *dir,
+			       const char *config_file)
 {
   char **ext;
   const char *empty_list[]= { "", 0 };
@@ -660,12 +669,13 @@ static int search_default_file(Process_option_func opt_handler,
     int error;
     if ((error= search_default_file_with_ext(opt_handler, handler_ctx,
                                              dir, *ext,
-                         config_file, 0)) < 0)
+					     config_file, 0)) < 0)
       return error;
   }
   return 0;
 }
 
+
 /*
   Skip over keyword and get argument after keyword
 
@@ -708,13 +718,14 @@ static char *get_argument(const char *keyword, size_t kwlen,
   if (end <= ptr)
   {
     fprintf(stderr,
-        "error: Wrong '!%s' directive in config file: %s at line %d\n",
-        keyword, name, line);
+	    "error: Wrong '!%s' directive in config file: %s at line %d\n",
+	    keyword, name, line);
     return 0;
   }
   return ptr;
 }
 
+
 /*
   Open a configuration file (if exists) and read given options from it
 
@@ -722,7 +733,7 @@ static char *get_argument(const char *keyword, size_t kwlen,
     search_default_file_with_ext()
     opt_handler                 Option handler function. It is used to process
                                 every separate option.
-    handler_ctx                 Pointer to the structure to store actual
+    handler_ctx                 Pointer to the structure to store actual 
                                 parameters of the function.
     dir				directory to read
     ext				Extension for configuration file
@@ -778,10 +789,10 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
     /*
       Ignore world-writable regular files.
       This is mainly done to protect us to not read a file created by
-      the mysqld server, but the check is still valid in most context.
+      the mysqld server, but the check is still valid in most context. 
     */
     if ((stat_info.st_mode & S_IWOTH) &&
-    (stat_info.st_mode & S_IFMT) == S_IFREG)
+	(stat_info.st_mode & S_IFMT) == S_IFREG)
     {
       fprintf(stderr, "Warning: World-writable config file '%s' is ignored\n",
               name);
@@ -807,7 +818,7 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
     {
       if (recursion_level >= max_recursion_level)
       {
-        for (end= ptr + strlen(ptr) - 1;
+        for (end= ptr + strlen(ptr) - 1; 
              my_isspace(&my_charset_latin1, *(end - 1));
              end--)
         {}
@@ -827,10 +838,10 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
                     sizeof(includedir_keyword) - 1)) &&
           my_isspace(&my_charset_latin1, ptr[sizeof(includedir_keyword) - 1]))
       {
-    if (!(ptr= get_argument(includedir_keyword,
+	if (!(ptr= get_argument(includedir_keyword,
                                 sizeof(includedir_keyword),
                                 ptr, name, line)))
-      goto err;
+	  goto err;
 
         if (!(search_dir= my_dir(ptr, MYF(MY_WME))))
           goto err;
@@ -862,10 +873,10 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
       else if ((!strncmp(ptr, include_keyword, sizeof(include_keyword) - 1)) &&
                my_isspace(&my_charset_latin1, ptr[sizeof(include_keyword)-1]))
       {
-    if (!(ptr= get_argument(include_keyword,
+	if (!(ptr= get_argument(include_keyword,
                                 sizeof(include_keyword), ptr,
                                 name, line)))
-      goto err;
+	  goto err;
 
         search_default_file_with_ext(opt_handler, handler_ctx, "", "", ptr,
                                      recursion_level + 1);
@@ -879,10 +890,10 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
       found_group=1;
       if (!(end=(char *) strchr(++ptr,']')))
       {
-    fprintf(stderr,
-        "error: Wrong group definition in config file: %s at line %d\n",
-        name,line);
-    goto err;
+	fprintf(stderr,
+		"error: Wrong group definition in config file: %s at line %d\n",
+		name,line);
+	goto err;
       }
       /* Remove end space */
       for ( ; my_isspace(&my_charset_latin1,end[-1]) ; end--) ;
@@ -898,11 +909,12 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
     if (!found_group)
     {
       fprintf(stderr,
-          "error: Found option without preceding group in config file: %s at line: %d\n",
-          name,line);
+	      "error: Found option without preceding group in config file: %s at line: %d\n",
+	      name,line);
       goto err;
     }
-
+    
+   
     end= remove_end_comment(ptr);
     if ((value= strchr(ptr, '=')))
       end= value;				/* Option without argument */
@@ -920,61 +932,61 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
       for (value++ ; my_isspace(&my_charset_latin1,*value); value++) ;
       value_end=strend(value);
       /*
-    We don't have to test for value_end >= value as we know there is
-    an '=' before
+	We don't have to test for value_end >= value as we know there is
+	an '=' before
       */
       for ( ; my_isspace(&my_charset_latin1,value_end[-1]) ; value_end--) ;
       if (value_end < value)			/* Empty string */
-    value_end=value;
+	value_end=value;
 
       /* remove quotes around argument */
       if ((*value == '\"' || *value == '\'') && /* First char is quote */
           (value + 1 < value_end ) && /* String is longer than 1 */
           *value == value_end[-1] ) /* First char is equal to last char */
       {
-    value++;
-    value_end--;
+	value++;
+	value_end--;
       }
       ptr=strnmov(strmov(option,"--"),ptr,(size_t) (end-ptr));
       *ptr++= '=';
 
       for ( ; value != value_end; value++)
       {
-    if (*value == '\\' && value != value_end-1)
-    {
-      switch(*++value) {
-      case 'n':
-        *ptr++='\n';
-        break;
-      case 't':
-        *ptr++= '\t';
-        break;
-      case 'r':
-        *ptr++ = '\r';
-        break;
-      case 'b':
-        *ptr++ = '\b';
-        break;
-      case 's':
-        *ptr++= ' ';			/* space */
-        break;
-      case '\"':
-        *ptr++= '\"';
-        break;
-      case '\'':
-        *ptr++= '\'';
-        break;
-      case '\\':
-        *ptr++= '\\';
-        break;
-      default:				/* Unknown; Keep '\' */
-        *ptr++= '\\';
-        *ptr++= *value;
-        break;
-      }
-    }
-    else
-      *ptr++= *value;
+	if (*value == '\\' && value != value_end-1)
+	{
+	  switch(*++value) {
+	  case 'n':
+	    *ptr++='\n';
+	    break;
+	  case 't':
+	    *ptr++= '\t';
+	    break;
+	  case 'r':
+	    *ptr++ = '\r';
+	    break;
+	  case 'b':
+	    *ptr++ = '\b';
+	    break;
+	  case 's':
+	    *ptr++= ' ';			/* space */
+	    break;
+	  case '\"':
+	    *ptr++= '\"';
+	    break;
+	  case '\'':
+	    *ptr++= '\'';
+	    break;
+	  case '\\':
+	    *ptr++= '\\';
+	    break;
+	  default:				/* Unknown; Keep '\' */
+	    *ptr++= '\\';
+	    *ptr++= *value;
+	    break;
+	  }
+	}
+	else
+	  *ptr++= *value;
       }
       *ptr=0;
       if (opt_handler(handler_ctx, curr_gr, option))
@@ -989,6 +1001,7 @@ static int search_default_file_with_ext(Process_option_func opt_handler,
   return -1;					/* Fatal error */
 }
 
+
 static char *remove_end_comment(char *ptr)
 {
   char quote= 0;	/* we are inside quote marks */
@@ -999,9 +1012,9 @@ static char *remove_end_comment(char *ptr)
     if ((*ptr == '\'' || *ptr == '\"') && !escape)
     {
       if (!quote)
-    quote= *ptr;
+	quote= *ptr;
       else if (quote == *ptr)
-    quote= 0;
+	quote= 0;
     }
     /* We are not inside a string */
     if (!quote && *ptr == '#')
@@ -1014,6 +1027,7 @@ static char *remove_end_comment(char *ptr)
   return ptr;
 }
 
+
 void my_print_default_files(const char *conf_file)
 {
   const char *empty_list[]= { "", 0 };
@@ -1092,6 +1106,7 @@ void print_defaults(const char *conf_file, const char **groups)
 --defaults-extra-file=# Read this file after the global files are read.");
 }
 
+
 static int add_directory(MEM_ROOT *alloc, const char *dir, const char **dirs)
 {
   char buf[FN_REFLEN];
@@ -1109,6 +1124,7 @@ static int add_directory(MEM_ROOT *alloc, const char *dir, const char **dirs)
   return 0;
 }
 
+
 #ifdef __WIN__
 /*
   This wrapper for GetSystemWindowsDirectory() will dynamically bind to the
@@ -1131,7 +1147,7 @@ static size_t my_get_system_windows_directory(char *buffer, size_t size)
     return func_ptr(buffer, (uint) size);
 
   /*
-    Windows NT 4.0 Terminal Server Edition:
+    Windows NT 4.0 Terminal Server Edition:  
     To retrieve the shared Windows directory, call GetSystemDirectory and
     trim the "System32" element from the end of the returned path.
   */
@@ -1144,6 +1160,7 @@ static size_t my_get_system_windows_directory(char *buffer, size_t size)
   return count;
 }
 
+
 static const char *my_get_module_parent(char *buf, size_t size)
 {
   char *last= NULL;
@@ -1175,6 +1192,7 @@ static const char *my_get_module_parent(char *buf, size_t size)
 }
 #endif /* __WIN__ */
 
+
 static const char **init_default_directories(MEM_ROOT *alloc)
 {
   const char **dirs;
@@ -1225,4 +1243,4 @@ static const char **init_default_directories(MEM_ROOT *alloc)
 #endif
 
   return (errors > 0 ? NULL : dirs);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/errors.c b/dep/mysqllite/mysys/errors.c
index fffcc5d..b976578 100644
--- a/dep/mysqllite/mysys/errors.c
+++ b/dep/mysqllite/mysys/errors.c
@@ -116,4 +116,4 @@ void wait_for_free_space(const char *filename, int errors)
 const char **get_global_errmsgs()
 {
   return globerrs;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/hash.c b/dep/mysqllite/mysys/hash.c
index 9575ca9..ef478a7 100644
--- a/dep/mysqllite/mysys/hash.c
+++ b/dep/mysqllite/mysys/hash.c
@@ -49,7 +49,7 @@ static my_hash_value_type calc_hash(const HASH *hash,
 
 /**
   @brief Initialize the hash
-
+  
   @details
 
   Initialize the hash, by defining and giving valid values for
@@ -88,10 +88,11 @@ static my_hash_value_type calc_hash(const HASH *hash,
   hash->free=free_element;
   hash->flags=flags;
   hash->charset=charset;
-  DBUG_RETURN(my_init_dynamic_array_ci(&hash->array,
+  DBUG_RETURN(my_init_dynamic_array_ci(&hash->array, 
                                        sizeof(HASH_LINK), size, growth_size));
 }
 
+
 /*
   Call hash->free on all elements in hash.
 
@@ -115,6 +116,7 @@ static inline void my_hash_free_elements(HASH *hash)
   hash->records=0;
 }
 
+
 /*
   Free memory used by hash.
 
@@ -137,6 +139,7 @@ void my_hash_free(HASH *hash)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Delete all elements from the hash (the hash itself is to be reused).
 
@@ -174,7 +177,7 @@ void my_hash_reset(HASH *hash)
   return (char*) record+hash->key_offset;
 }
 
-    /* Calculate pos according to keys */
+	/* Calculate pos according to keys */
 
 static uint my_hash_mask(my_hash_value_type hashnr, size_t buffmax,
                          size_t maxlength)
@@ -191,6 +194,8 @@ static uint my_hash_rec_mask(const HASH *hash, HASH_LINK *pos,
   return my_hash_mask(calc_hash(hash, key, length), buffmax, maxlength);
 }
 
+
+
 /* for compilers which can not handle inline */
 static
 #if !defined(__USLC__) && !defined(__sgi)
@@ -203,13 +208,14 @@ my_hash_value_type rec_hashnr(HASH *hash,const uchar *record)
   return calc_hash(hash,key,length);
 }
 
+
 uchar* my_hash_search(const HASH *hash, const uchar *key, size_t length)
 {
   HASH_SEARCH_STATE state;
   return my_hash_first(hash, key, length, &state);
 }
 
-uchar* my_hash_search_using_hash_value(const HASH *hash,
+uchar* my_hash_search_using_hash_value(const HASH *hash, 
                                        my_hash_value_type hash_value,
                                        const uchar *key,
                                        size_t length)
@@ -225,6 +231,7 @@ my_hash_value_type my_calc_hash(const HASH *hash,
   return calc_hash(hash, key, length ? length : hash->key_length);
 }
 
+
 /*
   Search after a record based on a key
 
@@ -245,6 +252,7 @@ uchar* my_hash_first(const HASH *hash, const uchar *key, size_t length,
   return res;
 }
 
+
 uchar* my_hash_first_from_hash_value(const HASH *hash,
                                      my_hash_value_type hash_value,
                                      const uchar *key,
@@ -265,15 +273,15 @@ uchar* my_hash_first_from_hash_value(const HASH *hash,
       pos= dynamic_element(&hash->array,idx,HASH_LINK*);
       if (!hashcmp(hash,pos,key,length))
       {
-    DBUG_PRINT("exit",("found key at %d",idx));
-    *current_record= idx;
-    DBUG_RETURN (pos->data);
+	DBUG_PRINT("exit",("found key at %d",idx));
+	*current_record= idx;
+	DBUG_RETURN (pos->data);
       }
       if (flag)
       {
-    flag=0;					/* Reset flag */
-    if (my_hash_rec_mask(hash, pos, hash->blength, hash->records) != idx)
-      break;				/* Wrong link */
+	flag=0;					/* Reset flag */
+	if (my_hash_rec_mask(hash, pos, hash->blength, hash->records) != idx)
+	  break;				/* Wrong link */
       }
     }
     while ((idx=pos->next) != NO_RECORD);
@@ -282,8 +290,8 @@ uchar* my_hash_first_from_hash_value(const HASH *hash,
   DBUG_RETURN(0);
 }
 
-    /* Get next record with identical key */
-    /* Can only be called if previous calls was my_hash_search */
+	/* Get next record with identical key */
+	/* Can only be called if previous calls was my_hash_search */
 
 uchar* my_hash_next(const HASH *hash, const uchar *key, size_t length,
                     HASH_SEARCH_STATE *current_record)
@@ -299,8 +307,8 @@ uchar* my_hash_next(const HASH *hash, const uchar *key, size_t length,
       pos=data+idx;
       if (!hashcmp(hash,pos,key,length))
       {
-    *current_record= idx;
-    return pos->data;
+	*current_record= idx;
+	return pos->data;
       }
     }
     *current_record= NO_RECORD;
@@ -308,7 +316,8 @@ uchar* my_hash_next(const HASH *hash, const uchar *key, size_t length,
   return 0;
 }
 
-    /* Change link from pos to new_link */
+
+	/* Change link from pos to new_link */
 
 static void movelink(HASH_LINK *array,uint find,uint next_link,uint newlink)
 {
@@ -347,11 +356,12 @@ static int hashcmp(const HASH *hash, HASH_LINK *pos, const uchar *key,
   size_t rec_keylength;
   uchar *rec_key= (uchar*) my_hash_key(hash, pos->data, &rec_keylength, 1);
   return ((length && length != rec_keylength) ||
-      my_strnncoll(hash->charset, (uchar*) rec_key, rec_keylength,
-               (uchar*) key, rec_keylength));
+	  my_strnncoll(hash->charset, (uchar*) rec_key, rec_keylength,
+		       (uchar*) key, rec_keylength));
 }
 
-    /* Write a hash-key to the hash-index */
+
+	/* Write a hash-key to the hash-index */
 
 my_bool my_hash_insert(HASH *info, const uchar *record)
 {
@@ -383,61 +393,61 @@ my_bool my_hash_insert(HASH *info, const uchar *record)
       pos=data+idx;
       hash_nr=rec_hashnr(info,pos->data);
       if (flag == 0)				/* First loop; Check if ok */
-    if (my_hash_mask(hash_nr, info->blength, info->records) != first_index)
-      break;
+	if (my_hash_mask(hash_nr, info->blength, info->records) != first_index)
+	  break;
       if (!(hash_nr & halfbuff))
       {						/* Key will not move */
-    if (!(flag & LOWFIND))
-    {
-      if (flag & HIGHFIND)
-      {
-        flag=LOWFIND | HIGHFIND;
-        /* key shall be moved to the current empty position */
-        gpos=empty;
-        ptr_to_rec=pos->data;
-        empty=pos;				/* This place is now free */
-      }
-      else
-      {
-        flag=LOWFIND | LOWUSED;		/* key isn't changed */
-        gpos=pos;
-        ptr_to_rec=pos->data;
-      }
-    }
-    else
-    {
-      if (!(flag & LOWUSED))
-      {
-        /* Change link of previous LOW-key */
-        gpos->data=ptr_to_rec;
-        gpos->next= (uint) (pos-data);
-        flag= (flag & HIGHFIND) | (LOWFIND | LOWUSED);
-      }
-      gpos=pos;
-      ptr_to_rec=pos->data;
-    }
+	if (!(flag & LOWFIND))
+	{
+	  if (flag & HIGHFIND)
+	  {
+	    flag=LOWFIND | HIGHFIND;
+	    /* key shall be moved to the current empty position */
+	    gpos=empty;
+	    ptr_to_rec=pos->data;
+	    empty=pos;				/* This place is now free */
+	  }
+	  else
+	  {
+	    flag=LOWFIND | LOWUSED;		/* key isn't changed */
+	    gpos=pos;
+	    ptr_to_rec=pos->data;
+	  }
+	}
+	else
+	{
+	  if (!(flag & LOWUSED))
+	  {
+	    /* Change link of previous LOW-key */
+	    gpos->data=ptr_to_rec;
+	    gpos->next= (uint) (pos-data);
+	    flag= (flag & HIGHFIND) | (LOWFIND | LOWUSED);
+	  }
+	  gpos=pos;
+	  ptr_to_rec=pos->data;
+	}
       }
       else
       {						/* key will be moved */
-    if (!(flag & HIGHFIND))
-    {
-      flag= (flag & LOWFIND) | HIGHFIND;
-      /* key shall be moved to the last (empty) position */
-      gpos2 = empty; empty=pos;
-      ptr_to_rec2=pos->data;
-    }
-    else
-    {
-      if (!(flag & HIGHUSED))
-      {
-        /* Change link of previous hash-key and save */
-        gpos2->data=ptr_to_rec2;
-        gpos2->next=(uint) (pos-data);
-        flag= (flag & LOWFIND) | (HIGHFIND | HIGHUSED);
-      }
-      gpos2=pos;
-      ptr_to_rec2=pos->data;
-    }
+	if (!(flag & HIGHFIND))
+	{
+	  flag= (flag & LOWFIND) | HIGHFIND;
+	  /* key shall be moved to the last (empty) position */
+	  gpos2 = empty; empty=pos;
+	  ptr_to_rec2=pos->data;
+	}
+	else
+	{
+	  if (!(flag & HIGHUSED))
+	  {
+	    /* Change link of previous hash-key and save */
+	    gpos2->data=ptr_to_rec2;
+	    gpos2->next=(uint) (pos-data);
+	    flag= (flag & LOWFIND) | (HIGHFIND | HIGHUSED);
+	  }
+	  gpos2=pos;
+	  ptr_to_rec2=pos->data;
+	}
       }
     }
     while ((idx=pos->next) != NO_RECORD);
@@ -484,6 +494,7 @@ my_bool my_hash_insert(HASH *info, const uchar *record)
   return(0);
 }
 
+
 /******************************************************************************
 ** Remove one record from hash-table. The record with the same record
 ** ptr is removed.
@@ -573,10 +584,10 @@ my_bool my_hash_delete(HASH *hash, uchar *record)
   DBUG_RETURN(0);
 }
 
-    /*
-      Update keys when record has changed.
-      This is much more efficent than using a delete & insert.
-      */
+	/*
+	  Update keys when record has changed.
+	  This is much more efficent than using a delete & insert.
+	  */
 
 my_bool my_hash_update(HASH *hash, uchar *record, uchar *old_key,
                        size_t old_key_length)
@@ -585,18 +596,18 @@ my_bool my_hash_update(HASH *hash, uchar *record, uchar *old_key,
   size_t idx,empty;
   HASH_LINK org_link,*data,*previous,*pos;
   DBUG_ENTER("my_hash_update");
-
+  
   if (HASH_UNIQUE & hash->flags)
   {
     HASH_SEARCH_STATE state;
     uchar *found, *new_key= (uchar*) my_hash_key(hash, record, &idx, 1);
     if ((found= my_hash_first(hash, new_key, idx, &state)))
     {
-      do
+      do 
       {
         if (found != record)
           DBUG_RETURN(1);		/* Duplicate entry */
-      }
+      } 
       while ((found= my_hash_next(hash, new_key, idx, &state)));
     }
   }
@@ -616,6 +627,7 @@ my_bool my_hash_update(HASH *hash, uchar *record, uchar *old_key,
   previous=0;
   for (;;)
   {
+
     if ((pos= data+idx)->data == record)
       break;
     previous=pos;
@@ -676,6 +688,7 @@ my_bool my_hash_update(HASH *hash, uchar *record, uchar *old_key,
   DBUG_RETURN(0);
 }
 
+
 uchar *my_hash_element(HASH *hash, ulong idx)
 {
   if (idx < hash->records)
@@ -683,6 +696,7 @@ uchar *my_hash_element(HASH *hash, ulong idx)
   return 0;
 }
 
+
 /*
   Replace old row with new row.  This should only be used when key
   isn't changed
@@ -695,6 +709,7 @@ void my_hash_replace(HASH *hash, HASH_SEARCH_STATE *current_record,
     dynamic_element(&hash->array, *current_record, HASH_LINK*)->data= new_row;
 }
 
+
 #ifndef DBUG_OFF
 
 my_bool my_hash_check(HASH *hash)
@@ -714,28 +729,28 @@ my_bool my_hash_check(HASH *hash)
     {
       found++; seek++; links=1;
       for (idx=data[i].next ;
-       idx != NO_RECORD && found < records + 1;
-       idx=hash_info->next)
+	   idx != NO_RECORD && found < records + 1;
+	   idx=hash_info->next)
       {
-    if (idx >= records)
-    {
-      DBUG_PRINT("error",
-             ("Found pointer outside array to %d from link starting at %d",
-              idx,i));
-      error=1;
-    }
-    hash_info=data+idx;
-    seek+= ++links;
-    if ((rec_link= my_hash_rec_mask(hash, hash_info,
+	if (idx >= records)
+	{
+	  DBUG_PRINT("error",
+		     ("Found pointer outside array to %d from link starting at %d",
+		      idx,i));
+	  error=1;
+	}
+	hash_info=data+idx;
+	seek+= ++links;
+	if ((rec_link= my_hash_rec_mask(hash, hash_info,
                                         blength, records)) != i)
-    {
+	{
           DBUG_PRINT("error", ("Record in wrong link at %d: Start %d  "
                                "Record: 0x%lx  Record-link %d",
                                idx, i, (long) hash_info->data, rec_link));
-      error=1;
-    }
-    else
-      found++;
+	  error=1;
+	}
+	else
+	  found++;
       }
       if (links > max_links) max_links=links;
     }
@@ -747,8 +762,8 @@ my_bool my_hash_check(HASH *hash)
   }
   if (records)
     DBUG_PRINT("info",
-           ("records: %u   seeks: %d   max links: %d   hitrate: %.2f",
-        records,seek,max_links,(float) seek / (float) records));
+	       ("records: %u   seeks: %d   max links: %d   hitrate: %.2f",
+		records,seek,max_links,(float) seek / (float) records));
   return error;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/lf_alloc-pin.c b/dep/mysqllite/mysys/lf_alloc-pin.c
index dca8195..7af87bc 100644
--- a/dep/mysqllite/mysys/lf_alloc-pin.c
+++ b/dep/mysqllite/mysys/lf_alloc-pin.c
@@ -211,13 +211,16 @@ void _lf_pinbox_put_pins(LF_PINS *pins)
   LF_PINBOX *pinbox= pins->pinbox;
   uint32 top_ver, nr;
   nr= pins->link;
-#ifdef MY_LF_EXTRA_DEBUG
+
+#ifndef DBUG_OFF
   {
+    /* This thread should not hold any pin. */
     int i;
     for (i= 0; i < LF_PINBOX_PINS; i++)
       DBUG_ASSERT(pins->pin[i] == 0);
   }
-#endif
+#endif /* DBUG_OFF */
+
   /*
     XXX this will deadlock if other threads will wait for
     the caller to do something after _lf_pinbox_put_pins(),
@@ -531,4 +534,5 @@ uint lf_alloc_pool_count(LF_ALLOCATOR *allocator)
   for (node= allocator->top, i= 0; node; node= anext_node(node), i++)
     /* no op */;
   return i;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/lf_dynarray.c b/dep/mysqllite/mysys/lf_dynarray.c
index d099b39..3d072fd 100644
--- a/dep/mysqllite/mysys/lf_dynarray.c
+++ b/dep/mysqllite/mysys/lf_dynarray.c
@@ -203,4 +203,5 @@ int _lf_dynarray_iterate(LF_DYNARRAY *array, lf_dynarray_func func, void *arg)
     if ((res= recursive_iterate(array, array->level[i], i, func, arg)))
       return res;
   return 0;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/lf_hash.c b/dep/mysqllite/mysys/lf_hash.c
index 19bac56..4f0a3a3 100644
--- a/dep/mysqllite/mysys/lf_hash.c
+++ b/dep/mysqllite/mysys/lf_hash.c
@@ -500,4 +500,4 @@ static int initialize_bucket(LF_HASH *hash, LF_SLIST * volatile *node,
     and we should not free(dummy) - there's no memory leak here
   */
   return 0;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/list.c b/dep/mysqllite/mysys/list.c
index 2f978a0..fb46120 100644
--- a/dep/mysqllite/mysys/list.c
+++ b/dep/mysqllite/mysys/list.c
@@ -20,7 +20,9 @@
 #include "mysys_priv.h"
 #include <my_list.h>
 
-    /* Add a element to start of list */
+
+
+	/* Add a element to start of list */
 
 LIST *list_add(LIST *root, LIST *element)
 {
@@ -39,6 +41,7 @@ LIST *list_add(LIST *root, LIST *element)
   DBUG_RETURN(element);			/* New root */
 }
 
+
 LIST *list_delete(LIST *root, LIST *element)
 {
   if (element->prev)
@@ -50,6 +53,7 @@ LIST *list_delete(LIST *root, LIST *element)
   return root;
 }
 
+
 void list_free(LIST *root, uint free_data)
 {
   LIST *next;
@@ -63,6 +67,7 @@ void list_free(LIST *root, uint free_data)
   }
 }
 
+
 LIST *list_cons(void *data, LIST *list)
 {
   LIST *new_charset=(LIST*) my_malloc(sizeof(LIST),MYF(MY_FAE));
@@ -72,6 +77,7 @@ LIST *list_cons(void *data, LIST *list)
   return list_add(list,new_charset);
 }
 
+
 LIST *list_reverse(LIST *root)
 {
   LIST *last;
@@ -94,6 +100,7 @@ uint list_length(LIST *list)
   return count;
 }
 
+
 int list_walk(LIST *list, list_walk_action action, uchar* argument)
 {
   int error=0;
@@ -104,4 +111,4 @@ int list_walk(LIST *list, list_walk_action action, uchar* argument)
     list=list_rest(list);
   }
   return 0;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/md5.c b/dep/mysqllite/mysys/md5.c
index b390561..2388ceb 100644
--- a/dep/mysqllite/mysys/md5.c
+++ b/dep/mysqllite/mysys/md5.c
@@ -44,7 +44,8 @@
 
 #include <string.h>	/* for memcpy() and memset() */
 
-static void
+
+static void 
 my_MD5Transform (cvs_uint32 buf[4], const unsigned char in[64]);
 
 /* Little-endian byte-swapping routines.  Note that these do not
@@ -88,7 +89,7 @@ static uint32 getu32 (const unsigned char *addr)
   Update context to reflect the concatenation of another buffer full
   of bytes.
 */
-void
+void 
 my_MD5Update (my_MD5Context *ctx, unsigned char const *buf, unsigned len)
 {
   uint32 t;
@@ -133,11 +134,11 @@ static uint32 getu32 (const unsigned char *addr)
 }
 
 /*
-  Final wrapup - pad to 64-byte boundary with the bit pattern
+  Final wrapup - pad to 64-byte boundary with the bit pattern 
   1 0* (64-bit count of bits processed, MSB-first)
 */
 void
-my_MD5Final (unsigned char digest[16], my_MD5Context *ctx)
+my_MD5Final (unsigned char digest[16], my_MD5Context *ctx) 
 {
   unsigned count;
   unsigned char *p;
@@ -190,7 +191,7 @@ static uint32 getu32 (const unsigned char *addr)
 
 /* This is the central step in the MD5 algorithm. */
 #define MD5STEP(f, w, x, y, z, data, s) \
-    ( w += f(x, y, z) + data, w &= 0xffffffff, w = w<<s | w>>(32-s), w += x )
+	( w += f(x, y, z) + data, w &= 0xffffffff, w = w<<s | w>>(32-s), w += x )
 
 /*
  * The core of the MD5 algorithm, this alters an existing MD5 hash to
@@ -288,9 +289,9 @@ static uint32 getu32 (const unsigned char *addr)
 #endif
 
 #ifdef TEST
-/*
+/* 
   Simple test program.  Can use it to manually run the tests from
-  RFC1321 for example.
+  RFC1321 for example.  
 */
 #include <stdio.h>
 
@@ -321,4 +322,4 @@ static uint32 getu32 (const unsigned char *addr)
   }
   return 0;
 }
-#endif /* TEST */
\ No newline at end of file
+#endif /* TEST */
diff --git a/dep/mysqllite/mysys/mf_arr_appstr.c b/dep/mysqllite/mysys/mf_arr_appstr.c
index 0ce731d..1edbea9 100644
--- a/dep/mysqllite/mysys/mf_arr_appstr.c
+++ b/dep/mysqllite/mysys/mf_arr_appstr.c
@@ -16,6 +16,7 @@
 #include "mysys_priv.h"
 #include <m_string.h>                           /* strcmp() */
 
+
 /**
   Append str to array, or move to the end if it already exists
 
@@ -57,4 +58,4 @@ my_bool array_append_string_unique(const char *str,
   *p= str;
 
   return FALSE;                                 /* Success */
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_cache.c b/dep/mysqllite/mysys/mf_cache.c
index 856b311..545084e 100644
--- a/dep/mysqllite/mysys/mf_cache.c
+++ b/dep/mysqllite/mysys/mf_cache.c
@@ -20,14 +20,14 @@
 #include "my_static.h"
 #include "mysys_err.h"
 
-    /*
-      Remove an open tempfile so that it doesn't survive
-      if we crash;	If the operating system doesn't support
-      this, just remember the file name for later removal
-    */
+	/*
+	  Remove an open tempfile so that it doesn't survive
+	  if we crash;	If the operating system doesn't support
+	  this, just remember the file name for later removal
+	*/
 
 static my_bool cache_remove_open_tmp(IO_CACHE *cache __attribute__((unused)),
-                     const char *name)
+				     const char *name)
 {
 #if O_TEMPORARY == 0
 #if !defined(CANT_DELETE_OPEN_FILES)
@@ -36,7 +36,7 @@ static my_bool cache_remove_open_tmp(IO_CACHE *cache __attribute__((unused)),
 #else
   int length;
   if (!(cache->file_name=
-    (char*) my_malloc((length=strlen(name)+1),MYF(MY_WME))))
+	(char*) my_malloc((length=strlen(name)+1),MYF(MY_WME))))
   {
     my_close(cache->file,MYF(0));
     cache->file = -1;
@@ -49,13 +49,13 @@ static my_bool cache_remove_open_tmp(IO_CACHE *cache __attribute__((unused)),
   return 0;
 }
 
-    /*
-    ** Open tempfile cached by IO_CACHE
-    ** Should be used when no seeks are done (only reinit_io_buff)
-    ** Return 0 if cache is inited ok
-    ** The actual file is created when the IO_CACHE buffer gets filled
-    ** If dir is not given, use TMPDIR.
-    */
+	/*
+	** Open tempfile cached by IO_CACHE
+	** Should be used when no seeks are done (only reinit_io_buff)
+	** Return 0 if cache is inited ok
+	** The actual file is created when the IO_CACHE buffer gets filled
+	** If dir is not given, use TMPDIR.
+	*/
 
 my_bool open_cached_file(IO_CACHE *cache, const char* dir, const char *prefix,
                          size_t cache_size, myf cache_myflags)
@@ -63,11 +63,11 @@ my_bool open_cached_file(IO_CACHE *cache, const char* dir, const char *prefix,
   DBUG_ENTER("open_cached_file");
   cache->dir=	 dir ? my_strdup(dir,MYF(cache_myflags & MY_WME)) : (char*) 0;
   cache->prefix= (prefix ? my_strdup(prefix,MYF(cache_myflags & MY_WME)) :
-         (char*) 0);
+		 (char*) 0);
   cache->file_name=0;
   cache->buffer=0;				/* Mark that not open */
   if (!init_io_cache(cache,-1,cache_size,WRITE_CACHE,0L,0,
-             MYF(cache_myflags | MY_NABP)))
+		     MYF(cache_myflags | MY_NABP)))
   {
     DBUG_RETURN(0);
   }
@@ -76,7 +76,7 @@ my_bool open_cached_file(IO_CACHE *cache, const char* dir, const char *prefix,
   DBUG_RETURN(1);
 }
 
-    /* Create the temporary file */
+	/* Create the temporary file */
 
 my_bool real_open_cached_file(IO_CACHE *cache)
 {
@@ -84,9 +84,9 @@ my_bool real_open_cached_file(IO_CACHE *cache)
   int error=1;
   DBUG_ENTER("real_open_cached_file");
   if ((cache->file=create_temp_file(name_buff, cache->dir, cache->prefix,
-                    (O_RDWR | O_BINARY | O_TRUNC |
-                     O_TEMPORARY | O_SHORT_LIVED),
-                    MYF(MY_WME))) >= 0)
+				    (O_RDWR | O_BINARY | O_TRUNC |
+				     O_TEMPORARY | O_SHORT_LIVED),
+				    MYF(MY_WME))) >= 0)
   {
     error=0;
     cache_remove_open_tmp(cache, name_buff);
@@ -94,6 +94,7 @@ my_bool real_open_cached_file(IO_CACHE *cache)
   DBUG_RETURN(error);
 }
 
+
 void close_cached_file(IO_CACHE *cache)
 {
   DBUG_ENTER("close_cached_file");
@@ -108,8 +109,8 @@ void close_cached_file(IO_CACHE *cache)
 #ifdef CANT_DELETE_OPEN_FILES
       if (cache->file_name)
       {
-    (void) my_delete(cache->file_name,MYF(MY_WME | ME_NOINPUT));
-    my_free(cache->file_name);
+	(void) my_delete(cache->file_name,MYF(MY_WME | ME_NOINPUT));
+	my_free(cache->file_name);
       }
 #endif
     }
@@ -117,4 +118,4 @@ void close_cached_file(IO_CACHE *cache)
     my_free(cache->prefix);
   }
   DBUG_VOID_RETURN;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_dirname.c b/dep/mysqllite/mysys/mf_dirname.c
index df1e5c4..569293f 100644
--- a/dep/mysqllite/mysys/mf_dirname.c
+++ b/dep/mysqllite/mysys/mf_dirname.c
@@ -16,7 +16,7 @@
 #include "mysys_priv.h"
 #include <m_string.h>
 
-    /* Functions definied in this file */
+	/* Functions definied in this file */
 
 size_t dirname_length(const char *name)
 {
@@ -46,6 +46,7 @@ size_t dirname_length(const char *name)
   return (size_t) (gpos+1-(char*) name);
 }
 
+
 /*
   Gives directory part of filename. Directory ends with '/'
 
@@ -70,14 +71,15 @@ size_t dirname_part(char *to, const char *name, size_t *to_res_length)
   DBUG_RETURN(length);
 } /* dirname */
 
+
 /*
   Convert directory name to use under this system
 
   SYNPOSIS
     convert_dirname()
     to				Store result here. Must be at least of size
-                    min(FN_REFLEN, strlen(from) + 1) to make room
-                    for adding FN_LIBCHAR at the end.
+    				min(FN_REFLEN, strlen(from) + 1) to make room
+    				for adding FN_LIBCHAR at the end.
     from			Original filename. May be == to
     from_end			Pointer at end of filename (normally end \0)
 
@@ -116,7 +118,7 @@ char *convert_dirname(char *to, const char *from, const char *from_end)
     for (; from != from_end && *from ; from++)
     {
       if (*from == '/')
-    *to++= FN_LIBCHAR;
+	*to++= FN_LIBCHAR;
       else
       {
 #ifdef BACKSLASH_MBTAIL
@@ -149,4 +151,4 @@ char *convert_dirname(char *to, const char *from, const char *from_end)
     *to=0;
   }
   DBUG_RETURN(to);                              /* Pointer to end of dir */
-} /* convert_dirname */
\ No newline at end of file
+} /* convert_dirname */
diff --git a/dep/mysqllite/mysys/mf_fn_ext.c b/dep/mysqllite/mysys/mf_fn_ext.c
index 84d8869..47fc67c 100644
--- a/dep/mysqllite/mysys/mf_fn_ext.c
+++ b/dep/mysqllite/mysys/mf_fn_ext.c
@@ -13,6 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
+
 #include "mysys_priv.h"
 #include <m_string.h>
 
@@ -50,4 +51,4 @@ char *fn_ext(const char *name)
 #endif
   pos=strchr(gpos,FN_EXTCHAR);
   DBUG_RETURN((char*) (pos ? pos : strend(gpos)));
-} /* fn_ext */
\ No newline at end of file
+} /* fn_ext */
diff --git a/dep/mysqllite/mysys/mf_format.c b/dep/mysqllite/mysys/mf_format.c
index b1b6b09..2b2356c 100644
--- a/dep/mysqllite/mysys/mf_format.c
+++ b/dep/mysqllite/mysys/mf_format.c
@@ -24,7 +24,7 @@
 */
 
 char * fn_format(char * to, const char *name, const char *dir,
-            const char *extension, uint flag)
+		    const char *extension, uint flag)
 {
   char dev[FN_REFLEN], buff[FN_REFLEN], *pos, *startpos;
   const char *ext;
@@ -34,7 +34,7 @@ char * fn_format(char * to, const char *name, const char *dir,
   DBUG_ASSERT(name != NULL);
   DBUG_ASSERT(extension != NULL);
   DBUG_PRINT("enter",("name: %s  dir: %s  extension: %s  flag: %d",
-               name,dir,extension,flag));
+		       name,dir,extension,flag));
 
   /* Copy and skip directory */
   name+=(length=dirname_part(dev, (startpos=(char *) name), &dev_length));
@@ -103,7 +103,7 @@ char * fn_format(char * to, const char *name, const char *dir,
   */
   if (flag & MY_RETURN_REAL_PATH)
     (void) my_realpath(to, to, MYF(flag & MY_RESOLVE_SYMLINKS ?
-                   MY_RESOLVE_LINK: 0));
+				   MY_RESOLVE_LINK: 0));
   else if (flag & MY_RESOLVE_SYMLINKS)
   {
     strmov(buff,to);
@@ -112,6 +112,7 @@ char * fn_format(char * to, const char *name, const char *dir,
   DBUG_RETURN(to);
 } /* fn_format */
 
+
 /*
   strlength(const string str)
   Return length of string with end-space:s not counted.
@@ -132,12 +133,12 @@ size_t strlength(const char *str)
       while (*++pos && *pos != ' ') {};
       if (!*pos)
       {
-    found=pos;			/* String ends here */
-    break;
+	found=pos;			/* String ends here */
+	break;
       }
     }
     found=pos;
     while (*++pos == ' ') {};
   }
   DBUG_RETURN((size_t) (found - str));
-} /* strlength */
\ No newline at end of file
+} /* strlength */
diff --git a/dep/mysqllite/mysys/mf_getdate.c b/dep/mysqllite/mysys/mf_getdate.c
index fcecb9a..e3ac2e3 100644
--- a/dep/mysqllite/mysys/mf_getdate.c
+++ b/dep/mysqllite/mysys/mf_getdate.c
@@ -26,14 +26,15 @@
     get_date()
     to   - string where date will be written
     flag - format of date:
-      If flag & GETDATE_TIME	Return date and time
-      If flag & GETDATE_SHORT_DATE	Return short date format YYMMDD
-      If flag & GETDATE_HHMMSSTIME	Return time in HHMMDD format.
-      If flag & GETDATE_GMT		Date/time in GMT
-      If flag & GETDATE_FIXEDLENGTH	Return fixed length date/time
+	  If flag & GETDATE_TIME	Return date and time
+	  If flag & GETDATE_SHORT_DATE	Return short date format YYMMDD
+	  If flag & GETDATE_HHMMSSTIME	Return time in HHMMDD format.
+	  If flag & GETDATE_GMT		Date/time in GMT
+	  If flag & GETDATE_FIXEDLENGTH	Return fixed length date/time
     date - for conversion
 */
 
+
 void get_date(register char * to, int flag, time_t date)
 {
    reg2 struct tm *start_time;
@@ -57,25 +58,25 @@ void get_date(register char * to, int flag, time_t date)
 #endif
    if (flag & GETDATE_SHORT_DATE)
      sprintf(to,"%02d%02d%02d",
-         start_time->tm_year % 100,
-         start_time->tm_mon+1,
-         start_time->tm_mday);
+	     start_time->tm_year % 100,
+	     start_time->tm_mon+1,
+	     start_time->tm_mday);
    else
      sprintf(to, ((flag & GETDATE_FIXEDLENGTH) ?
-          "%4d-%02d-%02d" : "%d-%02d-%02d"),
-         start_time->tm_year+1900,
-         start_time->tm_mon+1,
-         start_time->tm_mday);
+		  "%4d-%02d-%02d" : "%d-%02d-%02d"),
+	     start_time->tm_year+1900,
+	     start_time->tm_mon+1,
+	     start_time->tm_mday);
    if (flag & GETDATE_DATE_TIME)
      sprintf(strend(to),
-         ((flag & GETDATE_FIXEDLENGTH) ?
-          " %02d:%02d:%02d" : " %2d:%02d:%02d"),
-         start_time->tm_hour,
-         start_time->tm_min,
-         start_time->tm_sec);
+	     ((flag & GETDATE_FIXEDLENGTH) ?
+	      " %02d:%02d:%02d" : " %2d:%02d:%02d"),
+	     start_time->tm_hour,
+	     start_time->tm_min,
+	     start_time->tm_sec);
    else if (flag & GETDATE_HHMMSSTIME)
      sprintf(strend(to),"%02d%02d%02d",
-         start_time->tm_hour,
-         start_time->tm_min,
-         start_time->tm_sec);
-} /* get_date */
\ No newline at end of file
+	     start_time->tm_hour,
+	     start_time->tm_min,
+	     start_time->tm_sec);
+} /* get_date */
diff --git a/dep/mysqllite/mysys/mf_iocache.c b/dep/mysqllite/mysys/mf_iocache.c
index 7388b90..7aa0934 100644
--- a/dep/mysqllite/mysys/mf_iocache.c
+++ b/dep/mysqllite/mysys/mf_iocache.c
@@ -91,6 +91,7 @@ void setup_io_cache(IO_CACHE* info)
   }
 }
 
+
 static void
 init_functions(IO_CACHE* info)
 {
@@ -117,6 +118,7 @@ void setup_io_cache(IO_CACHE* info)
   setup_io_cache(info);
 }
 
+
 /*
   Initialize an IO_CACHE object
 
@@ -124,16 +126,16 @@ void setup_io_cache(IO_CACHE* info)
     init_io_cache()
     info		cache handler to initialize
     file		File that should be associated to to the handler
-            If == -1 then real_open_cached_file()
-            will be called when it's time to open file.
+			If == -1 then real_open_cached_file()
+			will be called when it's time to open file.
     cachesize		Size of buffer to allocate for read/write
-            If == 0 then use my_default_record_cache_size
+			If == 0 then use my_default_record_cache_size
     type		Type of cache
     seek_offset		Where cache should start reading/writing
     use_async_io	Set to 1 of we should use async_io (if avaiable)
     cache_myflags	Bitmap of differnt flags
-            MY_WME | MY_FAE | MY_NABP | MY_FNABP |
-            MY_DONT_CHECK_FILESIZE
+			MY_WME | MY_FAE | MY_NABP | MY_FNABP |
+			MY_DONT_CHECK_FILESIZE
 
   RETURN
     0  ok
@@ -141,15 +143,15 @@ void setup_io_cache(IO_CACHE* info)
 */
 
 int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
-          enum cache_type type, my_off_t seek_offset,
-          pbool use_async_io, myf cache_myflags)
+		  enum cache_type type, my_off_t seek_offset,
+		  pbool use_async_io, myf cache_myflags)
 {
   size_t min_cache;
   my_off_t pos;
   my_off_t end_of_file= ~(my_off_t) 0;
   DBUG_ENTER("init_io_cache");
   DBUG_PRINT("enter",("cache: 0x%lx  type: %d  pos: %ld",
-              (ulong) info, (int) type, (ulong) seek_offset));
+		      (ulong) info, (int) type, (ulong) seek_offset));
 
   info->file= file;
   info->type= TYPE_NOT_SET;	    /* Don't set it until mutex are created */
@@ -196,12 +198,12 @@ int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
       /* Need to reset seek_not_done now that we just did a seek. */
       info->seek_not_done= end_of_file == seek_offset ? 0 : 1;
       if (end_of_file < seek_offset)
-    end_of_file=seek_offset;
+	end_of_file=seek_offset;
       /* Trim cache size if the file is very small */
       if ((my_off_t) cachesize > end_of_file-seek_offset+IO_SIZE*2-1)
       {
-    cachesize= (size_t) (end_of_file-seek_offset)+IO_SIZE*2-1;
-    use_async_io=0;				/* No need to use async */
+	cachesize= (size_t) (end_of_file-seek_offset)+IO_SIZE*2-1;
+	use_async_io=0;				/* No need to use async */
       }
     }
   }
@@ -220,23 +222,23 @@ int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
       myf flags= (myf) (cache_myflags & ~(MY_WME | MY_WAIT_IF_FULL));
 
       if (cachesize < min_cache)
-    cachesize = min_cache;
+	cachesize = min_cache;
       buffer_block= cachesize;
       if (type == SEQ_READ_APPEND)
-    buffer_block *= 2;
+	buffer_block *= 2;
       if (cachesize == min_cache)
         flags|= (myf) MY_WME;
 
       if ((info->buffer= (uchar*) my_malloc(buffer_block, flags)) != 0)
       {
-    info->write_buffer=info->buffer;
-    if (type == SEQ_READ_APPEND)
-      info->write_buffer = info->buffer + cachesize;
-    info->alloced_buffer=1;
-    break;					/* Enough memory found */
+	info->write_buffer=info->buffer;
+	if (type == SEQ_READ_APPEND)
+	  info->write_buffer = info->buffer + cachesize;
+	info->alloced_buffer=1;
+	break;					/* Enough memory found */
       }
       if (cachesize == min_cache)
-    DBUG_RETURN(2);				/* Can't alloc cache */
+	DBUG_RETURN(2);				/* Can't alloc cache */
       /* Try with less memory */
       cachesize= (cachesize*3/4 & ~(min_cache-1));
     }
@@ -284,7 +286,7 @@ int init_io_cache(IO_CACHE *info, File file, size_t cachesize,
   DBUG_RETURN(0);
 }						/* init_io_cache */
 
-    /* Wait until current request is ready */
+	/* Wait until current request is ready */
 
 #ifdef HAVE_AIOWAIT
 static void my_aiowait(my_aio_result *result)
@@ -296,21 +298,22 @@ static void my_aiowait(my_aio_result *result)
     {
       if ((int) (tmp=aiowait((struct timeval *) 0)) == -1)
       {
-    if (errno == EINTR)
-      continue;
-    DBUG_PRINT("error",("No aio request, error: %d",errno));
-    result->pending=0;			/* Assume everythings is ok */
-    break;
+	if (errno == EINTR)
+	  continue;
+	DBUG_PRINT("error",("No aio request, error: %d",errno));
+	result->pending=0;			/* Assume everythings is ok */
+	break;
       }
       ((my_aio_result*) tmp)->pending=0;
       if ((my_aio_result*) tmp == result)
-    break;
+	break;
     }
   }
   return;
 }
 #endif
 
+
 /*
   Use this to reset cache to re-start reading or to change the type
   between READ_CACHE <-> WRITE_CACHE
@@ -319,19 +322,19 @@ static void my_aiowait(my_aio_result *result)
 */
 
 my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
-            my_off_t seek_offset,
-            pbool use_async_io __attribute__((unused)),
-            pbool clear_cache)
+			my_off_t seek_offset,
+			pbool use_async_io __attribute__((unused)),
+			pbool clear_cache)
 {
   DBUG_ENTER("reinit_io_cache");
   DBUG_PRINT("enter",("cache: 0x%lx type: %d  seek_offset: %lu  clear_cache: %d",
-              (ulong) info, type, (ulong) seek_offset,
-              (int) clear_cache));
+		      (ulong) info, type, (ulong) seek_offset,
+		      (int) clear_cache));
 
   /* One can't do reinit with the following types */
   DBUG_ASSERT(type != READ_NET && info->type != READ_NET &&
-          type != WRITE_NET && info->type != WRITE_NET &&
-          type != SEQ_READ_APPEND && info->type != SEQ_READ_APPEND);
+	      type != WRITE_NET && info->type != WRITE_NET &&
+	      type != SEQ_READ_APPEND && info->type != SEQ_READ_APPEND);
 
   /* If the whole file is in memory, avoid flushing to disk */
   if (! clear_cache &&
@@ -354,8 +357,8 @@ my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
     {
       if (info->type == READ_CACHE)
       {
-    info->write_end=info->write_buffer+info->buffer_length;
-    info->seek_not_done=1;
+	info->write_end=info->write_buffer+info->buffer_length;
+	info->seek_not_done=1;
       }
       info->end_of_file = ~(my_off_t) 0;
     }
@@ -390,7 +393,7 @@ my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
     else
     {
       info->write_end=(info->buffer + info->buffer_length -
-               (seek_offset & (IO_SIZE-1)));
+		       (seek_offset & (IO_SIZE-1)));
       info->end_of_file= ~(my_off_t) 0;
     }
   }
@@ -411,6 +414,8 @@ my_bool reinit_io_cache(IO_CACHE *info, enum cache_type type,
   DBUG_RETURN(0);
 } /* reinit_io_cache */
 
+
+
 /*
   Read buffered.
 
@@ -467,7 +472,7 @@ int _my_b_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   */
   if (info->seek_not_done)
   {
-    if ((mysql_file_seek(info->file, pos_in_file, MY_SEEK_SET, MYF(0))
+    if ((mysql_file_seek(info->file, pos_in_file, MY_SEEK_SET, MYF(0)) 
         != MY_FILEPOS_ERROR))
     {
       /* No error, reset seek_not_done flag. */
@@ -512,14 +517,14 @@ int _my_b_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
     */
     length=(Count & (size_t) ~(IO_SIZE-1))-diff_length;
     if ((read_length= mysql_file_read(info->file,Buffer, length, info->myflags))
-    != length)
+	!= length)
     {
       /*
         If we didn't get, what we wanted, we either return -1 for a read
         error, or (it's end of file), how much we got in total.
       */
       info->error= (read_length == (size_t) -1 ? -1 :
-            (int) (read_length+left_length));
+		    (int) (read_length+left_length));
       DBUG_RETURN(1);
     }
     Count-=length;
@@ -556,7 +561,7 @@ int _my_b_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   }
   else if ((length= mysql_file_read(info->file,info->buffer, max_length,
                             info->myflags)) < Count ||
-       length == (size_t) -1)
+	   length == (size_t) -1)
   {
     /*
       We got an read error, or less than requested (end of file).
@@ -582,6 +587,7 @@ int _my_b_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   DBUG_RETURN(0);
 }
 
+
 /*
   Prepare IO_CACHE for shared use.
 
@@ -687,6 +693,7 @@ void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Remove a thread from shared access to IO_CACHE.
 
@@ -756,6 +763,7 @@ void remove_io_thread(IO_CACHE *cache)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Lock IO cache and wait for all other threads to join.
 
@@ -899,6 +907,7 @@ static int lock_io_cache(IO_CACHE *cache, my_off_t pos)
   DBUG_RETURN(0);
 }
 
+
 /*
   Unlock IO cache.
 
@@ -942,6 +951,7 @@ static void unlock_io_cache(IO_CACHE *cache)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Read from IO_CACHE when it is shared between several threads.
 
@@ -1004,7 +1014,7 @@ int _my_b_read_r(register IO_CACHE *cache, uchar *Buffer, size_t Count)
              length + IO_ROUND_DN(cache->read_length - length) :
              length - IO_ROUND_UP(length - cache->read_length));
     if (cache->type != READ_FIFO &&
-    (length > (cache->end_of_file - pos_in_file)))
+	(length > (cache->end_of_file - pos_in_file)))
       length= (size_t) (cache->end_of_file - pos_in_file);
     if (length == 0)
     {
@@ -1088,6 +1098,7 @@ int _my_b_read_r(register IO_CACHE *cache, uchar *Buffer, size_t Count)
   DBUG_RETURN(0);
 }
 
+
 /*
   Copy data from write cache to read cache.
 
@@ -1138,9 +1149,10 @@ static void copy_to_read_buffer(IO_CACHE *write_cache,
   }
 }
 
+
 /*
   Do sequential read from the SEQ_READ_APPEND cache.
-
+  
   We do this in three stages:
    - first read from info->buffer
    - then if there are still data to read, try the file descriptor
@@ -1207,8 +1219,8 @@ int _my_b_seq_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
     if (read_length != length)
     {
       /*
-    We only got part of data;  Read the rest of the data from the
-    write buffer
+	We only got part of data;  Read the rest of the data from the
+	write buffer
       */
       goto read_append_buffer;
     }
@@ -1241,9 +1253,9 @@ int _my_b_seq_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
       Buffer += length;
 
       /*
-     added the line below to make
-     DBUG_ASSERT(pos_in_file==info->end_of_file) pass.
-     otherwise this does not appear to be needed
+	 added the line below to make
+	 DBUG_ASSERT(pos_in_file==info->end_of_file) pass.
+	 otherwise this does not appear to be needed
       */
       pos_in_file += length;
       goto read_append_buffer;
@@ -1283,7 +1295,7 @@ int _my_b_seq_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
 
     /* Fill read buffer with data from write buffer */
     memcpy(info->buffer, info->append_read_pos,
-       (size_t) (transfer_len=len_in_buff - copy_len));
+	   (size_t) (transfer_len=len_in_buff - copy_len));
     info->read_pos= info->buffer;
     info->read_end= info->buffer+transfer_len;
     info->append_read_pos=info->write_pos;
@@ -1294,6 +1306,7 @@ int _my_b_seq_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   return Count ? 1 : 0;
 }
 
+
 #ifdef HAVE_AIOWAIT
 
 /*
@@ -1320,7 +1333,7 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   uchar *read_buffer;
 
   memcpy(Buffer,info->read_pos,
-     (left_length= (size_t) (info->read_end-info->read_pos)));
+	 (left_length= (size_t) (info->read_end-info->read_pos)));
   Buffer+=left_length;
   org_Count=Count;
   Count-=left_length;
@@ -1332,19 +1345,19 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
     if (info->aio_result.result.aio_errno)
     {
       if (info->myflags & MY_WME)
-    my_error(EE_READ, MYF(ME_BELL+ME_WAITTANG),
-         my_filename(info->file),
-         info->aio_result.result.aio_errno);
+	my_error(EE_READ, MYF(ME_BELL+ME_WAITTANG),
+		 my_filename(info->file),
+		 info->aio_result.result.aio_errno);
       my_errno=info->aio_result.result.aio_errno;
       info->error= -1;
       return(1);
     }
     if (! (read_length= (size_t) info->aio_result.result.aio_return) ||
-    read_length == (size_t) -1)
+	read_length == (size_t) -1)
     {
       my_errno=0;				/* For testing */
       info->error= (read_length == (size_t) -1 ? -1 :
-            (int) (read_length+left_length));
+		    (int) (read_length+left_length));
       return(1);
     }
     info->pos_in_file+= (size_t) (info->read_end - info->request_pos);
@@ -1356,22 +1369,22 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
     info->read_pos=info->request_pos;
     next_pos_in_file=info->aio_read_pos+read_length;
 
-    /* Check if pos_in_file is changed
-       (_ni_read_cache may have skipped some bytes) */
+	/* Check if pos_in_file is changed
+	   (_ni_read_cache may have skipped some bytes) */
 
     if (info->aio_read_pos < info->pos_in_file)
     {						/* Fix if skipped bytes */
       if (info->aio_read_pos + read_length < info->pos_in_file)
       {
-    read_length=0;				/* Skip block */
-    next_pos_in_file=info->pos_in_file;
+	read_length=0;				/* Skip block */
+	next_pos_in_file=info->pos_in_file;
       }
       else
       {
-    my_off_t offset= (info->pos_in_file - info->aio_read_pos);
-    info->pos_in_file=info->aio_read_pos; /* Whe are here */
-    info->read_pos=info->request_pos+offset;
-    read_length-=offset;			/* Bytes left from read_pos */
+	my_off_t offset= (info->pos_in_file - info->aio_read_pos);
+	info->pos_in_file=info->aio_read_pos; /* Whe are here */
+	info->read_pos=info->request_pos+offset;
+	read_length-=offset;			/* Bytes left from read_pos */
       }
     }
 #ifndef DBUG_OFF
@@ -1381,7 +1394,7 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
       return(info->read_length= (size_t) -1);
     }
 #endif
-    /* Copy found bytes to buffer */
+	/* Copy found bytes to buffer */
     length=min(Count,read_length);
     memcpy(Buffer,info->read_pos,(size_t) length);
     Buffer+=length;
@@ -1392,9 +1405,9 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   }
   else
     next_pos_in_file=(info->pos_in_file+ (size_t)
-              (info->read_end - info->request_pos));
+		      (info->read_end - info->request_pos));
 
-    /* If reading large blocks, or first read or read with skip */
+	/* If reading large blocks, or first read or read with skip */
   if (Count)
   {
     if (next_pos_in_file == info->end_of_file)
@@ -1402,7 +1415,7 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
       info->error=(int) (read_length+left_length);
       return 1;
     }
-
+    
     if (mysql_file_seek(info->file, next_pos_in_file, MY_SEEK_SET, MYF(0))
         == MY_FILEPOS_ERROR)
     {
@@ -1414,7 +1427,7 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
     if (Count < read_length)
     {					/* Small block, read to cache */
       if ((read_length=mysql_file_read(info->file,info->request_pos,
-                           read_length, info->myflags)) == (size_t) -1)
+			               read_length, info->myflags)) == (size_t) -1)
         return info->error= -1;
       use_length=min(Count,read_length);
       memcpy(Buffer,info->request_pos,(size_t) use_length);
@@ -1425,20 +1438,20 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
 
       if (Count != use_length)
       {					/* Didn't find hole block */
-    if (info->myflags & (MY_WME | MY_FAE | MY_FNABP) && Count != org_Count)
-      my_error(EE_EOFERR, MYF(ME_BELL+ME_WAITTANG),
-           my_filename(info->file),my_errno);
-    info->error=(int) (read_length+left_length);
-    return 1;
+	if (info->myflags & (MY_WME | MY_FAE | MY_FNABP) && Count != org_Count)
+	  my_error(EE_EOFERR, MYF(ME_BELL+ME_WAITTANG),
+		   my_filename(info->file),my_errno);
+	info->error=(int) (read_length+left_length);
+	return 1;
       }
     }
     else
     {						/* Big block, don't cache it */
       if ((read_length= mysql_file_read(info->file, Buffer, Count,info->myflags))
-      != Count)
+	  != Count)
       {
-    info->error= read_length == (size_t) -1 ? -1 : read_length+left_length;
-    return 1;
+	info->error= read_length == (size_t) -1 ? -1 : read_length+left_length;
+	return 1;
       }
       info->read_pos=info->read_end=info->request_pos;
       info->pos_in_file=(next_pos_in_file+=Count);
@@ -1460,21 +1473,21 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
   {
     info->aio_result.result.aio_errno=AIO_INPROGRESS;	/* Marker for test */
     DBUG_PRINT("aioread",("filepos: %ld  length: %lu",
-              (ulong) next_pos_in_file, (ulong) max_length));
+			  (ulong) next_pos_in_file, (ulong) max_length));
     if (aioread(info->file,read_buffer, max_length,
-        (my_off_t) next_pos_in_file,MY_SEEK_SET,
-        &info->aio_result.result))
+		(my_off_t) next_pos_in_file,MY_SEEK_SET,
+		&info->aio_result.result))
     {						/* Skip async io */
       my_errno=errno;
       DBUG_PRINT("error",("got error: %d, aio_result: %d from aioread, async skipped",
-              errno, info->aio_result.result.aio_errno));
+			  errno, info->aio_result.result.aio_errno));
       if (info->request_pos != info->buffer)
       {
-    bmove(info->buffer,info->request_pos,
-          (size_t) (info->read_end - info->read_pos));
-    info->request_pos=info->buffer;
-    info->read_pos-=info->read_length;
-    info->read_end-=info->read_length;
+	bmove(info->buffer,info->request_pos,
+	      (size_t) (info->read_end - info->read_pos));
+	info->request_pos=info->buffer;
+	info->read_pos-=info->read_length;
+	info->read_end-=info->read_length;
       }
       info->read_length=info->buffer_length;	/* Use hole buffer */
       info->read_function=_my_b_read;		/* Use normal IO_READ next */
@@ -1486,6 +1499,7 @@ int _my_b_async_read(register IO_CACHE *info, uchar *Buffer, size_t Count)
 } /* _my_b_async_read */
 #endif
 
+
 /* Read one byte when buffer is empty */
 
 int _my_b_get(IO_CACHE *info)
@@ -1501,7 +1515,7 @@ int _my_b_get(IO_CACHE *info)
   return (int) (uchar) buff;
 }
 
-/*
+/* 
    Write a byte buffer to IO_CACHE and flush to disk
    if IO_CACHE is full.
 
@@ -1514,8 +1528,13 @@ int _my_b_get(IO_CACHE *info)
 int _my_b_write(register IO_CACHE *info, const uchar *Buffer, size_t Count)
 {
   size_t rest_length,length;
+  my_off_t pos_in_file= info->pos_in_file;
 
-  if (info->pos_in_file+info->buffer_length > info->end_of_file)
+  DBUG_EXECUTE_IF("simulate_huge_load_data_file",
+                  {
+                    pos_in_file=(my_off_t)(5000000000ULL);
+                  });
+  if (pos_in_file+info->buffer_length > info->end_of_file)
   {
     my_errno=errno=EFBIG;
     return info->error = -1;
@@ -1573,6 +1592,7 @@ int _my_b_write(register IO_CACHE *info, const uchar *Buffer, size_t Count)
   return 0;
 }
 
+
 /*
   Append a block to the write buffer.
   This is done with the buffer locked to ensure that we don't read from
@@ -1622,11 +1642,12 @@ int my_b_append(register IO_CACHE *info, const uchar *Buffer, size_t Count)
   return 0;
 }
 
+
 int my_b_safe_write(IO_CACHE *info, const uchar *Buffer, size_t Count)
 {
   /*
     Sasha: We are not writing this with the ? operator to avoid hitting
-    a possible compiler bug. At least gcc 2.95 cannot deal with
+    a possible compiler bug. At least gcc 2.95 cannot deal with 
     several layers of ternary operators that evaluated comma(,) operator
     expressions inside - I do have a test case if somebody wants it
   */
@@ -1635,6 +1656,7 @@ int my_b_safe_write(IO_CACHE *info, const uchar *Buffer, size_t Count)
   return my_b_write(info, Buffer, Count);
 }
 
+
 /*
   Write a block to disk where part of the data may be inside the record
   buffer.  As all write calls to the data goes through the cache,
@@ -1642,7 +1664,7 @@ int my_b_safe_write(IO_CACHE *info, const uchar *Buffer, size_t Count)
 */
 
 int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,
-           my_off_t pos)
+		   my_off_t pos)
 {
   size_t length;
   int error=0;
@@ -1658,7 +1680,7 @@ int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,
     /* Of no overlap, write everything without buffering */
     if (pos + Count <= info->pos_in_file)
       return mysql_file_pwrite(info->file, Buffer, Count, pos,
-                       info->myflags | MY_NABP);
+		               info->myflags | MY_NABP);
     /* Write the part of the block that is before buffer */
     length= (uint) (info->pos_in_file - pos);
     if (mysql_file_pwrite(info->file, Buffer, length, pos, info->myflags | MY_NABP))
@@ -1694,7 +1716,8 @@ int my_block_write(register IO_CACHE *info, const uchar *Buffer, size_t Count,
   return error;
 }
 
-    /* Flush write cache */
+
+	/* Flush write cache */
 
 #define LOCK_APPEND_BUFFER if (need_append_buffer_lock) \
   lock_append_buffer(info);
@@ -1718,7 +1741,7 @@ int my_b_flush_io_cache(IO_CACHE *info,
     if (info->file == -1)
     {
       if (real_open_cached_file(info))
-    DBUG_RETURN((info->error= -1));
+	DBUG_RETURN((info->error= -1));
     }
     LOCK_APPEND_BUFFER;
 
@@ -1735,38 +1758,38 @@ int my_b_flush_io_cache(IO_CACHE *info,
 
       pos_in_file=info->pos_in_file;
       /*
-    If we have append cache, we always open the file with
-    O_APPEND which moves the pos to EOF automatically on every write
+	If we have append cache, we always open the file with
+	O_APPEND which moves the pos to EOF automatically on every write
       */
       if (!append_cache && info->seek_not_done)
       {					/* File touched, do seek */
-    if (mysql_file_seek(info->file, pos_in_file, MY_SEEK_SET, MYF(0)) ==
-        MY_FILEPOS_ERROR)
-    {
-      UNLOCK_APPEND_BUFFER;
-      DBUG_RETURN((info->error= -1));
-    }
-    if (!append_cache)
-      info->seek_not_done=0;
+	if (mysql_file_seek(info->file, pos_in_file, MY_SEEK_SET, MYF(0)) ==
+	    MY_FILEPOS_ERROR)
+	{
+	  UNLOCK_APPEND_BUFFER;
+	  DBUG_RETURN((info->error= -1));
+	}
+	if (!append_cache)
+	  info->seek_not_done=0;
       }
       if (!append_cache)
-    info->pos_in_file+=length;
+	info->pos_in_file+=length;
       info->write_end= (info->write_buffer+info->buffer_length-
-            ((pos_in_file+length) & (IO_SIZE-1)));
+			((pos_in_file+length) & (IO_SIZE-1)));
 
       if (mysql_file_write(info->file,info->write_buffer,length,
-           info->myflags | MY_NABP))
-    info->error= -1;
+		   info->myflags | MY_NABP))
+	info->error= -1;
       else
-    info->error= 0;
+	info->error= 0;
       if (!append_cache)
       {
         set_if_bigger(info->end_of_file,(pos_in_file+length));
       }
       else
       {
-    info->end_of_file+=(info->write_pos-info->append_read_pos);
-    DBUG_ASSERT(info->end_of_file == mysql_file_tell(info->file, MYF(0)));
+	info->end_of_file+=(info->write_pos-info->append_read_pos);
+	DBUG_ASSERT(info->end_of_file == mysql_file_tell(info->file, MYF(0)));
       }
 
       info->append_read_pos=info->write_pos=info->write_buffer;
@@ -1838,6 +1861,7 @@ int end_io_cache(IO_CACHE *info)
   DBUG_RETURN(error);
 } /* end_io_cache */
 
+
 /**********************************************************************
  Testing of MF_IOCACHE
 **********************************************************************/
@@ -1904,7 +1928,7 @@ int main(int argc, char** argv)
     int block_size = abs(rand() % max_block);
     int4store(buf, block_size);
     if (my_b_append(&sra_cache,buf,4) ||
-    my_b_append(&sra_cache, block, block_size))
+	my_b_append(&sra_cache, block, block_size))
       die("write failed");
     total_bytes += 4+block_size;
   }
@@ -1914,8 +1938,8 @@ int main(int argc, char** argv)
     die("%s failed to stat, but I had just closed it,\
  wonder how that happened");
   printf("Final size of %s is %s, wrote %d bytes\n",fname,
-     llstr(status.st_size,llstr_buf),
-     total_bytes);
+	 llstr(status.st_size,llstr_buf),
+	 total_bytes);
   my_delete(fname, MYF(MY_WME));
   /* check correctness of tests */
   if (total_bytes != status.st_size)
@@ -1927,4 +1951,4 @@ int main(int argc, char** argv)
   exit(error);
   return 0;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/mf_iocache2.c b/dep/mysqllite/mysys/mf_iocache2.c
index 0e25b05..6339532 100644
--- a/dep/mysqllite/mysys/mf_iocache2.c
+++ b/dep/mysqllite/mysys/mf_iocache2.c
@@ -66,6 +66,7 @@
   DBUG_RETURN(0);
 }
 
+
 my_off_t my_b_append_tell(IO_CACHE* info)
 {
   /*
@@ -82,7 +83,7 @@ my_off_t my_b_append_tell(IO_CACHE* info)
     Prevent optimizer from putting res in a register when debugging
     we need this to be able to see the value of res when the assert fails
   */
-  dbug_volatile my_off_t res;
+  dbug_volatile my_off_t res; 
 
   /*
     We need to lock the append buffer mutex to keep flush_io_cache()
@@ -105,10 +106,10 @@ my_off_t my_b_append_tell(IO_CACHE* info)
       Save the value of my_tell in res so we can see it when studying coredump
     */
     DBUG_ASSERT(info->end_of_file - (info->append_read_pos-info->write_buffer)
-        == (res=my_tell(info->file,MYF(0))));
+		== (res=my_tell(info->file,MYF(0))));
     my_seek(info->file,save_pos,MY_SEEK_SET,MYF(0));
   }
-#endif
+#endif  
   res = info->end_of_file + (info->write_pos-info->append_read_pos);
   mysql_mutex_unlock(&info->append_buffer_lock);
   return res;
@@ -163,7 +164,7 @@ void my_b_seek(IO_CACHE *info,my_off_t pos)
   {
     /* If write is in current buffer, reuse it */
     if ((ulonglong) offset <
-    (ulonglong) (info->write_end - info->write_buffer))
+	(ulonglong) (info->write_end - info->write_buffer))
     {
       info->write_pos = info->write_buffer + offset;
       DBUG_VOID_RETURN;
@@ -171,13 +172,14 @@ void my_b_seek(IO_CACHE *info,my_off_t pos)
     (void) flush_io_cache(info);
     /* Correct buffer end so that we write in increments of IO_SIZE */
     info->write_end=(info->write_buffer+info->buffer_length-
-             (pos & (IO_SIZE-1)));
+		     (pos & (IO_SIZE-1)));
   }
   info->pos_in_file=pos;
   info->seek_not_done=1;
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Fill buffer of the cache.
 
@@ -190,16 +192,17 @@ void my_b_seek(IO_CACHE *info,my_off_t pos)
   #  Number of characters
 */
 
+
 size_t my_b_fill(IO_CACHE *info)
 {
   my_off_t pos_in_file=(info->pos_in_file+
-            (size_t) (info->read_end - info->buffer));
+			(size_t) (info->read_end - info->buffer));
   size_t diff_length, length, max_length;
 
   if (info->seek_not_done)
   {					/* File touched, do seek */
     if (my_seek(info->file,pos_in_file,MY_SEEK_SET,MYF(0)) ==
-    MY_FILEPOS_ERROR)
+	MY_FILEPOS_ERROR)
     {
       info->error= 0;
       return 0;
@@ -228,6 +231,7 @@ size_t my_b_fill(IO_CACHE *info)
   return length;
 }
 
+
 /*
   Read a string ended by '\n' into a buffer of 'max_length' size.
   Returns number of characters read, 0 on error.
@@ -255,9 +259,9 @@ size_t my_b_gets(IO_CACHE *info, char *to, size_t max_length)
     {
       if ((*to++ = *pos++) == '\n')
       {
-    info->read_pos=pos;
-    *to='\0';
-    return (size_t) (to-start);
+	info->read_pos=pos;
+	*to='\0';
+	return (size_t) (to-start);
       }
     }
     if (!(max_length-=length))
@@ -272,6 +276,7 @@ size_t my_b_gets(IO_CACHE *info, char *to, size_t max_length)
   }
 }
 
+
 my_off_t my_b_filelength(IO_CACHE *info)
 {
   if (info->type == WRITE_CACHE)
@@ -281,6 +286,7 @@ my_off_t my_b_filelength(IO_CACHE *info)
   return my_seek(info->file, 0L, MY_SEEK_END, MYF(0));
 }
 
+
 /*
   Simple printf version.  Supports '%s', '%d', '%u', "%ld" and "%lu"
   Used for logging in MySQL
@@ -297,6 +303,7 @@ size_t my_b_printf(IO_CACHE *info, const char* fmt, ...)
   return result;
 }
 
+
 size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
 {
   size_t out_length= 0;
@@ -318,7 +325,7 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
     /* Copy everything until '%' or end of string */
     const char *start=fmt;
     size_t length;
-
+    
     for (; (*fmt != '\0') && (*fmt != '%'); fmt++) ;
 
     length= (size_t) (fmt - start);
@@ -329,9 +336,9 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
     if (*fmt == '\0')				/* End of format */
       return out_length;
 
-    /*
+    /* 
       By this point, *fmt must be a percent;  Keep track of this location and
-      skip over the percent character.
+      skip over the percent character. 
     */
     DBUG_ASSERT(*fmt == '%');
     backtrack= fmt;
@@ -346,7 +353,7 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
 process_flags:
     switch (*fmt)
     {
-      case '-':
+      case '-': 
         minimum_width_sign= -1; fmt++; goto process_flags;
       case '0':
         is_zero_padded= TRUE; fmt++; goto process_flags;
@@ -395,7 +402,7 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
       /* TODO: implement precision */
       out_length+= length2;
       if (my_b_write(info, (uchar*) par, length2))
-    goto err;
+	goto err;
     }
     else if (*fmt == 'b')                       /* Sized buffer parameter, only precision makes sense */
     {
@@ -412,27 +419,31 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
 
       iarg = va_arg(args, int);
       if (*fmt == 'd')
-    length2= (size_t) (int10_to_str((long) iarg,buff, -10) - buff);
+	length2= (size_t) (int10_to_str((long) iarg,buff, -10) - buff);
       else
         length2= (uint) (int10_to_str((long) (uint) iarg,buff,10)- buff);
 
       /* minimum width padding */
-      if (minimum_width > length2)
+      if (minimum_width > length2) 
       {
         char *buffz;
-
+                    
         buffz= my_alloca(minimum_width - length2);
         if (is_zero_padded)
           memset(buffz, '0', minimum_width - length2);
         else
           memset(buffz, ' ', minimum_width - length2);
-        my_b_write(info, buffz, minimum_width - length2);
+        if (my_b_write(info, buffz, minimum_width - length2))
+        {
+          my_afree(buffz);
+          goto err;
+        }
         my_afree(buffz);
       }
 
       out_length+= length2;
       if (my_b_write(info, (uchar*) buff, length2))
-    goto err;
+	goto err;
     }
     else if ((*fmt == 'l' && fmt[1] == 'd') || fmt[1] == 'u')
       /* long parameter */
@@ -443,12 +454,12 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
 
       iarg = va_arg(args, long);
       if (*++fmt == 'd')
-    length2= (size_t) (int10_to_str(iarg,buff, -10) - buff);
+	length2= (size_t) (int10_to_str(iarg,buff, -10) - buff);
       else
-    length2= (size_t) (int10_to_str(iarg,buff,10)- buff);
+	length2= (size_t) (int10_to_str(iarg,buff,10)- buff);
       out_length+= length2;
       if (my_b_write(info, (uchar*) buff, length2))
-    goto err;
+	goto err;
     }
     else
     {
@@ -462,4 +473,4 @@ size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list args)
 
 err:
   return (size_t) -1;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_keycache.c b/dep/mysqllite/mysys/mf_keycache.c
index 35516c2..7dfbf22 100644
--- a/dep/mysqllite/mysys/mf_keycache.c
+++ b/dep/mysqllite/mysys/mf_keycache.c
@@ -337,6 +337,7 @@ static inline uint next_power(uint value)
   return (uint) my_round_up_to_next_power((uint32) value) << 1;
 }
 
+
 /*
   Initialize a key cache
 
@@ -402,7 +403,7 @@ int init_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
   keycache->key_cache_mem_size= use_mem;
   keycache->key_cache_block_size= key_cache_block_size;
   DBUG_PRINT("info", ("key_cache_block_size: %u",
-              key_cache_block_size));
+		      key_cache_block_size));
 
   blocks= (ulong) (use_mem / (sizeof(BLOCK_LINK) + 2 * sizeof(HASH_LINK) +
                               sizeof(HASH_LINK*) * 5/4 + key_cache_block_size));
@@ -420,19 +421,19 @@ int init_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
         hash_links= MAX_THREADS + blocks - 1;
 #endif
       while ((length= (ALIGN_SIZE(blocks * sizeof(BLOCK_LINK)) +
-               ALIGN_SIZE(hash_links * sizeof(HASH_LINK)) +
-               ALIGN_SIZE(sizeof(HASH_LINK*) *
+		       ALIGN_SIZE(hash_links * sizeof(HASH_LINK)) +
+		       ALIGN_SIZE(sizeof(HASH_LINK*) *
                                   keycache->hash_entries))) +
-         ((size_t) blocks * keycache->key_cache_block_size) > use_mem)
+	     ((size_t) blocks * keycache->key_cache_block_size) > use_mem)
         blocks--;
       /* Allocate memory for cache page buffers */
       if ((keycache->block_mem=
-       my_large_malloc((size_t) blocks * keycache->key_cache_block_size,
-              MYF(0))))
+	   my_large_malloc((size_t) blocks * keycache->key_cache_block_size,
+			  MYF(0))))
       {
         /*
-      Allocate memory for blocks, hash_links and hash entries;
-      For each block 2 hash links are allocated
+	  Allocate memory for blocks, hash_links and hash entries;
+	  For each block 2 hash links are allocated
         */
         if ((keycache->block_root= (BLOCK_LINK*) my_malloc(length,
                                                            MYF(0))))
@@ -452,16 +453,16 @@ int init_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
     keycache->disk_blocks= (int) blocks;
     keycache->hash_links= hash_links;
     keycache->hash_root= (HASH_LINK**) ((char*) keycache->block_root +
-                        ALIGN_SIZE(blocks*sizeof(BLOCK_LINK)));
+				        ALIGN_SIZE(blocks*sizeof(BLOCK_LINK)));
     keycache->hash_link_root= (HASH_LINK*) ((char*) keycache->hash_root +
-                            ALIGN_SIZE((sizeof(HASH_LINK*) *
-                            keycache->hash_entries)));
+				            ALIGN_SIZE((sizeof(HASH_LINK*) *
+							keycache->hash_entries)));
     bzero((uchar*) keycache->block_root,
-      keycache->disk_blocks * sizeof(BLOCK_LINK));
+	  keycache->disk_blocks * sizeof(BLOCK_LINK));
     bzero((uchar*) keycache->hash_root,
           keycache->hash_entries * sizeof(HASH_LINK*));
     bzero((uchar*) keycache->hash_link_root,
-      keycache->hash_links * sizeof(HASH_LINK));
+	  keycache->hash_links * sizeof(HASH_LINK));
     keycache->hash_links_used= 0;
     keycache->free_hash_list= NULL;
     keycache->blocks_used= keycache->blocks_changed= 0;
@@ -476,26 +477,26 @@ int init_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
     keycache->keycache_time= 0;
     keycache->warm_blocks= 0;
     keycache->min_warm_blocks= (division_limit ?
-                blocks * division_limit / 100 + 1 :
-                blocks);
+				blocks * division_limit / 100 + 1 :
+				blocks);
     keycache->age_threshold= (age_threshold ?
-                  blocks * age_threshold / 100 :
-                  blocks);
+			      blocks * age_threshold / 100 :
+			      blocks);
 
     keycache->can_be_used= 1;
 
     keycache->waiting_for_hash_link.last_thread= NULL;
     keycache->waiting_for_block.last_thread= NULL;
     DBUG_PRINT("exit",
-           ("disk_blocks: %d  block_root: 0x%lx  hash_entries: %d\
+	       ("disk_blocks: %d  block_root: 0x%lx  hash_entries: %d\
  hash_root: 0x%lx  hash_links: %d  hash_link_root: 0x%lx",
-        keycache->disk_blocks,  (long) keycache->block_root,
-        keycache->hash_entries, (long) keycache->hash_root,
-        keycache->hash_links,   (long) keycache->hash_link_root));
+		keycache->disk_blocks,  (long) keycache->block_root,
+		keycache->hash_entries, (long) keycache->hash_root,
+		keycache->hash_links,   (long) keycache->hash_link_root));
     bzero((uchar*) keycache->changed_blocks,
-      sizeof(keycache->changed_blocks[0]) * CHANGED_BLOCKS_HASH);
+	  sizeof(keycache->changed_blocks[0]) * CHANGED_BLOCKS_HASH);
     bzero((uchar*) keycache->file_blocks,
-      sizeof(keycache->file_blocks[0]) * CHANGED_BLOCKS_HASH);
+	  sizeof(keycache->file_blocks[0]) * CHANGED_BLOCKS_HASH);
   }
   else
   {
@@ -525,6 +526,7 @@ int init_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
   DBUG_RETURN(0);
 }
 
+
 /*
   Resize a key cache
 
@@ -636,7 +638,7 @@ int resize_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
   end_key_cache(keycache, 0);			/* Don't free mutex */
   /* The following will work even if use_mem is 0 */
   blocks= init_key_cache(keycache, key_cache_block_size, use_mem,
-             division_limit, age_threshold);
+			 division_limit, age_threshold);
 
 finish:
   /*
@@ -652,6 +654,7 @@ int resize_key_cache(KEY_CACHE *keycache, uint key_cache_block_size,
   DBUG_RETURN(blocks);
 }
 
+
 /*
   Increment counter blocking resize key cache operation
 */
@@ -660,6 +663,7 @@ static inline void inc_counter_for_resize_op(KEY_CACHE *keycache)
   keycache->cnt_for_resize_op++;
 }
 
+
 /*
   Decrement counter blocking resize key cache operation;
   Signal the operation to proceed when counter becomes equal zero
@@ -689,21 +693,22 @@ static inline void dec_counter_for_resize_op(KEY_CACHE *keycache)
 */
 
 void change_key_cache_param(KEY_CACHE *keycache, uint division_limit,
-                uint age_threshold)
+			    uint age_threshold)
 {
   DBUG_ENTER("change_key_cache_param");
 
   keycache_pthread_mutex_lock(&keycache->cache_lock);
   if (division_limit)
     keycache->min_warm_blocks= (keycache->disk_blocks *
-                division_limit / 100 + 1);
+				division_limit / 100 + 1);
   if (age_threshold)
     keycache->age_threshold=   (keycache->disk_blocks *
-                age_threshold / 100);
+				age_threshold / 100);
   keycache_pthread_mutex_unlock(&keycache->cache_lock);
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Remove key_cache from memory
 
@@ -762,6 +767,7 @@ void end_key_cache(KEY_CACHE *keycache, my_bool cleanup)
   DBUG_VOID_RETURN;
 } /* end_key_cache */
 
+
 /*
   Link a thread into double-linked queue of waiting threads.
 
@@ -842,6 +848,7 @@ static void unlink_from_queue(KEYCACHE_WQUEUE *wqueue,
 #endif
 }
 
+
 /*
   Add a thread to single-linked queue of waiting threads
 
@@ -895,6 +902,7 @@ static void wait_on_queue(KEYCACHE_WQUEUE *wqueue,
   while (thread->next);
 }
 
+
 /*
   Remove all threads from queue signaling them to proceed
 
@@ -939,6 +947,7 @@ static void release_whole_queue(KEYCACHE_WQUEUE *wqueue)
   wqueue->last_thread= NULL;
 }
 
+
 /*
   Unlink a block from the chain of dirty/clean blocks
 */
@@ -960,6 +969,7 @@ static inline void unlink_changed(BLOCK_LINK *block)
 #endif
 }
 
+
 /*
   Link a block into the chain of dirty/clean blocks
 */
@@ -974,6 +984,7 @@ static inline void link_changed(BLOCK_LINK *block, BLOCK_LINK **phead)
   *phead= block;
 }
 
+
 /*
   Link a block in a chain of clean blocks of a file.
 
@@ -1017,6 +1028,7 @@ static void link_to_file_list(KEY_CACHE *keycache,
   }
 }
 
+
 /*
   Re-link a block from the clean chain to the dirty chain of a file.
 
@@ -1054,6 +1066,7 @@ static void link_to_changed_list(KEY_CACHE *keycache,
   keycache->global_blocks_changed++;
 }
 
+
 /*
   Link a block to the LRU chain at the beginning or at the end of
   one of two parts.
@@ -1195,6 +1208,7 @@ static void link_block(KEY_CACHE *keycache, BLOCK_LINK *block, my_bool hot,
 #endif
 }
 
+
 /*
   Unlink a block from the LRU chain
 
@@ -1251,6 +1265,7 @@ static void unlink_block(KEY_CACHE *keycache, BLOCK_LINK *block)
 #endif
 }
 
+
 /*
   Register requests for a block.
 
@@ -1277,6 +1292,7 @@ static void reg_requests(KEY_CACHE *keycache, BLOCK_LINK *block, int count)
   block->requests+=count;
 }
 
+
 /*
   Unregister request for a block
   linking it to the LRU chain if it's the last request
@@ -1357,7 +1373,7 @@ static void unreg_request(KEY_CACHE *keycache,
     */
     block= keycache->used_ins;
     if (block && keycache->keycache_time - block->last_hit_time >
-    keycache->age_threshold)
+	keycache->age_threshold)
     {
       unlink_block(keycache, block);
       link_block(keycache, block, 0, 0);
@@ -1389,6 +1405,7 @@ static void remove_reader(BLOCK_LINK *block)
     keycache_pthread_cond_signal(block->condvar);
 }
 
+
 /*
   Wait until the last reader of the page in block
   signals on its termination
@@ -1420,6 +1437,7 @@ static void wait_for_readers(KEY_CACHE *keycache,
   }
 }
 
+
 /*
   Add a hash link to a bucket in the hash_table
 */
@@ -1433,6 +1451,7 @@ static inline void link_hash(HASH_LINK **start, HASH_LINK *hash_link)
   *start= hash_link;
 }
 
+
 /*
   Remove a hash link from the hash table
 */
@@ -1477,7 +1496,7 @@ static void unlink_hash(KEY_CACHE *keycache, HASH_LINK *hash_link)
     }
     while (thread != last_thread);
     link_hash(&keycache->hash_root[KEYCACHE_HASH(hash_link->file,
-                             hash_link->diskpos)],
+					         hash_link->diskpos)],
               hash_link);
     return;
   }
@@ -1485,6 +1504,7 @@ static void unlink_hash(KEY_CACHE *keycache, HASH_LINK *hash_link)
   keycache->free_hash_list= hash_link;
 }
 
+
 /*
   Get the hash link for a page
 */
@@ -1569,6 +1589,7 @@ static HASH_LINK *get_hash_link(KEY_CACHE *keycache,
   return hash_link;
 }
 
+
 /*
   Get a block for the file page requested by a keycache read/write operation;
   If the page is not in the cache return a free block, if there is none
@@ -2008,7 +2029,7 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
           DBUG_ASSERT(keycache->blocks_used <
                       (ulong) keycache->disk_blocks);
           block= &keycache->block_root[keycache->blocks_used];
-          block_mem_offset=
+          block_mem_offset= 
            ((size_t) keycache->blocks_used) * keycache->key_cache_block_size;
           block->buffer= ADD_TO_PTR(keycache->block_mem,
                                     block_mem_offset,
@@ -2040,7 +2061,7 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
       }
       else
       {
-    /*
+	/*
           There are no free blocks and no never used blocks, use a block
           from the LRU ring.
         */
@@ -2114,9 +2135,9 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
           in most cases the first condition is true.
         */
         if (block->hash_link != hash_link &&
-        ! (block->status & BLOCK_IN_SWITCH) )
+	    ! (block->status & BLOCK_IN_SWITCH) )
         {
-      /* this is a primary request for a new page */
+	  /* this is a primary request for a new page */
           block->status|= BLOCK_IN_SWITCH;
 
           KEYCACHE_DBUG_PRINT("find_key_block",
@@ -2124,7 +2145,7 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
 
           if (block->status & BLOCK_CHANGED)
           {
-        /* The block contains a dirty page - push it out of the cache */
+	    /* The block contains a dirty page - push it out of the cache */
 
             KEYCACHE_DBUG_PRINT("find_key_block", ("block is dirty"));
             if (block->status & BLOCK_IN_FLUSH)
@@ -2207,10 +2228,10 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
             release_whole_queue(&block->wqueue[COND_FOR_SAVED]);
             /*
               The block is still assigned to its old hash_link.
-          Wait until all pending read requests
-          for this page are executed
-          (we could have avoided this waiting, if we had read
-          a page in the cache in a sweep, without yielding control)
+	      Wait until all pending read requests
+	      for this page are executed
+	      (we could have avoided this waiting, if we had read
+	      a page in the cache in a sweep, without yielding control)
             */
             wait_for_readers(keycache, block);
             DBUG_ASSERT(block->hash_link && block->hash_link->block == block &&
@@ -2247,7 +2268,7 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
         {
           /*
             Either (block->hash_link == hash_link),
-        or     (block->status & BLOCK_IN_SWITCH).
+	    or     (block->status & BLOCK_IN_SWITCH).
 
             This is for secondary requests for a new file block only.
             Either it is already assigned to the new hash_link meanwhile
@@ -2333,6 +2354,7 @@ static BLOCK_LINK *find_key_block(KEY_CACHE *keycache,
   DBUG_RETURN(block);
 }
 
+
 /*
   Read into a key cache block buffer from disk.
 
@@ -2443,6 +2465,7 @@ static void read_block(KEY_CACHE *keycache,
   }
 }
 
+
 /*
   Read a block of data from a cached file into a buffer;
 
@@ -2500,7 +2523,7 @@ uchar *key_cache_read(KEY_CACHE *keycache,
                                 (ulong) (keycache->blocks_unused *
                                          keycache->key_cache_block_size));
     }
-
+  
     /*
       When the key cache is once initialized, we use the cache_lock to
       reliably distinguish the cases of normal operation, resizing, and
@@ -2546,7 +2569,7 @@ uchar *key_cache_read(KEY_CACHE *keycache,
       KEYCACHE_DBUG_ASSERT(read_length > 0);
 
       if (block_length > keycache->key_cache_block_size || offset)
-    return_buffer=0;
+	return_buffer=0;
 
       /* Request the cache block that matches file/pos. */
       keycache->global_cache_r_requests++;
@@ -2648,6 +2671,7 @@ uchar *key_cache_read(KEY_CACHE *keycache,
       buff+= read_length;
       filepos+= read_length+offset;
       offset= 0;
+
     } while ((length-= read_length));
     if (MYSQL_KEYCACHE_READ_DONE_ENABLED())
     {
@@ -2683,6 +2707,7 @@ uchar *key_cache_read(KEY_CACHE *keycache,
   DBUG_RETURN(error ? (uchar*) 0 : start);
 }
 
+
 /*
   Insert a block of file data from a buffer into key cache
 
@@ -2733,7 +2758,7 @@ int key_cache_insert(KEY_CACHE *keycache,
       ongoing resize.
     */
     if (!keycache->can_be_used || keycache->in_resize)
-    goto no_key_cache;
+	goto no_key_cache;
     /* Register the pseudo I/O for the next resize. */
     inc_counter_for_resize_op(keycache);
     locked_and_incremented= TRUE;
@@ -2744,7 +2769,7 @@ int key_cache_insert(KEY_CACHE *keycache,
     {
       /* Cache could be disabled or resizing in a later iteration. */
       if (!keycache->can_be_used || keycache->in_resize)
-    goto no_key_cache;
+	goto no_key_cache;
       /* Start loading at the beginning of the cache block. */
       filepos-= offset;
       /* Do not load beyond the end of the cache block. */
@@ -2909,6 +2934,7 @@ int key_cache_insert(KEY_CACHE *keycache,
       buff+= read_length;
       filepos+= read_length+offset;
       offset= 0;
+
     } while ((length-= read_length));
 
   no_key_cache:
@@ -2919,6 +2945,7 @@ int key_cache_insert(KEY_CACHE *keycache,
   DBUG_RETURN(error);
 }
 
+
 /*
   Write a buffer into a cached file.
 
@@ -3031,7 +3058,7 @@ int key_cache_write(KEY_CACHE *keycache,
     {
       /* Cache could be disabled in a later iteration. */
       if (!keycache->can_be_used)
-    goto no_key_cache;
+	goto no_key_cache;
 
       MYSQL_KEYCACHE_WRITE_BLOCK(keycache->key_cache_block_size);
       /* Start writing at the beginning of the cache block. */
@@ -3217,6 +3244,7 @@ int key_cache_write(KEY_CACHE *keycache,
       buff+= read_length;
       filepos+= read_length+offset;
       offset= 0;
+
     } while ((length-= read_length));
     goto end;
   }
@@ -3231,7 +3259,7 @@ int key_cache_write(KEY_CACHE *keycache,
     if (locked_and_incremented)
       keycache_pthread_mutex_unlock(&keycache->cache_lock);
     if (my_pwrite(file, (uchar*) buff, length, filepos,
-          MYF(MY_NABP | MY_WAIT_IF_FULL)))
+		  MYF(MY_NABP | MY_WAIT_IF_FULL)))
       error=1;
     if (locked_and_incremented)
       keycache_pthread_mutex_lock(&keycache->cache_lock);
@@ -3243,7 +3271,7 @@ int key_cache_write(KEY_CACHE *keycache,
     dec_counter_for_resize_op(keycache);
     keycache_pthread_mutex_unlock(&keycache->cache_lock);
   }
-
+  
   if (MYSQL_KEYCACHE_WRITE_DONE_ENABLED())
   {
     MYSQL_KEYCACHE_WRITE_DONE((ulong) (keycache->blocks_used *
@@ -3251,7 +3279,7 @@ int key_cache_write(KEY_CACHE *keycache,
                               (ulong) (keycache->blocks_unused *
                                        keycache->key_cache_block_size));
   }
-
+  
 #if !defined(DBUG_OFF) && defined(EXTRA_DEBUG)
   DBUG_EXECUTE("exec",
                test_key_cache(keycache, "end of key_cache_write", 1););
@@ -3259,6 +3287,7 @@ int key_cache_write(KEY_CACHE *keycache,
   DBUG_RETURN(error);
 }
 
+
 /*
   Free block.
 
@@ -3413,12 +3442,14 @@ static void free_block(KEY_CACHE *keycache, BLOCK_LINK *block)
   release_whole_queue(&block->wqueue[COND_FOR_SAVED]);
 }
 
+
 static int cmp_sec_link(BLOCK_LINK **a, BLOCK_LINK **b)
 {
   return (((*a)->hash_link->diskpos < (*b)->hash_link->diskpos) ? -1 :
       ((*a)->hash_link->diskpos > (*b)->hash_link->diskpos) ? 1 : 0);
 }
 
+
 /*
   Flush a portion of changed blocks to disk,
   free used blocks if requested
@@ -3523,10 +3554,12 @@ static int flush_cached_blocks(KEY_CACHE *keycache,
       */
       unreg_request(keycache, block, 1);
     }
+
   } /* end of for ( ; cache != end ; cache++) */
   return last_errno;
 }
 
+
 /*
   Flush all key blocks for a file to disk, but don't do any mutex locks.
 
@@ -3551,7 +3584,7 @@ static int flush_cached_blocks(KEY_CACHE *keycache,
 */
 
 static int flush_key_blocks_int(KEY_CACHE *keycache,
-                File file, enum flush_type type)
+				File file, enum flush_type type)
 {
   BLOCK_LINK *cache_buff[FLUSH_CACHE],**cache;
   int last_errno= 0;
@@ -3966,7 +3999,9 @@ static int flush_key_blocks_int(KEY_CACHE *keycache,
                       &keycache->cache_lock);
         goto restart;
       }
+
     } /* if (! (type == FLUSH_KEEP || type == FLUSH_FORCE_WRITE)) */
+
   } /* if (keycache->disk_blocks > 0 */
 
 #ifndef DBUG_OFF
@@ -3981,6 +4016,7 @@ static int flush_key_blocks_int(KEY_CACHE *keycache,
   DBUG_RETURN(last_errno != 0);
 }
 
+
 /*
   Flush all blocks for a file to disk
 
@@ -4018,6 +4054,7 @@ int flush_key_blocks(KEY_CACHE *keycache,
   DBUG_RETURN(res);
 }
 
+
 /*
   Flush all blocks in the key cache to disk.
 
@@ -4094,6 +4131,7 @@ static int flush_all_key_blocks(KEY_CACHE *keycache)
             DBUG_RETURN(1);
         }
       }
+
     } while (found);
 
     /*
@@ -4127,6 +4165,7 @@ static int flush_all_key_blocks(KEY_CACHE *keycache)
             DBUG_RETURN(1);
         }
       }
+
     } while (found);
 
     /*
@@ -4149,6 +4188,7 @@ static int flush_all_key_blocks(KEY_CACHE *keycache)
   DBUG_RETURN(0);
 }
 
+
 /*
   Reset the counters of a key cache.
 
@@ -4184,6 +4224,7 @@ int reset_key_cache_counters(const char *name __attribute__((unused)),
   DBUG_RETURN(0);
 }
 
+
 #ifndef DBUG_OFF
 /*
   Test if disk-cache is ok
@@ -4201,6 +4242,7 @@ static void test_key_cache(KEY_CACHE *keycache __attribute__((unused)),
 #define KEYCACHE_DUMP_FILE  "keycache_dump.txt"
 #define MAX_QUEUE_LEN  100
 
+
 static void keycache_dump(KEY_CACHE *keycache)
 {
   FILE *keycache_dump_file=fopen(KEYCACHE_DUMP_FILE, "w");
@@ -4295,6 +4337,7 @@ static void keycache_dump(KEY_CACHE *keycache)
 
 #if defined(KEYCACHE_TIMEOUT) && !defined(__WIN__)
 
+
 static int keycache_pthread_cond_wait(mysql_cond_t *cond,
                                       mysql_mutex_t *mutex)
 {
@@ -4358,6 +4401,7 @@ static int keycache_pthread_cond_wait(mysql_cond_t *cond,
 
 #if defined(KEYCACHE_DEBUG)
 
+
 static int keycache_pthread_mutex_lock(mysql_mutex_t *mutex)
 {
   int rc;
@@ -4366,12 +4410,14 @@ static int keycache_pthread_mutex_lock(mysql_mutex_t *mutex)
   return rc;
 }
 
+
 static void keycache_pthread_mutex_unlock(mysql_mutex_t *mutex)
 {
   KEYCACHE_THREAD_TRACE_END("");
   mysql_mutex_unlock(mutex);
 }
 
+
 static int keycache_pthread_cond_signal(mysql_cond_t *cond)
 {
   int rc;
@@ -4380,8 +4426,10 @@ static int keycache_pthread_cond_signal(mysql_cond_t *cond)
   return rc;
 }
 
+
 #if defined(KEYCACHE_DEBUG_LOG)
 
+
 static void keycache_debug_print(const char * fmt,...)
 {
   va_list args;
@@ -4397,6 +4445,7 @@ static void keycache_debug_print(const char * fmt,...)
 
 #if defined(KEYCACHE_DEBUG_LOG)
 
+
 void keycache_debug_log_close(void)
 {
   if (keycache_debug_log)
@@ -4470,4 +4519,5 @@ static int cache_empty(KEY_CACHE *keycache)
   }
   return !errcnt;
 }
-#endif
\ No newline at end of file
+#endif
+
diff --git a/dep/mysqllite/mysys/mf_keycaches.c b/dep/mysqllite/mysys/mf_keycaches.c
index bc377b5..b49a46f 100644
--- a/dep/mysqllite/mysys/mf_keycaches.c
+++ b/dep/mysqllite/mysys/mf_keycaches.c
@@ -50,6 +50,7 @@
   struct st_safe_hash_entry *next, **prev;
 } SAFE_HASH_ENTRY;
 
+
 typedef struct st_safe_hash_with_default
 {
   rw_lock_t mutex;
@@ -58,6 +59,7 @@
   SAFE_HASH_ENTRY *root;
 } SAFE_HASH;
 
+
 /*
   Free a SAFE_HASH_ENTRY
 
@@ -71,6 +73,7 @@ static void safe_hash_entry_free(SAFE_HASH_ENTRY *entry)
   DBUG_VOID_RETURN;
 }
 
+
 /* Get key and length for a SAFE_HASH_ENTRY */
 
 static uchar *safe_hash_entry_get(SAFE_HASH_ENTRY *entry, size_t *length,
@@ -80,6 +83,7 @@ static uchar *safe_hash_entry_get(SAFE_HASH_ENTRY *entry, size_t *length,
   return (uchar*) entry->key;
 }
 
+
 /*
   Init a SAFE_HASH object
 
@@ -99,7 +103,7 @@ static uchar *safe_hash_entry_get(SAFE_HASH_ENTRY *entry, size_t *length,
 */
 
 static my_bool safe_hash_init(SAFE_HASH *hash, uint elements,
-                  uchar *default_value)
+			      uchar *default_value)
 {
   DBUG_ENTER("safe_hash");
   if (my_hash_init(&hash->hash, &my_charset_bin, elements,
@@ -115,6 +119,7 @@ static my_bool safe_hash_init(SAFE_HASH *hash, uint elements,
   DBUG_RETURN(0);
 }
 
+
 /*
   Free a SAFE_HASH object
 
@@ -155,6 +160,7 @@ static uchar *safe_hash_search(SAFE_HASH *hash, const uchar *key, uint length)
   DBUG_RETURN(result);
 }
 
+
 /*
   Associate a key with some data
 
@@ -176,7 +182,7 @@ static uchar *safe_hash_search(SAFE_HASH *hash, const uchar *key, uint length)
 */
 
 static my_bool safe_hash_set(SAFE_HASH *hash, const uchar *key, uint length,
-                 uchar *data)
+			     uchar *data)
 {
   SAFE_HASH_ENTRY *entry;
   my_bool error= 0;
@@ -209,7 +215,7 @@ static my_bool safe_hash_set(SAFE_HASH *hash, const uchar *key, uint length,
   else
   {
     if (!(entry= (SAFE_HASH_ENTRY *) my_malloc(sizeof(*entry) + length,
-                           MYF(MY_WME))))
+					       MYF(MY_WME))))
     {
       error= 1;
       goto end;
@@ -237,6 +243,7 @@ static my_bool safe_hash_set(SAFE_HASH *hash, const uchar *key, uint length,
   DBUG_RETURN(error);
 }
 
+
 /*
   Change all entres with one data value to another data value
 
@@ -268,10 +275,10 @@ static void safe_hash_change(SAFE_HASH *hash, uchar *old_data, uchar *new_data)
       {
         if ((*entry->prev= entry->next))
           entry->next->prev= entry->prev;
-    my_hash_delete(&hash->hash, (uchar*) entry);
+	my_hash_delete(&hash->hash, (uchar*) entry);
       }
       else
-    entry->data= new_data;
+	entry->data= new_data;
     }
   }
 
@@ -279,6 +286,7 @@ static void safe_hash_change(SAFE_HASH *hash, uchar *old_data, uchar *new_data)
   DBUG_VOID_RETURN;
 }
 
+
 /*****************************************************************************
   Functions to handle the key cache objects
 *****************************************************************************/
@@ -286,11 +294,13 @@ static void safe_hash_change(SAFE_HASH *hash, uchar *old_data, uchar *new_data)
 /* Variable to store all key cache objects */
 static SAFE_HASH key_cache_hash;
 
+
 my_bool multi_keycache_init(void)
 {
   return safe_hash_init(&key_cache_hash, 16, (uchar*) dflt_key_cache);
 }
 
+
 void multi_keycache_free(void)
 {
   safe_hash_free(&key_cache_hash);
@@ -320,9 +330,11 @@ KEY_CACHE *multi_key_cache_search(uchar *key, uint length)
   return (KEY_CACHE*) safe_hash_search(&key_cache_hash, key, length);
 }
 
+
 /*
   Assosiate a key cache with a key
 
+
   SYONOPSIS
     multi_key_cache_set()
     key				key (path to table etc..)
@@ -334,14 +346,16 @@ KEY_CACHE *multi_key_cache_search(uchar *key, uint length)
     entry
 */
 
+
 my_bool multi_key_cache_set(const uchar *key, uint length,
-                KEY_CACHE *key_cache)
+			    KEY_CACHE *key_cache)
 {
   return safe_hash_set(&key_cache_hash, key, length, (uchar*) key_cache);
 }
 
+
 void multi_key_cache_change(KEY_CACHE *old_data,
-                KEY_CACHE *new_data)
+			    KEY_CACHE *new_data)
 {
   safe_hash_change(&key_cache_hash, (uchar*) old_data, (uchar*) new_data);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_loadpath.c b/dep/mysqllite/mysys/mf_loadpath.c
index 51c0474..776435e 100644
--- a/dep/mysqllite/mysys/mf_loadpath.c
+++ b/dep/mysqllite/mysys/mf_loadpath.c
@@ -16,28 +16,28 @@
 #include "mysys_priv.h"
 #include <m_string.h>
 
-    /* Returns full load-path for a file. to may be = path */
-    /* if path is a hard-path return path */
-    /* if path starts with home-dir return path */
-    /* if path starts with current dir or parent-dir unpack path */
-    /* if there is no path, prepend with own_path_prefix if given */
-    /* else unpack path according to current dir */
+	/* Returns full load-path for a file. to may be = path */
+	/* if path is a hard-path return path */
+	/* if path starts with home-dir return path */
+	/* if path starts with current dir or parent-dir unpack path */
+	/* if there is no path, prepend with own_path_prefix if given */
+	/* else unpack path according to current dir */
 
 char * my_load_path(char * to, const char *path,
-               const char *own_path_prefix)
+		       const char *own_path_prefix)
 {
   char buff[FN_REFLEN];
   int is_cur;
   DBUG_ENTER("my_load_path");
   DBUG_PRINT("enter",("path: %s  prefix: %s",path,
-              own_path_prefix ? own_path_prefix : ""));
+		      own_path_prefix ? own_path_prefix : ""));
 
   if ((path[0] == FN_HOMELIB && path[1] == FN_LIBCHAR) ||
       test_if_hard_path(path))
     (void) strnmov(buff, path, FN_REFLEN);
   else if ((is_cur=(path[0] == FN_CURLIB && path[1] == FN_LIBCHAR)) ||
-       (is_prefix(path,FN_PARENTDIR)) ||
-       ! own_path_prefix)
+	   (is_prefix(path,FN_PARENTDIR)) ||
+	   ! own_path_prefix)
   {
     if (is_cur)
       is_cur=2;					/* Remove current dir */
@@ -52,4 +52,4 @@ char * my_load_path(char * to, const char *path,
   to[FN_REFLEN-1]= '\0';
   DBUG_PRINT("exit",("to: %s",to));
   DBUG_RETURN(to);
-} /* my_load_path */
\ No newline at end of file
+} /* my_load_path */
diff --git a/dep/mysqllite/mysys/mf_pack.c b/dep/mysqllite/mysys/mf_pack.c
index 93e7d5b..18c9a38 100644
--- a/dep/mysqllite/mysys/mf_pack.c
+++ b/dep/mysqllite/mysys/mf_pack.c
@@ -21,9 +21,9 @@
 
 static char * expand_tilde(char **path);
 
-    /* Pack a dirname ; Changes HOME to ~/ and current dev to ./ */
-    /* from is a dirname (from dirname() ?) ending with FN_LIBCHAR */
-    /* to may be == from */
+	/* Pack a dirname ; Changes HOME to ~/ and current dev to ./ */
+	/* from is a dirname (from dirname() ?) ending with FN_LIBCHAR */
+	/* to may be == from */
 
 void pack_dirname(char * to, const char *from)
 {
@@ -47,8 +47,8 @@ void pack_dirname(char * to, const char *from)
     buff_length= strlen(buff);
     d_length= (size_t) (start-to);
     if ((start == to ||
-     (buff_length == d_length && !memcmp(buff,start,d_length))) &&
-    *start != FN_LIBCHAR && *start)
+	 (buff_length == d_length && !memcmp(buff,start,d_length))) &&
+	*start != FN_LIBCHAR && *start)
     {						/* Put current dir before */
       bchange((uchar*) to, d_length, (uchar*) buff, buff_length, strlen(to)+1);
     }
@@ -61,37 +61,37 @@ void pack_dirname(char * to, const char *from)
     {
       length= strlen(home_dir);
       if (home_dir[length-1] == FN_LIBCHAR)
-    length--;				/* Don't test last '/' */
+	length--;				/* Don't test last '/' */
     }
     if (length > 1 && length < d_length)
     {						/* test if /xx/yy -> ~/yy */
       if (memcmp(to,home_dir,length) == 0 && to[length] == FN_LIBCHAR)
       {
-    to[0]=FN_HOMELIB;			/* Filename begins with ~ */
-    (void) strmov_overlapp(to+1,to+length);
+	to[0]=FN_HOMELIB;			/* Filename begins with ~ */
+	(void) strmov_overlapp(to+1,to+length);
       }
     }
     if (! cwd_err)
     {						/* Test if cwd is ~/... */
       if (length > 1 && length < buff_length)
       {
-    if (memcmp(buff,home_dir,length) == 0 && buff[length] == FN_LIBCHAR)
-    {
-      buff[0]=FN_HOMELIB;
-      (void) strmov_overlapp(buff+1,buff+length);
-    }
+	if (memcmp(buff,home_dir,length) == 0 && buff[length] == FN_LIBCHAR)
+	{
+	  buff[0]=FN_HOMELIB;
+	  (void) strmov_overlapp(buff+1,buff+length);
+	}
       }
       if (is_prefix(to,buff))
       {
-    length= strlen(buff);
-    if (to[length])
-      (void) strmov_overlapp(to,to+length);	/* Remove everything before */
-    else
-    {
-      to[0]= FN_CURLIB;			/* Put ./ instead of cwd */
-      to[1]= FN_LIBCHAR;
-      to[2]= '\0';
-    }
+	length= strlen(buff);
+	if (to[length])
+	  (void) strmov_overlapp(to,to+length);	/* Remove everything before */
+	else
+	{
+	  to[0]= FN_CURLIB;			/* Put ./ instead of cwd */
+	  to[1]= FN_LIBCHAR;
+	  to[2]= '\0';
+	}
       }
     }
   }
@@ -99,6 +99,7 @@ void pack_dirname(char * to, const char *from)
   DBUG_VOID_RETURN;
 } /* pack_dirname */
 
+
 /*
   remove unwanted chars from dirname
 
@@ -116,7 +117,7 @@ void pack_dirname(char * to, const char *from)
   Unpacks current dir if if "./.." used
 
   RETURN
-    #  length of new name
+    #  length of new name   
 */
 
 size_t cleanup_dirname(register char *to, const char *from)
@@ -162,61 +163,61 @@ size_t cleanup_dirname(register char *to, const char *from)
     {
       if ((size_t) (pos-start) > length && memcmp(pos-length,parent,length) == 0)
       {						/* If .../../; skip prev */
-    pos-=length;
-    if (pos != start)
-    {					 /* not /../ */
-      pos--;
-      if (*pos == FN_HOMELIB && (pos == start || pos[-1] == FN_LIBCHAR))
-      {
-        if (!home_dir)
-        {
-          pos+=length+1;			/* Don't unpack ~/.. */
-          continue;
-        }
-        pos=strmov(buff,home_dir)-1;	/* Unpacks ~/.. */
-        if (*pos == FN_LIBCHAR)
-          pos--;				/* home ended with '/' */
-      }
-      if (*pos == FN_CURLIB && (pos == start || pos[-1] == FN_LIBCHAR))
-      {
-        if (my_getwd(curr_dir,FN_REFLEN,MYF(0)))
-        {
-          pos+=length+1;			/* Don't unpack ./.. */
-          continue;
-        }
-        pos=strmov(buff,curr_dir)-1;	/* Unpacks ./.. */
-        if (*pos == FN_LIBCHAR)
-          pos--;				/* home ended with '/' */
-      }
-      end_parentdir=pos;
-      while (pos >= start && *pos != FN_LIBCHAR)	/* remove prev dir */
-        pos--;
+	pos-=length;
+	if (pos != start)
+	{					 /* not /../ */
+	  pos--;
+	  if (*pos == FN_HOMELIB && (pos == start || pos[-1] == FN_LIBCHAR))
+	  {
+	    if (!home_dir)
+	    {
+	      pos+=length+1;			/* Don't unpack ~/.. */
+	      continue;
+	    }
+	    pos=strmov(buff,home_dir)-1;	/* Unpacks ~/.. */
+	    if (*pos == FN_LIBCHAR)
+	      pos--;				/* home ended with '/' */
+	  }
+	  if (*pos == FN_CURLIB && (pos == start || pos[-1] == FN_LIBCHAR))
+	  {
+	    if (my_getwd(curr_dir,FN_REFLEN,MYF(0)))
+	    {
+	      pos+=length+1;			/* Don't unpack ./.. */
+	      continue;
+	    }
+	    pos=strmov(buff,curr_dir)-1;	/* Unpacks ./.. */
+	    if (*pos == FN_LIBCHAR)
+	      pos--;				/* home ended with '/' */
+	  }
+	  end_parentdir=pos;
+	  while (pos >= start && *pos != FN_LIBCHAR)	/* remove prev dir */
+	    pos--;
           if (pos[1] == FN_HOMELIB ||
               (pos >= start && memcmp(pos, parent, length) == 0))
-      {					/* Don't remove ~user/ */
-        pos=strmov(end_parentdir+1,parent);
-        *pos=FN_LIBCHAR;
-        continue;
-      }
-    }
+	  {					/* Don't remove ~user/ */
+	    pos=strmov(end_parentdir+1,parent);
+	    *pos=FN_LIBCHAR;
+	    continue;
+	  }
+	}
       }
       else if ((size_t) (pos-start) == length-1 &&
-           !memcmp(start,parent+1,length-1))
-    start=pos;				/* Starts with "../" */
+	       !memcmp(start,parent+1,length-1))
+	start=pos;				/* Starts with "../" */
       else if (pos-start > 0 && pos[-1] == FN_LIBCHAR)
       {
 #ifdef FN_NETWORK_DRIVES
-    if (pos-start != 1)
+	if (pos-start != 1)
 #endif
-      pos--;			/* Remove dupplicate '/' */
+	  pos--;			/* Remove dupplicate '/' */
       }
       else if (pos-start > 1 && pos[-1] == FN_CURLIB && pos[-2] == FN_LIBCHAR)
-    pos-=2;					/* Skip /./ */
+	pos-=2;					/* Skip /./ */
       else if (pos > buff+1 && pos[-1] == FN_HOMELIB && pos[-2] == FN_LIBCHAR)
       {					/* Found ..../~/  */
-    buff[0]=FN_HOMELIB;
-    buff[1]=FN_LIBCHAR;
-    start=buff; pos=buff+1;
+	buff[0]=FN_HOMELIB;
+	buff[1]=FN_LIBCHAR;
+	start=buff; pos=buff+1;
       }
     }
   }
@@ -225,14 +226,16 @@ size_t cleanup_dirname(register char *to, const char *from)
   DBUG_RETURN((size_t) (pos-buff));
 } /* cleanup_dirname */
 
+
 /*
   On system where you don't have symbolic links, the following
-  code will allow you to create a file:
+  code will allow you to create a file: 
   directory-name.sym that should contain the real path
   to the directory.  This will be used if the directory name
   doesn't exists
 */
 
+
 my_bool my_use_symdir=0;	/* Set this if you want to use symdirs */
 
 #ifdef USE_SYMDIR
@@ -252,15 +255,15 @@ void symdirget(char *dir)
     {
       if ((length= my_read(file, buff, sizeof(buff) - 1, MYF(0))) > 0)
       {
-    for (pos= buff + length ;
-         pos > buff && (iscntrl(pos[-1]) || isspace(pos[-1])) ;
-         pos --);
+	for (pos= buff + length ;
+	     pos > buff && (iscntrl(pos[-1]) || isspace(pos[-1])) ;
+	     pos --);
 
-    /* Ensure that the symlink ends with the directory symbol */
-    if (pos == buff || pos[-1] != FN_LIBCHAR)
-      *pos++=FN_LIBCHAR;
+	/* Ensure that the symlink ends with the directory symbol */
+	if (pos == buff || pos[-1] != FN_LIBCHAR)
+	  *pos++=FN_LIBCHAR;
 
-    strmake(dir,buff, (size_t) (pos-buff));
+	strmake(dir,buff, (size_t) (pos-buff));
       }
       my_close(file, MYF(0));
     }
@@ -268,6 +271,7 @@ void symdirget(char *dir)
 }
 #endif /* USE_SYMDIR */
 
+
 /**
   Convert a directory name to a format which can be compared as strings
 
@@ -314,6 +318,7 @@ size_t normalize_dirname(char *to, const char *from)
   DBUG_RETURN(length);
 }
 
+
 /**
   Fixes a directory name so that can be used by open()
 
@@ -346,13 +351,13 @@ size_t unpack_dirname(char * to, const char *from)
       length-= (size_t) (suffix-buff)-1;
       if (length+(h_length= strlen(tilde_expansion)) <= FN_REFLEN)
       {
-    if ((h_length > 0) && (tilde_expansion[h_length-1] == FN_LIBCHAR))
-      h_length--;
-    if (buff+h_length < suffix)
-      bmove(buff+h_length,suffix,length);
-    else
-      bmove_upp((uchar*) buff+h_length+length, (uchar*) suffix+length, length);
-    bmove(buff,tilde_expansion,h_length);
+	if ((h_length > 0) && (tilde_expansion[h_length-1] == FN_LIBCHAR))
+	  h_length--;
+	if (buff+h_length < suffix)
+	  bmove(buff+h_length,suffix,length);
+	else
+	  bmove_upp((uchar*) buff+h_length+length, (uchar*) suffix+length, length);
+	bmove(buff,tilde_expansion,h_length);
       }
     }
   }
@@ -363,8 +368,9 @@ size_t unpack_dirname(char * to, const char *from)
   DBUG_RETURN(system_filename(to,buff));	/* Fix for open */
 } /* unpack_dirname */
 
-    /* Expand tilde to home or user-directory */
-    /* Path is reset to point at FN_LIBCHAR after ~xxx */
+
+	/* Expand tilde to home or user-directory */
+	/* Path is reset to point at FN_LIBCHAR after ~xxx */
 
 static char * expand_tilde(char **path)
 {
@@ -391,6 +397,7 @@ static char * expand_tilde(char **path)
   return (char *) 0;
 }
 
+
 /*
   Fix filename so it can be used by open, create
 
@@ -407,6 +414,7 @@ static char * expand_tilde(char **path)
     ~ will only be expanded if total length < FN_REFLEN
 */
 
+
 size_t unpack_filename(char * to, const char *from)
 {
   size_t length, n_length, buff_length;
@@ -425,16 +433,17 @@ size_t unpack_filename(char * to, const char *from)
   DBUG_RETURN(length);
 } /* unpack_filename */
 
-    /* Convert filename (unix standard) to system standard */
-    /* Used before system command's like open(), create() .. */
-    /* Returns used length of to; total length should be FN_REFLEN */
+
+	/* Convert filename (unix standard) to system standard */
+	/* Used before system command's like open(), create() .. */
+	/* Returns used length of to; total length should be FN_REFLEN */
 
 size_t system_filename(char *to, const char *from)
 {
   return (size_t) (strmake(to,from,FN_REFLEN-1)-to);
 }
 
-    /* Fix a filename to intern (UNIX format) */
+	/* Fix a filename to intern (UNIX format) */
 
 char *intern_filename(char *to, const char *from)
 {
@@ -448,4 +457,4 @@ char *intern_filename(char *to, const char *from)
   length= dirname_part(to, from, &to_length);	/* Copy dirname & fix chars */
   (void) strmov(to + to_length,from+length);
   return (to);
-} /* intern_filename */
\ No newline at end of file
+} /* intern_filename */
diff --git a/dep/mysqllite/mysys/mf_path.c b/dep/mysqllite/mysys/mf_path.c
index 773830f..725cf27 100644
--- a/dep/mysqllite/mysys/mf_path.c
+++ b/dep/mysqllite/mysys/mf_path.c
@@ -18,16 +18,16 @@
 
 static char *find_file_in_path(char *to,const char *name);
 
-    /* Finds where program can find it's files.
-       pre_pathname is found by first locking at progname (argv[0]).
-       if progname contains path the path is returned.
-       else if progname is found in path, return it
-       else if progname is given and POSIX environment variable "_" is set
-       then path is taken from "_".
-       If filename doesn't contain a path append MY_BASEDIR_VERSION or
-       MY_BASEDIR if defined, else append "/my/running".
-       own_path_name_part is concatinated to result.
-       my_path puts result in to and returns to */
+	/* Finds where program can find it's files.
+	   pre_pathname is found by first locking at progname (argv[0]).
+	   if progname contains path the path is returned.
+	   else if progname is found in path, return it
+	   else if progname is given and POSIX environment variable "_" is set
+	   then path is taken from "_".
+	   If filename doesn't contain a path append MY_BASEDIR_VERSION or
+	   MY_BASEDIR if defined, else append "/my/running".
+	   own_path_name_part is concatinated to result.
+	   my_path puts result in to and returns to */
 
 char * my_path(char * to, const char *progname,
                const char *own_pathname_part)
@@ -38,21 +38,21 @@ char * my_path(char * to, const char *progname,
 
   start=to;					/* Return this */
   if (progname && (dirname_part(to, progname, &to_length) ||
-           find_file_in_path(to,progname) ||
-           ((prog=getenv("_")) != 0 &&
+		   find_file_in_path(to,progname) ||
+		   ((prog=getenv("_")) != 0 &&
                     dirname_part(to, prog, &to_length))))
   {
     (void) intern_filename(to,to);
     if (!test_if_hard_path(to))
     {
       if (!my_getwd(curr_dir,FN_REFLEN,MYF(0)))
-    bchange((uchar*) to, 0, (uchar*) curr_dir, strlen(curr_dir), strlen(to)+1);
+	bchange((uchar*) to, 0, (uchar*) curr_dir, strlen(curr_dir), strlen(to)+1);
     }
   }
   else
   {
     if ((end = getenv("MY_BASEDIR_VERSION")) == 0 &&
-    (end = getenv("MY_BASEDIR")) == 0)
+	(end = getenv("MY_BASEDIR")) == 0)
     {
 #ifdef DEFAULT_BASEDIR
       end= (char*) DEFAULT_BASEDIR;
@@ -70,8 +70,9 @@ char * my_path(char * to, const char *progname,
   DBUG_RETURN(start);
 } /* my_path */
 
-    /* test if file without filename is found in path */
-    /* Returns to if found and to has dirpart if found, else NullS */
+
+	/* test if file without filename is found in path */
+	/* Returns to if found and to has dirpart if found, else NullS */
 
 #if defined(__WIN__)
 #define F_OK 0
@@ -101,8 +102,8 @@ static char *find_file_in_path(char *to, const char *name)
       strxmov(strnmov(to,path,(uint) (pos-path)),dir,name,ext,NullS);
       if (!access(to,F_OK))
       {
-    to[(uint) (pos-path)+1]=0;	/* Return path only */
-    return to;
+	to[(uint) (pos-path)+1]=0;	/* Return path only */
+	return to;
       }
     }
   }
@@ -116,4 +117,4 @@ static char *find_file_in_path(char *to, const char *name)
   }
 #endif
   return NullS;				/* File not found */
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_qsort.c b/dep/mysqllite/mysys/mf_qsort.c
index 9f54673..4b3ecb6 100644
--- a/dep/mysqllite/mysys/mf_qsort.c
+++ b/dep/mysqllite/mysys/mf_qsort.c
@@ -19,6 +19,7 @@
   and Bentley & McIlroy's "Engineering a Sort Function".
 */
 
+
 #include "mysys_priv.h"
 #ifndef SCO
 #include <m_string.h>
@@ -91,7 +92,7 @@
 
 #ifdef QSORT_EXTRA_CMP_ARGUMENT
 qsort_t my_qsort2(void *base_ptr, size_t count, size_t size, qsort2_cmp cmp,
-           void *cmp_argument)
+	       void *cmp_argument)
 #else
 qsort_t my_qsort(void *base_ptr, size_t count, size_t size, qsort_cmp cmp)
 #endif
@@ -125,10 +126,10 @@ qsort_t my_qsort(void *base_ptr, size_t count, size_t size, qsort_cmp cmp)
     {
       for (low_ptr = low + size; low_ptr <= high; low_ptr += size)
       {
-    char *ptr;
-    for (ptr = low_ptr; ptr > low && CMP(ptr - size, ptr) > 0;
-         ptr -= size)
-      SWAP(ptr, ptr - size, size, ptr_cmp);
+	char *ptr;
+	for (ptr = low_ptr; ptr > low && CMP(ptr - size, ptr) > 0;
+	     ptr -= size)
+	  SWAP(ptr, ptr - size, size, ptr_cmp);
       }
       POP(low, high);
       continue;
@@ -159,24 +160,24 @@ qsort_t my_qsort(void *base_ptr, size_t count, size_t size, qsort_cmp cmp)
     do
     {
       while (CMP(low_ptr, pivot) < 0)
-    low_ptr += size;
+	low_ptr += size;
       while (CMP(pivot, high_ptr) < 0)
-    high_ptr -= size;
+	high_ptr -= size;
 
       if (low_ptr < high_ptr)
       {
-    SWAP(low_ptr, high_ptr, size, ptr_cmp);
-    low_ptr += size;
-    high_ptr -= size;
+	SWAP(low_ptr, high_ptr, size, ptr_cmp);
+	low_ptr += size;
+	high_ptr -= size;
       }
-      else
+      else 
       {
-    if (low_ptr == high_ptr)
-    {
-      low_ptr += size;
-      high_ptr -= size;
-    }
-    break;
+	if (low_ptr == high_ptr)
+	{
+	  low_ptr += size;
+	  high_ptr -= size;
+	}
+	break;
       }
     }
     while (low_ptr <= high_ptr);
@@ -192,10 +193,10 @@ qsort_t my_qsort(void *base_ptr, size_t count, size_t size, qsort_cmp cmp)
     {
       if ((int) (high - low_ptr) <= 0)
       {
-    POP(low, high);			/* Nothing more to sort */
+	POP(low, high);			/* Nothing more to sort */
       }
       else
-    low = low_ptr;			/* Ignore small left part. */
+	low = low_ptr;			/* Ignore small left part. */
     }
     else if ((int) (high - low_ptr) <= 0)
       high = high_ptr;			/* Ignore small right part. */
@@ -212,4 +213,4 @@ qsort_t my_qsort(void *base_ptr, size_t count, size_t size, qsort_cmp cmp)
   } while (stack_ptr > stack);
   my_afree(pivot);
   SORT_RETURN;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_qsort2.c b/dep/mysqllite/mysys/mf_qsort2.c
index 1d2f3d3..ca2bd1a 100644
--- a/dep/mysqllite/mysys/mf_qsort2.c
+++ b/dep/mysqllite/mysys/mf_qsort2.c
@@ -16,4 +16,4 @@
 /* qsort that sends one extra argument to the compare subrutine */
 
 #define QSORT_EXTRA_CMP_ARGUMENT
-#include "mf_qsort.c"
\ No newline at end of file
+#include "mf_qsort.c"
diff --git a/dep/mysqllite/mysys/mf_radix.c b/dep/mysqllite/mysys/mf_radix.c
index ca69ae2..582ca76 100644
--- a/dep/mysqllite/mysys/mf_radix.c
+++ b/dep/mysqllite/mysys/mf_radix.c
@@ -23,7 +23,7 @@
 #include "mysys_priv.h"
 #include <m_string.h>
 
-    /* Radixsort */
+	/* Radixsort */
 
 void radixsort_for_str_ptr(uchar **base, uint number_of_elements, size_t size_of_element, uchar **buffer)
 {
@@ -42,7 +42,7 @@ void radixsort_for_str_ptr(uchar **base, uint number_of_elements, size_t size_of
     for (count_ptr=count+1 ; count_ptr < count_end ; count_ptr++)
     {
       if (*count_ptr == number_of_elements)
-    goto next;
+	goto next;
       (*count_ptr)+= *(count_ptr-1);
     }
     for (ptr= end ; ptr-- != base ;)
@@ -51,4 +51,4 @@ void radixsort_for_str_ptr(uchar **base, uint number_of_elements, size_t size_of
       (*ptr++) = *buffer_ptr++;
   next:;
   }
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_same.c b/dep/mysqllite/mysys/mf_same.c
index 46de2f3..6738dc8 100644
--- a/dep/mysqllite/mysys/mf_same.c
+++ b/dep/mysqllite/mysys/mf_same.c
@@ -19,11 +19,11 @@
 #include <m_string.h>
 
         /*
-      Copy directory and/or extension between filenames.
-      (For the meaning of 'flag', check mf_format.c)
-      'to' may be equal to 'name'.
-      Returns 'to'.
-    */
+	  Copy directory and/or extension between filenames.
+	  (For the meaning of 'flag', check mf_format.c)
+	  'to' may be equal to 'name'.
+	  Returns 'to'.
+	*/
 
 char * fn_same(char *to, const char *name, int flag)
 {
@@ -37,4 +37,4 @@ char * fn_same(char *to, const char *name, int flag)
     ext="";
 
   DBUG_RETURN(fn_format(to,to,dev,ext,flag));
-} /* fn_same */
\ No newline at end of file
+} /* fn_same */
diff --git a/dep/mysqllite/mysys/mf_sort.c b/dep/mysqllite/mysys/mf_sort.c
index d88a5a4..9ef0278 100644
--- a/dep/mysqllite/mysys/mf_sort.c
+++ b/dep/mysqllite/mysys/mf_sort.c
@@ -38,4 +38,4 @@ void my_string_ptr_sort(uchar *base, uint items, size_t size)
                 (void*) &size);
     }
   }
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_soundex.c b/dep/mysqllite/mysys/mf_soundex.c
index 840a406..fe30d8c 100644
--- a/dep/mysqllite/mysys/mf_soundex.c
+++ b/dep/mysqllite/mysys/mf_soundex.c
@@ -39,11 +39,11 @@
 
 static char get_scode(CHARSET_INFO * cs, char **ptr,pbool remove_garbage);
 
-        /* outputed string is 4 byte long */
-        /* out_pntr can be == in_pntr */
+		/* outputed string is 4 byte long */
+		/* out_pntr can be == in_pntr */
 
 void soundex(CHARSET_INFO * cs,register char * out_pntr, char * in_pntr,
-         pbool remove_garbage)
+	     pbool remove_garbage)
 {
   char ch,last_ch;
   reg3 char * end;
@@ -56,11 +56,11 @@ void soundex(CHARSET_INFO * cs,register char * out_pntr, char * in_pntr,
   }
   *out_pntr++ = map[(uchar)*in_pntr];	/* Copy first letter		 */
   last_ch = get_scode(cs,&in_pntr,0);	/* code of the first letter	 */
-                    /* for the first 'double-letter  */
-                    /* check.			 */
+					/* for the first 'double-letter  */
+					/* check.			 */
   end=out_pntr+3;			/* Loop on input letters until	 */
-                    /* end of input (null) or output */
-                    /* letter code count = 3	 */
+					/* end of input (null) or output */
+					/* letter code count = 3	 */
 
   in_pntr++;
   while (out_pntr < end && (ch = get_scode(cs,&in_pntr,remove_garbage)) != 0)
@@ -78,6 +78,7 @@ void soundex(CHARSET_INFO * cs,register char * out_pntr, char * in_pntr,
   return;
 } /* soundex */
 
+
   /*
     If alpha, map input letter to soundex code.
     If not alpha and remove_garbage is set then skip to next char
@@ -101,4 +102,4 @@ static char get_scode(CHARSET_INFO * cs,char **ptr, pbool remove_garbage)
     return 0;				/* Can't map */
   }
   return(soundex_map[ch-'A']);
-} /* get_scode */
\ No newline at end of file
+} /* get_scode */
diff --git a/dep/mysqllite/mysys/mf_tempdir.c b/dep/mysqllite/mysys/mf_tempdir.c
index 1b7b2f7..eceb90b 100644
--- a/dep/mysqllite/mysys/mf_tempdir.c
+++ b/dep/mysqllite/mysys/mf_tempdir.c
@@ -69,6 +69,7 @@ my_bool init_tmpdir(MY_TMPDIR *tmpdir, const char *pathlist)
   DBUG_RETURN(TRUE);
 }
 
+
 char *my_tmpdir(MY_TMPDIR *tmpdir)
 {
   char *dir;
@@ -90,4 +91,5 @@ void free_tmpdir(MY_TMPDIR *tmpdir)
     my_free(tmpdir->list[i]);
   delete_dynamic(&tmpdir->full_list);
   mysql_mutex_destroy(&tmpdir->mutex);
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/mf_tempfile.c b/dep/mysqllite/mysys/mf_tempfile.c
index a0f1fd1..1548207 100644
--- a/dep/mysqllite/mysys/mf_tempfile.c
+++ b/dep/mysqllite/mysys/mf_tempfile.c
@@ -22,6 +22,8 @@
 #include <paths.h>
 #endif
 
+
+
 /*
   @brief
   Create a temporary file with unique name in a given directory
@@ -53,8 +55,8 @@
 */
 
 File create_temp_file(char *to, const char *dir, const char *prefix,
-              int mode __attribute__((unused)),
-              myf MyFlags __attribute__((unused)))
+		      int mode __attribute__((unused)),
+		      myf MyFlags __attribute__((unused)))
 {
   File file= -1;
 #ifdef __WIN__
@@ -67,13 +69,13 @@ File create_temp_file(char *to, const char *dir, const char *prefix,
 
    /*
      Use GetTempPath to determine path for temporary files.
-     This is because the documentation for GetTempFileName
+     This is because the documentation for GetTempFileName 
      has the following to say about this parameter:
      "If this parameter is NULL, the function fails."
    */
    if (!dir)
    {
-     if(GetTempPath(sizeof(path_buf), path_buf) > 0)
+     if(GetTempPath(sizeof(path_buf), path_buf) > 0) 
        dir = path_buf;
    }
    /*
@@ -105,9 +107,9 @@ File create_temp_file(char *to, const char *dir, const char *prefix,
     File org_file;
 
     pfx_len= (uint) (strmov(strnmov(prefix_buff,
-                    prefix ? prefix : "tmp.",
-                    sizeof(prefix_buff)-7),"XXXXXX") -
-             prefix_buff);
+				    prefix ? prefix : "tmp.",
+				    sizeof(prefix_buff)-7),"XXXXXX") -
+		     prefix_buff);
     if (!dir && ! (dir =getenv("TMPDIR")))
       dir=P_tmpdir;
     if (strlen(dir)+ pfx_len > FN_REFLEN-2)
@@ -120,7 +122,7 @@ File create_temp_file(char *to, const char *dir, const char *prefix,
     if (mode & O_TEMPORARY)
       (void) my_delete(to, MYF(MY_WME | ME_NOINPUT));
     file=my_register_filename(org_file, to, FILE_BY_MKSTEMP,
-                  EE_CANTCREATEFILE, MyFlags);
+			      EE_CANTCREATEFILE, MyFlags);
     /* If we didn't manage to register the name, remove the temp file */
     if (org_file >= 0 && file < 0)
     {
@@ -154,9 +156,10 @@ File create_temp_file(char *to, const char *dir, const char *prefix,
       strmake(to,res,FN_REFLEN-1);
       (*free)(res);
       file=my_create(to,0,
-             (int) (O_RDWR | O_BINARY | O_TRUNC | O_EXCL | O_NOFOLLOW |
-                O_TEMPORARY | O_SHORT_LIVED),
-             MYF(MY_WME));
+		     (int) (O_RDWR | O_BINARY | O_TRUNC | O_EXCL | O_NOFOLLOW |
+			    O_TEMPORARY | O_SHORT_LIVED),
+		     MYF(MY_WME));
+
     }
     else
     {
@@ -171,4 +174,4 @@ File create_temp_file(char *to, const char *dir, const char *prefix,
   if (file >= 0)
     thread_safe_increment(my_tmp_file_created,&THR_LOCK_open);
   DBUG_RETURN(file);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_unixpath.c b/dep/mysqllite/mysys/mf_unixpath.c
index a75ed93..6777c27 100644
--- a/dep/mysqllite/mysys/mf_unixpath.c
+++ b/dep/mysqllite/mysys/mf_unixpath.c
@@ -33,4 +33,4 @@ void to_unix_path(char *to __attribute__((unused)))
       *to='/';
   }
 #endif
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/mf_wcomp.c b/dep/mysqllite/mysys/mf_wcomp.c
index b619f42..4786537 100644
--- a/dep/mysqllite/mysys/mf_wcomp.c
+++ b/dep/mysqllite/mysys/mf_wcomp.c
@@ -86,4 +86,4 @@ int wild_compare(register const char *str, register const char *wildstr,
     }
   }
   DBUG_RETURN (*str != 0);
-} /* wild_compare */
\ No newline at end of file
+} /* wild_compare */
diff --git a/dep/mysqllite/mysys/mulalloc.c b/dep/mysqllite/mysys/mulalloc.c
index 6494b51..f4ca3d9 100644
--- a/dep/mysqllite/mysys/mulalloc.c
+++ b/dep/mysqllite/mysys/mulalloc.c
@@ -25,10 +25,10 @@
   SYNOPSIS
     my_multi_malloc()
       myFlags              Flags
-    ptr1, length1      Multiple arguments terminated by null ptr
-    ptr2, length2      ...
+	ptr1, length1      Multiple arguments terminated by null ptr
+	ptr2, length2      ...
         ...
-    NULL
+	NULL
 */
 
 void* my_multi_malloc(myf myFlags, ...)
@@ -60,4 +60,4 @@ void* my_multi_malloc(myf myFlags, ...)
   }
   va_end(args);
   DBUG_RETURN((void*) start);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_access.c b/dep/mysqllite/mysys/my_access.c
index 8fc5368..43917da 100644
--- a/dep/mysqllite/mysys/my_access.c
+++ b/dep/mysqllite/mysys/my_access.c
@@ -20,27 +20,27 @@
 
 /*
   Check a file or path for accessability.
-
+ 
   SYNOPSIS
     file_access()
     path 	Path to file
     amode	Access method
-
+ 
   DESCRIPTION
-    This function wraps the normal access method because the access
-    available in MSVCRT> +reports that filenames such as LPT1 and
+    This function wraps the normal access method because the access 
+    available in MSVCRT> +reports that filenames such as LPT1 and 
     COM1 are valid (they are but should not be so for us).
-
+ 
   RETURN VALUES
   0    ok
   -1   error  (We use -1 as my_access is mapped to access on other platforms)
 */
 
-int my_access(const char *path, int amode)
-{
+int my_access(const char *path, int amode) 
+{ 
   WIN32_FILE_ATTRIBUTE_DATA fileinfo;
   BOOL result;
-
+	
   result= GetFileAttributesEx(path, GetFileExInfoStandard, &fileinfo);
   if (! result ||
       (fileinfo.dwFileAttributes & FILE_ATTRIBUTE_READONLY) && (amode & W_OK))
@@ -53,11 +53,12 @@ int my_access(const char *path, int amode)
 
 #endif /* __WIN__ */
 
+
 /*
   List of file names that causes problem on windows
 
   NOTE that one can also not have file names of type CON.TXT
-
+  
   NOTE: it is important to keep "CLOCK$" on the first place,
   we skip it in check_if_legal_tablename.
 */
@@ -72,10 +73,11 @@ int my_access(const char *path, int amode)
 
 #define MAX_RESERVED_NAME_LENGTH 6
 
+
 /*
   Looks up a null-terminated string in a list,
   case insensitively.
-
+ 
   SYNOPSIS
     str_list_find()
     list        list of items
@@ -96,6 +98,7 @@ static int str_list_find(const char **list, const char *str)
   return 0;
 }
 
+
 /*
   A map for faster reserved_names lookup,
   helps to avoid loops in many cases.
@@ -123,9 +126,10 @@ static int str_list_find(const char **list, const char *str)
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  /* ................ */
 };
 
+
 /*
   Check if a table name may cause problems
-
+ 
   SYNOPSIS
     check_if_legal_tablename
     name 	Table name (without any extensions)
@@ -144,17 +148,20 @@ static int str_list_find(const char **list, const char *str)
 int check_if_legal_tablename(const char *name)
 {
   DBUG_ENTER("check_if_legal_tablename");
-  DBUG_RETURN((reserved_map[(uchar) name[0]] & 1) &&
+  DBUG_RETURN(name[0] != 0 && name[1] != 0 &&
+              (reserved_map[(uchar) name[0]] & 1) &&
               (reserved_map[(uchar) name[1]] & 2) &&
               (reserved_map[(uchar) name[2]] & 4) &&
               str_list_find(&reserved_names[1], name));
 }
 
+
 #if defined(__WIN__) || defined(__EMX__)
 
+
 /*
   Check if a path will access a reserverd file name that may cause problems
-
+ 
   SYNOPSIS
     check_if_legal_filename
     path 	Path to file
@@ -180,7 +187,7 @@ int check_if_legal_filename(const char *path)
   {
     const char *reserved= *reserved_name;       /* never empty */
     const char *name= path;
-
+    
     do
     {
       if (*reserved != my_toupper(&my_charset_latin1, *name))
@@ -192,4 +199,4 @@ int check_if_legal_filename(const char *path)
   DBUG_RETURN(0);
 }
 
-#endif /* defined(__WIN__) || defined(__EMX__) */
\ No newline at end of file
+#endif /* defined(__WIN__) || defined(__EMX__) */
diff --git a/dep/mysqllite/mysys/my_aes.c b/dep/mysqllite/mysys/my_aes.c
index 3250d27..575d470 100644
--- a/dep/mysqllite/mysys/my_aes.c
+++ b/dep/mysqllite/mysys/my_aes.c
@@ -13,11 +13,13 @@
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
 
+
 /*
   Implementation of AES Encryption for MySQL
   Initial version by Peter Zaitsev  June 2002
 */
 
+
 #include <my_global.h>
 #include <m_string.h>
 #include "my_aes.h"
@@ -28,12 +30,14 @@
 
 #define AES_BAD_DATA  -1	/* If bad data discovered during decoding */
 
+
 /* The structure for key information */
 typedef struct {
   int	nr;				/* Number of rounds */
   uint32   rk[4*(AES_MAXNR + 1)];	/* key schedule */
 } KEYINSTANCE;
 
+
 /*
   This is internal function just keeps joint code of Key generation
 
@@ -52,8 +56,8 @@
 */
 
 static int my_aes_create_key(KEYINSTANCE *aes_key,
-                 enum encrypt_dir direction, const char *key,
-                 int key_length)
+			     enum encrypt_dir direction, const char *key,
+			     int key_length)
 {
   uint8 rkey[AES_KEY_LENGTH/8];	 /* The real key to be used for encryption */
   uint8 *rkey_end=rkey+AES_KEY_LENGTH/8; /* Real key boundary */
@@ -71,29 +75,29 @@ static int my_aes_create_key(KEYINSTANCE *aes_key,
   }
 #ifdef AES_USE_KEY_BITS
   /*
-   This block is intended to allow more weak encryption if application
+   This block is intended to allow more weak encryption if application 
    build with libmysqld needs to correspond to export regulations
-   It should be never used in normal distribution as does not give
+   It should be never used in normal distribution as does not give 
    any speed improvement.
    To get worse security define AES_USE_KEY_BITS to number of bits
    you want key to be. It should be divisible by 8
-
-   WARNING: Changing this value results in changing of enryption for
+   
+   WARNING: Changing this value results in changing of enryption for 
    all key lengths  so altering this value will result in impossibility
-   to decrypt data encrypted with previous value
+   to decrypt data encrypted with previous value       
   */
 #define AES_USE_KEY_BYTES (AES_USE_KEY_BITS/8)
   /*
-   To get weaker key we use first AES_USE_KEY_BYTES bytes of created key
+   To get weaker key we use first AES_USE_KEY_BYTES bytes of created key 
    and cyclically copy them until we created all required key length
-  */
-  for (ptr= rkey+AES_USE_KEY_BYTES, sptr=rkey ; ptr < rkey_end;
+  */  
+  for (ptr= rkey+AES_USE_KEY_BYTES, sptr=rkey ; ptr < rkey_end; 
        ptr++,sptr++)
   {
     if (sptr == rkey+AES_USE_KEY_BYTES)
       sptr=rkey;
-    *ptr=*sptr;
-  }
+    *ptr=*sptr;   
+  }      
 #endif
   if (direction == AES_DECRYPT)
      aes_key->nr = rijndaelKeySetupDec(aes_key->rk, rkey, AES_KEY_LENGTH);
@@ -102,6 +106,7 @@ static int my_aes_create_key(KEYINSTANCE *aes_key,
   return 0;
 }
 
+
 /*
   Crypt buffer with AES encryption algorithm.
 
@@ -119,7 +124,7 @@ static int my_aes_create_key(KEYINSTANCE *aes_key,
 */
 
 int my_aes_encrypt(const char* source, int source_length, char* dest,
-           const char* key, int key_length)
+		   const char* key, int key_length)
 {
   KEYINSTANCE aes_key;
   uint8 block[AES_BLOCK_SIZE];	/* 128 bit block used for padding */
@@ -136,7 +141,7 @@ int my_aes_encrypt(const char* source, int source_length, char* dest,
   for (i = num_blocks; i > 0; i--)   /* Encode complete blocks */
   {
     rijndaelEncrypt(aes_key.rk, aes_key.nr, (const uint8*) source,
-            (uint8*) dest);
+		    (uint8*) dest);
     source+= AES_BLOCK_SIZE;
     dest+= AES_BLOCK_SIZE;
   }
@@ -149,6 +154,7 @@ int my_aes_encrypt(const char* source, int source_length, char* dest,
   return AES_BLOCK_SIZE*(num_blocks + 1);
 }
 
+
 /*
   DeCrypt buffer with AES encryption algorithm.
 
@@ -166,7 +172,7 @@ int my_aes_encrypt(const char* source, int source_length, char* dest,
 */
 
 int my_aes_decrypt(const char *source, int source_length, char *dest,
-           const char *key, int key_length)
+		   const char *key, int key_length)
 {
   KEYINSTANCE aes_key;
   uint8 block[AES_BLOCK_SIZE];	/* 128 bit block used for padding */
@@ -186,7 +192,7 @@ int my_aes_decrypt(const char *source, int source_length, char *dest,
   for (i = num_blocks-1; i > 0; i--)   /* Decode all but last blocks */
   {
     rijndaelDecrypt(aes_key.rk, aes_key.nr, (const uint8*) source,
-            (uint8*) dest);
+		    (uint8*) dest);
     source+= AES_BLOCK_SIZE;
     dest+= AES_BLOCK_SIZE;
   }
@@ -203,6 +209,7 @@ int my_aes_decrypt(const char *source, int source_length, char *dest,
   return AES_BLOCK_SIZE*num_blocks - pad_len;
 }
 
+
 /*
   Get size of buffer which will be large enough for encrypted data
 
@@ -217,4 +224,4 @@ int my_aes_decrypt(const char *source, int source_length, char *dest,
 int my_aes_get_size(int source_length)
 {
   return AES_BLOCK_SIZE*(source_length/AES_BLOCK_SIZE)+AES_BLOCK_SIZE;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_alloc.c b/dep/mysqllite/mysys/my_alloc.c
index 5a6b6d2..65af560 100644
--- a/dep/mysqllite/mysys/my_alloc.c
+++ b/dep/mysqllite/mysys/my_alloc.c
@@ -21,6 +21,7 @@
 #undef EXTRA_DEBUG
 #define EXTRA_DEBUG
 
+
 /*
   Initialize memory root
 
@@ -43,7 +44,7 @@
 */
 
 void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
-             size_t pre_alloc_size __attribute__((unused)))
+		     size_t pre_alloc_size __attribute__((unused)))
 {
   DBUG_ENTER("init_alloc_root");
   DBUG_PRINT("enter",("root: 0x%lx", (long) mem_root));
@@ -59,8 +60,8 @@ void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
   if (pre_alloc_size)
   {
     if ((mem_root->free= mem_root->pre_alloc=
-     (USED_MEM*) my_malloc(pre_alloc_size+ ALIGN_SIZE(sizeof(USED_MEM)),
-                   MYF(0))))
+	 (USED_MEM*) my_malloc(pre_alloc_size+ ALIGN_SIZE(sizeof(USED_MEM)),
+			       MYF(0))))
     {
       mem_root->free->size= pre_alloc_size+ALIGN_SIZE(sizeof(USED_MEM));
       mem_root->free->left= pre_alloc_size;
@@ -71,6 +72,7 @@ void init_alloc_root(MEM_ROOT *mem_root, size_t block_size,
   DBUG_VOID_RETURN;
 }
 
+
 /*
   SYNOPSIS
     reset_root_defaults()
@@ -126,10 +128,10 @@ void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,
       /* Allocate new prealloc block and add it to the end of free list */
       if ((mem= (USED_MEM *) my_malloc(size, MYF(0))))
       {
-        mem->size= size;
+        mem->size= size; 
         mem->left= pre_alloc_size;
         mem->next= *prev;
-        *prev= mem_root->pre_alloc= mem;
+        *prev= mem_root->pre_alloc= mem; 
       }
       else
       {
@@ -142,6 +144,7 @@ void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,
     mem_root->pre_alloc= 0;
 }
 
+
 void *alloc_root(MEM_ROOT *mem_root, size_t length)
 {
 #if defined(HAVE_purify) && defined(EXTRA_DEBUG)
@@ -193,8 +196,8 @@ void *alloc_root(MEM_ROOT *mem_root, size_t length)
   if ((*(prev= &mem_root->free)) != NULL)
   {
     if ((*prev)->left < length &&
-    mem_root->first_block_usage++ >= ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP &&
-    (*prev)->left < ALLOC_MAX_BLOCK_TO_DROP)
+	mem_root->first_block_usage++ >= ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP &&
+	(*prev)->left < ALLOC_MAX_BLOCK_TO_DROP)
     {
       next= *prev;
       *prev= next->next;			/* Remove block from list */
@@ -214,7 +217,7 @@ void *alloc_root(MEM_ROOT *mem_root, size_t length)
     if (!(next = (USED_MEM*) my_malloc(get_size,MYF(MY_WME | ME_FATALERROR))))
     {
       if (mem_root->error_handler)
-    (*mem_root->error_handler)();
+	(*mem_root->error_handler)();
       DBUG_RETURN((void*) 0);                      /* purecov: inspected */
     }
     mem_root->block_num++;
@@ -238,6 +241,7 @@ void *alloc_root(MEM_ROOT *mem_root, size_t length)
 #endif
 }
 
+
 /*
   Allocate many pointers at the same time.
 
@@ -320,6 +324,7 @@ static inline void mark_blocks_free(MEM_ROOT* root)
   root->first_block_usage= 0;
 }
 
+
 /*
   Deallocate everything used by alloc_root or just move
   used blocks to free list if called with MY_USED_TO_FREE
@@ -331,7 +336,7 @@ static inline void mark_blocks_free(MEM_ROOT* root)
 
         MY_MARK_BLOCKS_FREED	Don't free blocks, just mark them free
         MY_KEEP_PREALLOC	If this is not set, then free also the
-                        preallocated block
+        		        preallocated block
 
   NOTES
     One can call this function either with root block initialised with
@@ -403,11 +408,13 @@ void set_prealloc_root(MEM_ROOT *root, char *ptr)
   }
 }
 
+
 char *strdup_root(MEM_ROOT *root, const char *str)
 {
   return strmake_root(root, str, strlen(str));
 }
 
+
 char *strmake_root(MEM_ROOT *root, const char *str, size_t len)
 {
   char *pos;
@@ -419,10 +426,11 @@ char *strmake_root(MEM_ROOT *root, const char *str, size_t len)
   return pos;
 }
 
+
 void *memdup_root(MEM_ROOT *root, const void *str, size_t len)
 {
   char *pos;
   if ((pos=alloc_root(root,len)))
     memcpy(pos,str,len);
   return pos;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_atomic.c b/dep/mysqllite/mysys/my_atomic.c
index 405cc49..26348b5 100644
--- a/dep/mysqllite/mysys/my_atomic.c
+++ b/dep/mysqllite/mysys/my_atomic.c
@@ -62,4 +62,6 @@ void plain_pthread_mutex_unlock(safe_mutex_t *m)
   pthread_mutex_unlock(& m->mutex);
 }
 
-#endif
\ No newline at end of file
+#endif
+
+
diff --git a/dep/mysqllite/mysys/my_bit.c b/dep/mysqllite/mysys/my_bit.c
index da3a151..d36f52b 100644
--- a/dep/mysqllite/mysys/my_bit.c
+++ b/dep/mysqllite/mysys/my_bit.c
@@ -60,4 +60,5 @@
 0xBB, 0x7B, 0xFB, 0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97,
 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7, 0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F,
 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
-};
\ No newline at end of file
+};
+
diff --git a/dep/mysqllite/mysys/my_bitmap.c b/dep/mysqllite/mysys/my_bitmap.c
index 33820dc..47646fe 100644
--- a/dep/mysqllite/mysys/my_bitmap.c
+++ b/dep/mysqllite/mysys/my_bitmap.c
@@ -80,18 +80,21 @@ void create_last_word_mask(MY_BITMAP *map)
   }
 }
 
+
 static inline void bitmap_lock(MY_BITMAP *map __attribute__((unused)))
 {
   if (map->mutex)
     mysql_mutex_lock(map->mutex);
 }
 
+
 static inline void bitmap_unlock(MY_BITMAP *map __attribute__((unused)))
 {
   if (map->mutex)
     mysql_mutex_unlock(map->mutex);
 }
 
+
 static inline uint get_first_set(uint32 value, uint word_pos)
 {
   uchar *byte_ptr= (uchar*)&value;
@@ -111,6 +114,7 @@ static inline uint get_first_set(uint32 value, uint word_pos)
   return MY_BIT_NONE;
 }
 
+
 static inline uint get_first_not_set(uint32 value, uint word_pos)
 {
   uchar *byte_ptr= (uchar*)&value;
@@ -130,8 +134,9 @@ static inline uint get_first_not_set(uint32 value, uint word_pos)
   return MY_BIT_NONE;
 }
 
+
 my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
-            my_bool thread_safe __attribute__((unused)))
+		    my_bool thread_safe __attribute__((unused)))
 {
   DBUG_ENTER("bitmap_init");
   if (!buf)
@@ -154,6 +159,7 @@ my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
       map->mutex= (mysql_mutex_t *) ((char*) buf + size_in_bytes);
       mysql_mutex_init(key_BITMAP_mutex, map->mutex, MY_MUTEX_INIT_FAST);
     }
+
   }
 
   else
@@ -161,6 +167,7 @@ my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
     DBUG_ASSERT(thread_safe == 0);
   }
 
+
   map->bitmap= buf;
   map->n_bits= n_bits;
   create_last_word_mask(map);
@@ -168,6 +175,7 @@ my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
   DBUG_RETURN(0);
 }
 
+
 void bitmap_free(MY_BITMAP *map)
 {
   DBUG_ENTER("bitmap_free");
@@ -182,6 +190,7 @@ void bitmap_free(MY_BITMAP *map)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   test if bit already set and set it if it was not (thread unsafe method)
 
@@ -204,6 +213,7 @@ my_bool bitmap_fast_test_and_set(MY_BITMAP *map, uint bitmap_bit)
   return res;
 }
 
+
 /*
   test if bit already set and set it if it was not (thread safe method)
 
@@ -249,6 +259,7 @@ my_bool bitmap_fast_test_and_clear(MY_BITMAP *map, uint bitmap_bit)
   return res;
 }
 
+
 my_bool bitmap_test_and_clear(MY_BITMAP *map, uint bitmap_bit)
 {
   my_bool res;
@@ -259,6 +270,7 @@ my_bool bitmap_test_and_clear(MY_BITMAP *map, uint bitmap_bit)
   return res;
 }
 
+
 uint bitmap_set_next(MY_BITMAP *map)
 {
   uint bit_found;
@@ -268,13 +280,14 @@ uint bitmap_set_next(MY_BITMAP *map)
   return bit_found;
 }
 
+
 void bitmap_set_prefix(MY_BITMAP *map, uint prefix_size)
 {
   uint prefix_bytes, prefix_bits, d;
   uchar *m= (uchar *)map->bitmap;
 
   DBUG_ASSERT(map->bitmap &&
-          (prefix_size <= map->n_bits || prefix_size == (uint) ~0));
+	      (prefix_size <= map->n_bits || prefix_size == (uint) ~0));
   set_if_smaller(prefix_size, map->n_bits);
   if ((prefix_bytes= prefix_size / 8))
     memset(m, 0xff, prefix_bytes);
@@ -285,6 +298,7 @@ void bitmap_set_prefix(MY_BITMAP *map, uint prefix_size)
     bzero(m, d);
 }
 
+
 my_bool bitmap_is_prefix(const MY_BITMAP *map, uint prefix_size)
 {
   uint prefix_bits= prefix_size % 32;
@@ -326,6 +340,7 @@ my_bool bitmap_is_prefix(const MY_BITMAP *map, uint prefix_size)
   return word_ptr > map->last_word_ptr || last_word == 0;
 }
 
+
 my_bool bitmap_is_set_all(const MY_BITMAP *map)
 {
   my_bitmap_map *data_ptr= map->bitmap;
@@ -339,6 +354,7 @@ my_bool bitmap_is_set_all(const MY_BITMAP *map)
   return TRUE;
 }
 
+
 my_bool bitmap_is_clear_all(const MY_BITMAP *map)
 {
   my_bitmap_map *data_ptr= map->bitmap;
@@ -392,6 +408,7 @@ my_bool bitmap_is_overlapping(const MY_BITMAP *map1, const MY_BITMAP *map2)
   return FALSE;
 }
 
+
 void bitmap_intersect(MY_BITMAP *map, const MY_BITMAP *map2)
 {
   my_bitmap_map *to= map->bitmap, *from= map2->bitmap, *end;
@@ -414,6 +431,7 @@ void bitmap_intersect(MY_BITMAP *map, const MY_BITMAP *map2)
   }
 }
 
+
 /*
   Set/clear all bits above a bit.
 
@@ -444,6 +462,7 @@ void bitmap_set_above(MY_BITMAP *map, uint from_byte, uint use_bit)
     *to= use_byte;
 }
 
+
 void bitmap_subtract(MY_BITMAP *map, const MY_BITMAP *map2)
 {
   my_bitmap_map *to= map->bitmap, *from= map2->bitmap, *end;
@@ -455,6 +474,7 @@ void bitmap_subtract(MY_BITMAP *map, const MY_BITMAP *map2)
     *to &= ~(*from);
 }
 
+
 void bitmap_union(MY_BITMAP *map, const MY_BITMAP *map2)
 {
   my_bitmap_map *to= map->bitmap, *from= map2->bitmap, *end;
@@ -466,6 +486,7 @@ void bitmap_union(MY_BITMAP *map, const MY_BITMAP *map2)
     *to |= *from;
 }
 
+
 void bitmap_xor(MY_BITMAP *map, const MY_BITMAP *map2)
 {
   my_bitmap_map *to= map->bitmap, *from= map2->bitmap, *end;
@@ -477,6 +498,7 @@ void bitmap_xor(MY_BITMAP *map, const MY_BITMAP *map2)
     *to ^= *from;
 }
 
+
 void bitmap_invert(MY_BITMAP *map)
 {
   my_bitmap_map *to= map->bitmap, *end;
@@ -487,6 +509,7 @@ void bitmap_invert(MY_BITMAP *map)
     *to ^= 0xFFFFFFFF;
 }
 
+
 uint bitmap_bits_set(const MY_BITMAP *map)
 {
   my_bitmap_map *data_ptr= map->bitmap;
@@ -502,6 +525,7 @@ uint bitmap_bits_set(const MY_BITMAP *map)
   return res;
 }
 
+
 void bitmap_copy(MY_BITMAP *map, const MY_BITMAP *map2)
 {
   my_bitmap_map *to= map->bitmap, *from= map2->bitmap, *end;
@@ -513,6 +537,7 @@ void bitmap_copy(MY_BITMAP *map, const MY_BITMAP *map2)
     *to = *from;
 }
 
+
 uint bitmap_get_first_set(const MY_BITMAP *map)
 {
   uint word_pos;
@@ -528,6 +553,7 @@ uint bitmap_get_first_set(const MY_BITMAP *map)
   return get_first_set(*map->last_word_ptr & ~map->last_word_mask, word_pos);
 }
 
+
 uint bitmap_get_first(const MY_BITMAP *map)
 {
   uint word_pos;
@@ -543,6 +569,7 @@ uint bitmap_get_first(const MY_BITMAP *map)
   return get_first_not_set(*map->last_word_ptr | map->last_word_mask, word_pos);
 }
 
+
 uint bitmap_lock_set_next(MY_BITMAP *map)
 {
   uint bit_found;
@@ -552,10 +579,11 @@ uint bitmap_lock_set_next(MY_BITMAP *map)
   return bit_found;
 }
 
+
 void bitmap_lock_clear_bit(MY_BITMAP *map, uint bitmap_bit)
 {
   bitmap_lock(map);
   DBUG_ASSERT(map->bitmap && bitmap_bit < map->n_bits);
   bitmap_clear_bit(map, bitmap_bit);
   bitmap_unlock(map);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_chsize.c b/dep/mysqllite/mysys/my_chsize.c
index bf5e72a..97ecd88 100644
--- a/dep/mysqllite/mysys/my_chsize.c
+++ b/dep/mysqllite/mysys/my_chsize.c
@@ -26,7 +26,7 @@
       fd		File descriptor
       new_length	New file size
       filler		If we don't have truncate, fill up all bytes after
-            new_length with this character
+			new_length with this character
       MyFlags		Flags
 
   DESCRIPTION
@@ -36,7 +36,7 @@
 
   RETURN VALUE
     0	Ok
-    1	Error
+    1	Error 
 */
 int my_chsize(File fd, my_off_t newlength, int filler, myf MyFlags)
 {
@@ -44,7 +44,7 @@ int my_chsize(File fd, my_off_t newlength, int filler, myf MyFlags)
   uchar buff[IO_SIZE];
   DBUG_ENTER("my_chsize");
   DBUG_PRINT("my",("fd: %d  length: %lu  MyFlags: %d",fd,(ulong) newlength,
-           MyFlags));
+		   MyFlags));
 
   if ((oldsize= my_seek(fd, 0L, MY_SEEK_END, MYF(MY_WME+MY_FAE))) == newlength)
     DBUG_RETURN(0);
@@ -105,4 +105,4 @@ int my_chsize(File fd, my_off_t newlength, int filler, myf MyFlags)
   if (MyFlags & MY_WME)
     my_error(EE_CANT_CHSIZE, MYF(ME_BELL+ME_WAITTANG), my_errno);
   DBUG_RETURN(1);
-} /* my_chsize */
\ No newline at end of file
+} /* my_chsize */
diff --git a/dep/mysqllite/mysys/my_compress.c b/dep/mysqllite/mysys/my_compress.c
index 3c885a6..8420005 100644
--- a/dep/mysqllite/mysys/my_compress.c
+++ b/dep/mysqllite/mysys/my_compress.c
@@ -56,6 +56,7 @@ my_bool my_compress(uchar *packet, size_t *len, size_t *complen)
   DBUG_RETURN(0);
 }
 
+
 uchar *my_compress_alloc(const uchar *packet, size_t *len, size_t *complen)
 {
   uchar *compbuf;
@@ -88,6 +89,7 @@ uchar *my_compress_alloc(const uchar *packet, size_t *len, size_t *complen)
   return compbuf;
 }
 
+
 /*
   Uncompress packet
 
@@ -96,7 +98,7 @@ uchar *my_compress_alloc(const uchar *packet, size_t *len, size_t *complen)
      packet	Compressed data. This is is replaced with the orignal data.
      len	Length of compressed data
      complen	Length of the packet buffer (must be enough for the original
-            data)
+	        data)
 
    RETURN
      1   error
@@ -144,6 +146,7 @@ my_bool my_uncompress(uchar *packet, size_t len, size_t *complen)
 
 #define BLOB_HEADER 12
 
+
 /*
   packfrm is a method used to compress the frm file for storage in a
   handler. This method was developed for the NDB handler and has been moved
@@ -203,6 +206,7 @@ int packfrm(uchar *data, size_t len,
                       (long) *pack_data, (ulong) *pack_len));
 err:
   DBUG_RETURN(error);
+
 }
 
 /*
@@ -257,4 +261,4 @@ int unpackfrm(uchar **unpack_data, size_t *unpack_len,
                        (ulong) *unpack_len));
    DBUG_RETURN(0);
 }
-#endif /* HAVE_COMPRESS */
\ No newline at end of file
+#endif /* HAVE_COMPRESS */
diff --git a/dep/mysqllite/mysys/my_conio.c b/dep/mysqllite/mysys/my_conio.c
index 249d68f..5dbd311 100644
--- a/dep/mysqllite/mysys/my_conio.c
+++ b/dep/mysqllite/mysys/my_conio.c
@@ -13,6 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
 
+
 #include "mysys_priv.h"
 
 #ifdef __WIN__
@@ -28,8 +29,9 @@
   if found useful they are to be exported in mysys
 */
 
+
 /*
-  int my_pthread_auto_mutex_lock(HANDLE* ph, const char* name,
+  int my_pthread_auto_mutex_lock(HANDLE* ph, const char* name, 
                                  int id, int time)
   NOTES
     creates a mutex with given name and tries to lock it time msec.
@@ -46,15 +48,15 @@ int my_pthread_auto_mutex_lock(HANDLE* ph, const char* name, int id, int time)
 {
   int res;
   char tname[FN_REFLEN];
-
+  
   sprintf(tname, "%s-%08X", name, id);
-
+  
   *ph= CreateMutex(NULL, FALSE, tname);
   if (*ph == NULL)
     return GetLastError();
 
   res= WaitForSingleObject(*ph, time);
-
+  
   if (res == WAIT_TIMEOUT)
     return ERROR_SEM_TIMEOUT;
 
@@ -88,6 +90,7 @@ int my_pthread_auto_mutex_free(HANDLE* ph)
   return 0;
 }
 
+
 #define pthread_auto_mutex_decl(name)                           \
   HANDLE __h##name= NULL;
 
@@ -97,18 +100,19 @@ int my_pthread_auto_mutex_free(HANDLE* ph)
 #define pthread_auto_mutex_free(name)                           \
   my_pthread_auto_mutex_free(&__h##name)
 
+
 /*
   char* my_cgets()
 
   NOTES
     Replaces _cgets from libc to support input of more than 255 chars.
-    Reads from the console via ReadConsole into buffer which
+    Reads from the console via ReadConsole into buffer which 
     should be at least clen characters.
     Actual length of string returned in plen.
 
   WARNING
     my_cgets() does NOT check the pushback character buffer (i.e., _chbuf).
-    Thus, my_cgets() will not return any character that is pushed back by
+    Thus, my_cgets() will not return any character that is pushed back by 
     the _ungetch() call.
 
   RETURN
@@ -123,14 +127,14 @@ char* my_cgets(char *buffer, size_t clen, size_t* plen)
   char *result;
   DWORD plen_res;
   CONSOLE_SCREEN_BUFFER_INFO csbi;
-
+  
   pthread_auto_mutex_decl(my_conio_cs);
-
+ 
   /* lock the console for the current process*/
   if (pthread_auto_mutex_lock(my_conio_cs, GetCurrentProcessId(), INFINITE))
   {
     /* can not lock console */
-    pthread_auto_mutex_free(my_conio_cs);
+    pthread_auto_mutex_free(my_conio_cs);  
     return NULL;
   }
 
@@ -143,26 +147,26 @@ char* my_cgets(char *buffer, size_t clen, size_t* plen)
                             NULL, OPEN_EXISTING, 0, NULL);
   }
 
-  if (my_coninpfh == INVALID_HANDLE_VALUE)
+  if (my_coninpfh == INVALID_HANDLE_VALUE) 
   {
     /* unlock the console */
-    pthread_auto_mutex_free(my_conio_cs);
+    pthread_auto_mutex_free(my_conio_cs);  
     return(NULL);
   }
 
   GetConsoleMode((HANDLE)my_coninpfh, &state);
-  SetConsoleMode((HANDLE)my_coninpfh, ENABLE_LINE_INPUT |
+  SetConsoleMode((HANDLE)my_coninpfh, ENABLE_LINE_INPUT | 
                  ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT);
 
   GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
 
-  /*
+  /* 
     there is no known way to determine allowed buffer size for input
-    though it is known it should not be more than 64K
-    so we cut 64K and try first size of screen buffer
-    if it is still to large we cut half of it and try again
+    though it is known it should not be more than 64K               
+    so we cut 64K and try first size of screen buffer               
+    if it is still to large we cut half of it and try again         
     later we may want to cycle from min(clen, 65535) to allowed size
-    with small decrement to determine exact allowed buffer
+    with small decrement to determine exact allowed buffer           
   */
   clen= min(clen, 65535);
   do
@@ -193,7 +197,7 @@ char* my_cgets(char *buffer, size_t clen, size_t* plen)
     {
       *plen= *plen - 2;
     }
-    else
+    else 
     {
       if (*plen > 0 && buffer[*plen - 1] == '\r')
       {
@@ -210,9 +214,9 @@ char* my_cgets(char *buffer, size_t clen, size_t* plen)
 
   SetConsoleMode((HANDLE)my_coninpfh, state);
   /* unlock the console */
-  pthread_auto_mutex_free(my_conio_cs);
+  pthread_auto_mutex_free(my_conio_cs);  
 
   return result;
 }
 
-#endif /* __WIN__ */
\ No newline at end of file
+#endif /* __WIN__ */
diff --git a/dep/mysqllite/mysys/my_copy.c b/dep/mysqllite/mysys/my_copy.c
index b185eb9..e89f8c8 100644
--- a/dep/mysqllite/mysys/my_copy.c
+++ b/dep/mysqllite/mysys/my_copy.c
@@ -29,6 +29,7 @@ struct utimbuf {
 };
 #endif
 
+
 /*
   int my_copy(const char *from, const char *to, myf MyFlags)
 
@@ -76,15 +77,15 @@ int my_copy(const char *from, const char *to, myf MyFlags)
     create_flag= (MyFlags & MY_DONT_OVERWRITE_FILE) ? O_EXCL : O_TRUNC;
 
     if ((to_file=  my_create(to,(int) stat_buff.st_mode,
-                 O_WRONLY | create_flag | O_BINARY | O_SHARE,
-                 MyFlags)) < 0)
+			     O_WRONLY | create_flag | O_BINARY | O_SHARE,
+			     MyFlags)) < 0)
       goto err;
 
     while ((Count=my_read(from_file, buff, sizeof(buff), MyFlags)) != 0)
     {
-    if (Count == (uint) -1 ||
-        my_write(to_file,buff,Count,MYF(MyFlags | MY_NABP)))
-    goto err;
+	if (Count == (uint) -1 ||
+	    my_write(to_file,buff,Count,MYF(MyFlags | MY_NABP)))
+	goto err;
     }
 
     /* sync the destination file */
@@ -100,7 +101,7 @@ int my_copy(const char *from, const char *to, myf MyFlags)
     /* Copy modes if possible */
 
     if (MyFlags & MY_HOLD_ORIGINAL_MODES && !new_file_stat)
-    DBUG_RETURN(0);			/* File copyed but not stat */
+	DBUG_RETURN(0);			/* File copyed but not stat */
     /* Copy modes */
     if (chmod(to, stat_buff.st_mode & 07777))
     {
@@ -140,4 +141,4 @@ int my_copy(const char *from, const char *to, myf MyFlags)
     (void) my_delete(to, MyFlags);
   }
   DBUG_RETURN(-1);
-} /* my_copy */
\ No newline at end of file
+} /* my_copy */
diff --git a/dep/mysqllite/mysys/my_create.c b/dep/mysqllite/mysys/my_create.c
index 8c9e8ce..2e4e8eb 100644
--- a/dep/mysqllite/mysys/my_create.c
+++ b/dep/mysqllite/mysys/my_create.c
@@ -23,27 +23,28 @@
 #include <share.h>
 #endif
 
-    /*
-    ** Create a new file
-    ** Arguments:
-    ** Path-name of file
-    ** Read | write on file (umask value)
-    ** Read & Write on open file
-    ** Special flags
-    */
+	/*
+	** Create a new file
+	** Arguments:
+	** Path-name of file
+	** Read | write on file (umask value)
+	** Read & Write on open file
+	** Special flags
+	*/
+
 
 File my_create(const char *FileName, int CreateFlags, int access_flags,
-           myf MyFlags)
+	       myf MyFlags)
 {
   int fd, rc;
   DBUG_ENTER("my_create");
   DBUG_PRINT("my",("Name: '%s' CreateFlags: %d  AccessFlags: %d  MyFlags: %d",
-           FileName, CreateFlags, access_flags, MyFlags));
+		   FileName, CreateFlags, access_flags, MyFlags));
 #if defined(_WIN32)
   fd= my_win_open(FileName, access_flags | O_CREAT);
 #else
   fd= open((char *) FileName, access_flags | O_CREAT,
-        CreateFlags ? CreateFlags : my_umask);
+	    CreateFlags ? CreateFlags : my_umask);
 #endif
 
   if ((MyFlags & MY_SYNC_DIR) && (fd >=0) &&
@@ -68,6 +69,6 @@ File my_create(const char *FileName, int CreateFlags, int access_flags,
     my_delete(FileName, MyFlags);
     my_errno= tmp;
   }
-
+  
   DBUG_RETURN(rc);
-} /* my_create */
\ No newline at end of file
+} /* my_create */
diff --git a/dep/mysqllite/mysys/my_delete.c b/dep/mysqllite/mysys/my_delete.c
index bac5e3b..cf9573f 100644
--- a/dep/mysqllite/mysys/my_delete.c
+++ b/dep/mysqllite/mysys/my_delete.c
@@ -28,7 +28,7 @@ int my_delete(const char *name, myf MyFlags)
     my_errno=errno;
     if (MyFlags & (MY_FAE+MY_WME))
       my_error(EE_DELETE,MYF(ME_BELL+ME_WAITTANG+(MyFlags & ME_NOINPUT)),
-           name,errno);
+	       name,errno);
   }
   else if ((MyFlags & MY_SYNC_DIR) &&
            my_sync_dir_by_file(name, MyFlags))
@@ -45,7 +45,7 @@ int my_delete(const char *name, myf MyFlags)
   that the file must be opened everywhere with FILE_SHARE_DELETE mode).
   Deleting not-closed files can not be supported on Win 98|ME (and because
   of that is considered harmful).
-
+  
   The function deletes the file with its preliminary renaming. This is
   because when not-closed share-delete file is deleted it still lives on
   a disk until it will not be closed everwhere. This may conflict with an
@@ -66,6 +66,7 @@ int my_delete(const char *name, myf MyFlags)
   @retval
     1   error
 
+
 */
 int nt_share_delete(const char *name, myf MyFlags)
 {
@@ -95,7 +96,7 @@ int nt_share_delete(const char *name, myf MyFlags)
 
   if (errno == ERROR_FILE_NOT_FOUND)
   {
-    my_errno= ENOENT;    // marking, that `name' doesn't exist
+    my_errno= ENOENT;    // marking, that `name' doesn't exist 
   }
   else if (errno == 0)
   {
@@ -121,4 +122,4 @@ int nt_share_delete(const char *name, myf MyFlags)
              name, my_errno);
   DBUG_RETURN(-1);
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/my_div.c b/dep/mysqllite/mysys/my_div.c
index 1b56ef7..d29d366 100644
--- a/dep/mysqllite/mysys/my_div.c
+++ b/dep/mysqllite/mysys/my_div.c
@@ -34,4 +34,4 @@ char * my_filename(File fd)
   }
   else
     DBUG_RETURN((char*) "UNOPENED");	/* Debug message */
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_error.c b/dep/mysqllite/mysys/my_error.c
index c5c7eb3..a60292b 100644
--- a/dep/mysqllite/mysys/my_error.c
+++ b/dep/mysqllite/mysys/my_error.c
@@ -56,6 +56,7 @@
 
 static struct my_err_head *my_errmsgs_list= &my_errmsgs_globerrs;
 
+
 /*
    Error message to user
 
@@ -96,6 +97,7 @@ void my_error(int nr, myf MyFlags, ...)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Error as printf
 
@@ -113,7 +115,7 @@ void my_printf_error(uint error, const char *format, myf MyFlags, ...)
   char ebuff[ERRMSGSIZE];
   DBUG_ENTER("my_printf_error");
   DBUG_PRINT("my", ("nr: %d  MyFlags: %d  errno: %d  Format: %s",
-            error, MyFlags, errno, format));
+		    error, MyFlags, errno, format));
 
   va_start(args,MyFlags);
   (void) my_vsnprintf_ex(&my_charset_utf8_general_ci, ebuff,
@@ -139,7 +141,7 @@ void my_printv_error(uint error, const char *format, myf MyFlags, va_list ap)
   char ebuff[ERRMSGSIZE];
   DBUG_ENTER("my_printv_error");
   DBUG_PRINT("my", ("nr: %d  MyFlags: %d  errno: %d  format: %s",
-            error, MyFlags, errno, format));
+		    error, MyFlags, errno, format));
 
   (void) my_vsnprintf(ebuff, sizeof(ebuff), format, ap);
   (*error_handler_hook)(error, ebuff, MyFlags);
@@ -161,6 +163,7 @@ void my_message(uint error, const char *str, register myf MyFlags)
   (*error_handler_hook)(error, str, MyFlags);
 }
 
+
 /*
   Register error messages for use with my_error().
 
@@ -218,6 +221,7 @@ int my_error_register(const char** (*get_errmsgs) (), int first, int last)
   return 0;
 }
 
+
 /*
   Unregister formerly registered error messages.
 
@@ -264,10 +268,11 @@ const char **my_error_unregister(int first, int last)
   /* Save the return value and free the header. */
   errmsgs= meh_p->get_errmsgs();
   my_free(meh_p);
-
+  
   return errmsgs;
 }
 
+
 void my_error_unregister_all(void)
 {
   struct my_err_head *cursor, *saved_next;
@@ -282,4 +287,4 @@ void my_error_unregister_all(void)
   my_errmsgs_globerrs.meh_next= NULL;  /* Freed in first iteration above. */
 
   my_errmsgs_list= &my_errmsgs_globerrs;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_file.c b/dep/mysqllite/mysys/my_file.c
index 23e5b99..719b77c 100644
--- a/dep/mysqllite/mysys/my_file.c
+++ b/dep/mysqllite/mysys/my_file.c
@@ -49,8 +49,8 @@ static uint set_max_open_files(uint max_file_limit)
   {
     old_cur= (uint) rlimit.rlim_cur;
     DBUG_PRINT("info", ("rlim_cur: %u  rlim_max: %u",
-            (uint) rlimit.rlim_cur,
-            (uint) rlimit.rlim_max));
+			(uint) rlimit.rlim_cur,
+			(uint) rlimit.rlim_max));
     if (rlimit.rlim_cur == RLIM_INFINITY)
       rlimit.rlim_cur = max_file_limit;
     if (rlimit.rlim_cur >= max_file_limit)
@@ -64,7 +64,7 @@ static uint set_max_open_files(uint max_file_limit)
       (void) getrlimit(RLIMIT_NOFILE,&rlimit);
       DBUG_PRINT("info", ("rlim_cur: %u", (uint) rlimit.rlim_cur));
       if (rlimit.rlim_cur)			/* If call didn't fail */
-    max_file_limit= (uint) rlimit.rlim_cur;
+	max_file_limit= (uint) rlimit.rlim_cur;
     }
   }
   DBUG_PRINT("exit",("max_file_limit: %u", max_file_limit));
@@ -79,6 +79,7 @@ static uint set_max_open_files(uint max_file_limit)
 }
 #endif
 
+
 /*
   Change number of open files
 
@@ -102,7 +103,7 @@ uint my_set_max_open_files(uint files)
     DBUG_RETURN(files);
 
   if (!(tmp= (struct st_my_file_info*) my_malloc(sizeof(*tmp) * files,
-                         MYF(MY_WME))))
+						 MYF(MY_WME))))
     DBUG_RETURN(MY_NFILE);
 
   /* Copy any initialized files */
@@ -117,6 +118,7 @@ uint my_set_max_open_files(uint files)
   DBUG_RETURN(files);
 }
 
+
 void my_free_open_file_info()
 {
   DBUG_ENTER("my_free_file_info");
@@ -130,4 +132,4 @@ void my_free_open_file_info()
     my_file_limit= MY_NFILE;
   }
   DBUG_VOID_RETURN;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_fopen.c b/dep/mysqllite/mysys/my_fopen.c
index d30ddb0..6e81b64 100644
--- a/dep/mysqllite/mysys/my_fopen.c
+++ b/dep/mysqllite/mysys/my_fopen.c
@@ -44,7 +44,7 @@ FILE *my_fopen(const char *filename, int flags, myf MyFlags)
   char type[5];
   DBUG_ENTER("my_fopen");
   DBUG_PRINT("my",("Name: '%s'  flags: %d  MyFlags: %d",
-           filename, flags, MyFlags));
+		   filename, flags, MyFlags));
 
   make_ftype(type,flags);
 
@@ -69,7 +69,7 @@ FILE *my_fopen(const char *filename, int flags, myf MyFlags)
     }
     mysql_mutex_lock(&THR_LOCK_open);
     if ((my_file_info[filedesc].name= (char*)
-     my_strdup(filename,MyFlags)))
+	 my_strdup(filename,MyFlags)))
     {
       my_stream_opened++;
       my_file_total_opened++;
@@ -87,11 +87,12 @@ FILE *my_fopen(const char *filename, int flags, myf MyFlags)
   DBUG_PRINT("error",("Got error %d on open",my_errno));
   if (MyFlags & (MY_FFNF | MY_FAE | MY_WME))
     my_error((flags & O_RDONLY) || (flags == O_RDONLY ) ? EE_FILENOTFOUND :
-         EE_CANTCREATEFILE,
-         MYF(ME_BELL+ME_WAITTANG), filename, my_errno);
+	     EE_CANTCREATEFILE,
+	     MYF(ME_BELL+ME_WAITTANG), filename, my_errno);
   DBUG_RETURN((FILE*) 0);
 } /* my_fopen */
 
+
 #if defined(_WIN32)
 
 static FILE *my_win_freopen(const char *path, const char *mode, FILE *stream)
@@ -183,6 +184,7 @@ static FILE *my_freebsd_freopen(const char *path, const char *mode, FILE *stream
 
 #endif
 
+
 /**
   Change the file associated with a file stream.
 
@@ -220,6 +222,7 @@ FILE *my_freopen(const char *path, const char *mode, FILE *stream)
   return result;
 }
 
+
 /* Close a stream */
 int my_fclose(FILE *fd, myf MyFlags)
 {
@@ -239,7 +242,7 @@ int my_fclose(FILE *fd, myf MyFlags)
     my_errno=errno;
     if (MyFlags & (MY_FAE | MY_WME))
       my_error(EE_BADCLOSE, MYF(ME_BELL+ME_WAITTANG),
-           my_filename(file),errno);
+	       my_filename(file),errno);
   }
   else
     my_stream_opened--;
@@ -252,8 +255,9 @@ int my_fclose(FILE *fd, myf MyFlags)
   DBUG_RETURN(err);
 } /* my_fclose */
 
-    /* Make a stream out of a file handle */
-    /* Name may be 0 */
+
+	/* Make a stream out of a file handle */
+	/* Name may be 0 */
 
 FILE *my_fdopen(File Filedes, const char *name, int Flags, myf MyFlags)
 {
@@ -261,7 +265,7 @@ FILE *my_fdopen(File Filedes, const char *name, int Flags, myf MyFlags)
   char type[5];
   DBUG_ENTER("my_fdopen");
   DBUG_PRINT("my",("Fd: %d  Flags: %d  MyFlags: %d",
-           Filedes, Flags, MyFlags));
+		   Filedes, Flags, MyFlags));
 
   make_ftype(type,Flags);
 #ifdef _WIN32
@@ -298,7 +302,8 @@ FILE *my_fdopen(File Filedes, const char *name, int Flags, myf MyFlags)
   DBUG_RETURN(fd);
 } /* my_fdopen */
 
-/*
+
+/*   
   Make a fopen() typestring from a open() type bitmap
 
   SYNOPSIS
@@ -307,47 +312,47 @@ FILE *my_fdopen(File Filedes, const char *name, int Flags, myf MyFlags)
     flag	Flag used by open()
 
   IMPLEMENTATION
-    This routine attempts to find the best possible match
-    between  a numeric option and a string option that could be
-    fed to fopen.  There is not a 1 to 1 mapping between the two.
-
+    This routine attempts to find the best possible match 
+    between  a numeric option and a string option that could be 
+    fed to fopen.  There is not a 1 to 1 mapping between the two.  
+  
   NOTE
     On Unix, O_RDONLY is usually 0
 
   MAPPING
-    r  == O_RDONLY
-    w  == O_WRONLY|O_TRUNC|O_CREAT
-    a  == O_WRONLY|O_APPEND|O_CREAT
-    r+ == O_RDWR
-    w+ == O_RDWR|O_TRUNC|O_CREAT
+    r  == O_RDONLY   
+    w  == O_WRONLY|O_TRUNC|O_CREAT  
+    a  == O_WRONLY|O_APPEND|O_CREAT  
+    r+ == O_RDWR  
+    w+ == O_RDWR|O_TRUNC|O_CREAT  
     a+ == O_RDWR|O_APPEND|O_CREAT
 */
 
 static void make_ftype(register char * to, register int flag)
 {
-  /* check some possible invalid combinations */
+  /* check some possible invalid combinations */  
   DBUG_ASSERT((flag & (O_TRUNC | O_APPEND)) != (O_TRUNC | O_APPEND));
   DBUG_ASSERT((flag & (O_WRONLY | O_RDWR)) != (O_WRONLY | O_RDWR));
 
-  if ((flag & (O_RDONLY|O_WRONLY)) == O_WRONLY)
-    *to++= (flag & O_APPEND) ? 'a' : 'w';
-  else if (flag & O_RDWR)
+  if ((flag & (O_RDONLY|O_WRONLY)) == O_WRONLY)    
+    *to++= (flag & O_APPEND) ? 'a' : 'w';  
+  else if (flag & O_RDWR)          
   {
-    /* Add '+' after theese */
-    if (flag & (O_TRUNC | O_CREAT))
-      *to++= 'w';
-    else if (flag & O_APPEND)
-      *to++= 'a';
-    else
+    /* Add '+' after theese */    
+    if (flag & (O_TRUNC | O_CREAT))      
+      *to++= 'w';    
+    else if (flag & O_APPEND)      
+      *to++= 'a';    
+    else      
       *to++= 'r';
-    *to++= '+';
-  }
-  else
+    *to++= '+';  
+  }  
+  else    
     *to++= 'r';
 
-#if FILE_BINARY            /* If we have binary-files */
-  if (flag & FILE_BINARY)
+#if FILE_BINARY            /* If we have binary-files */  
+  if (flag & FILE_BINARY)    
     *to++='b';
-#endif
+#endif  
   *to='\0';
-} /* make_ftype */
\ No newline at end of file
+} /* make_ftype */
diff --git a/dep/mysqllite/mysys/my_fstream.c b/dep/mysqllite/mysys/my_fstream.c
index 9203e62..e758609 100644
--- a/dep/mysqllite/mysys/my_fstream.c
+++ b/dep/mysqllite/mysys/my_fstream.c
@@ -47,7 +47,7 @@ size_t my_fread(FILE *stream, uchar *Buffer, size_t Count, myf MyFlags)
   size_t readbytes;
   DBUG_ENTER("my_fread");
   DBUG_PRINT("my",("stream: 0x%lx  Buffer: 0x%lx  Count: %u  MyFlags: %d",
-           (long) stream, (long) Buffer, (uint) Count, MyFlags));
+		   (long) stream, (long) Buffer, (uint) Count, MyFlags));
 
   if ((readbytes= fread(Buffer, sizeof(char), Count, stream)) != Count)
   {
@@ -55,12 +55,12 @@ size_t my_fread(FILE *stream, uchar *Buffer, size_t Count, myf MyFlags)
     if (MyFlags & (MY_WME | MY_FAE | MY_FNABP))
     {
       if (ferror(stream))
-    my_error(EE_READ, MYF(ME_BELL+ME_WAITTANG),
-         my_filename(my_fileno(stream)),errno);
+	my_error(EE_READ, MYF(ME_BELL+ME_WAITTANG),
+		 my_filename(my_fileno(stream)),errno);
       else
       if (MyFlags & (MY_NABP | MY_FNABP))
-    my_error(EE_EOFERR, MYF(ME_BELL+ME_WAITTANG),
-         my_filename(my_fileno(stream)),errno);
+	my_error(EE_EOFERR, MYF(ME_BELL+ME_WAITTANG),
+		 my_filename(my_fileno(stream)),errno);
     }
     my_errno=errno ? errno : -1;
     if (ferror(stream) || MyFlags & (MY_NABP | MY_FNABP))
@@ -71,6 +71,7 @@ size_t my_fread(FILE *stream, uchar *Buffer, size_t Count, myf MyFlags)
   DBUG_RETURN(readbytes);
 } /* my_fread */
 
+
 /*
   Write a chunk of bytes to a stream
 
@@ -94,7 +95,7 @@ size_t my_fwrite(FILE *stream, const uchar *Buffer, size_t Count, myf MyFlags)
 #endif
   DBUG_ENTER("my_fwrite");
   DBUG_PRINT("my",("stream: 0x%lx  Buffer: 0x%lx  Count: %u  MyFlags: %d",
-           (long) stream, (long) Buffer, (uint) Count, MyFlags));
+		   (long) stream, (long) Buffer, (uint) Count, MyFlags));
 
 #if !defined(NO_BACKGROUND) && defined(USE_MY_STREAM)
   errors=0;
@@ -110,21 +111,21 @@ size_t my_fwrite(FILE *stream, const uchar *Buffer, size_t Count, myf MyFlags)
       my_errno=errno;
       if (written != (size_t) -1)
       {
-    seekptr+=written;
-    Buffer+=written;
-    writtenbytes+=written;
-    Count-=written;
+	seekptr+=written;
+	Buffer+=written;
+	writtenbytes+=written;
+	Count-=written;
       }
 #ifdef EINTR
       if (errno == EINTR)
       {
-    (void) my_fseek(stream,seekptr,MY_SEEK_SET,MYF(0));
-    continue;
+	(void) my_fseek(stream,seekptr,MY_SEEK_SET,MYF(0));
+	continue;
       }
 #endif
 #if !defined(NO_BACKGROUND) && defined(USE_MY_STREAM)
       if (my_thread_var->abort)
-    MyFlags&= ~ MY_WAIT_IF_FULL;		/* End if aborted by user */
+	MyFlags&= ~ MY_WAIT_IF_FULL;		/* End if aborted by user */
 
       if ((errno == ENOSPC || errno == EDQUOT) &&
           (MyFlags & MY_WAIT_IF_FULL))
@@ -137,13 +138,13 @@ size_t my_fwrite(FILE *stream, const uchar *Buffer, size_t Count, myf MyFlags)
 #endif
       if (ferror(stream) || (MyFlags & (MY_NABP | MY_FNABP)))
       {
-    if (MyFlags & (MY_WME | MY_FAE | MY_FNABP))
-    {
-      my_error(EE_WRITE, MYF(ME_BELL+ME_WAITTANG),
-           my_filename(my_fileno(stream)),errno);
-    }
-    writtenbytes= (size_t) -1;        /* Return that we got error */
-    break;
+	if (MyFlags & (MY_WME | MY_FAE | MY_FNABP))
+	{
+	  my_error(EE_WRITE, MYF(ME_BELL+ME_WAITTANG),
+		   my_filename(my_fileno(stream)),errno);
+	}
+	writtenbytes= (size_t) -1;        /* Return that we got error */
+	break;
       }
     }
     if (MyFlags & (MY_NABP | MY_FNABP))
@@ -155,18 +156,20 @@ size_t my_fwrite(FILE *stream, const uchar *Buffer, size_t Count, myf MyFlags)
   DBUG_RETURN(writtenbytes);
 } /* my_fwrite */
 
+
 /* Seek to position in file */
 
 my_off_t my_fseek(FILE *stream, my_off_t pos, int whence,
-          myf MyFlags __attribute__((unused)))
+		  myf MyFlags __attribute__((unused)))
 {
   DBUG_ENTER("my_fseek");
   DBUG_PRINT("my",("stream: 0x%lx  pos: %lu  whence: %d  MyFlags: %d",
                    (long) stream, (long) pos, whence, MyFlags));
   DBUG_RETURN(fseek(stream, (off_t) pos, whence) ?
-          MY_FILEPOS_ERROR : (my_off_t) ftell(stream));
+	      MY_FILEPOS_ERROR : (my_off_t) ftell(stream));
 } /* my_seek */
 
+
 /* Tell current position of file */
 
 my_off_t my_ftell(FILE *stream, myf MyFlags __attribute__((unused)))
@@ -179,6 +182,7 @@ my_off_t my_ftell(FILE *stream, myf MyFlags __attribute__((unused)))
   DBUG_RETURN((my_off_t) pos);
 } /* my_ftell */
 
+
 /* Get a File corresponding to the stream*/
 int my_fileno(FILE *f)
 {
@@ -187,4 +191,4 @@ int my_fileno(FILE *f)
 #else
  return fileno(f);
 #endif
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_gethwaddr.c b/dep/mysqllite/mysys/my_gethwaddr.c
index 37dae3e..54823a7 100644
--- a/dep/mysqllite/mysys/my_gethwaddr.c
+++ b/dep/mysqllite/mysys/my_gethwaddr.c
@@ -222,4 +222,5 @@ int main(int argc __attribute__((unused)),char **argv)
   printf("\n");
   return 0;
 }
-#endif
\ No newline at end of file
+#endif
+
diff --git a/dep/mysqllite/mysys/my_getncpus.c b/dep/mysqllite/mysys/my_getncpus.c
index 828fb02..34257ff 100644
--- a/dep/mysqllite/mysys/my_getncpus.c
+++ b/dep/mysqllite/mysys/my_getncpus.c
@@ -46,4 +46,4 @@ int my_getncpus()
 #endif
   }
   return ncpus;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_getopt.c b/dep/mysqllite/mysys/my_getopt.c
index f454fc0..2ab9d44 100644
--- a/dep/mysqllite/mysys/my_getopt.c
+++ b/dep/mysqllite/mysys/my_getopt.c
@@ -53,7 +53,7 @@ enum enum_special_opt
 char *disabled_my_option= (char*) "0";
 char *enabled_my_option= (char*) "1";
 
-/*
+/* 
    This is a flag that can be set in client programs. 0 means that
    my_getopt will not print error messages, but the client should do
    it by itself
@@ -61,7 +61,7 @@ enum enum_special_opt
 
 my_bool my_getopt_print_errors= 1;
 
-/*
+/* 
    This is a flag that can be set in client programs. 1 means that
    my_getopt will skip over options it does not know how to handle.
 */
@@ -149,8 +149,8 @@ void my_getopt_register_get_addr(my_getopt_value func_addr)
   @return error in case of ambiguous or unknown options,
           0 on success.
 */
-int handle_options(int *argc, char ***argv,
-           const struct my_option *longopts,
+int handle_options(int *argc, char ***argv, 
+		   const struct my_option *longopts,
                    my_get_one_option get_one_option)
 {
   uint UNINIT_VAR(opt_found), argvpos= 0, length;
@@ -216,82 +216,82 @@ int handle_options(int *argc, char ***argv,
           (*argc)--;
           continue;
         }
-    opt_str= check_struct_option(cur_arg, key_name);
-    optend= strcend(opt_str, '=');
-    length= (uint) (optend - opt_str);
-    if (*optend == '=')
-      optend++;
-    else
-      optend= 0;
-
-    /*
-      Find first the right option. Return error in case of an ambiguous,
-      or unknown option
-    */
-    optp= longopts;
-    if (!(opt_found= findopt(opt_str, length, &optp, &prev_found)))
-    {
-      /*
-        Didn't find any matching option. Let's see if someone called
-        option with a special option prefix
-      */
-      if (!must_be_var)
-      {
-        if (optend)
-          must_be_var= 1; /* option is followed by an argument */
-        for (i= 0; special_opt_prefix[i]; i++)
-        {
-          if (!getopt_compare_strings(special_opt_prefix[i], opt_str,
-                      special_opt_prefix_lengths[i]) &&
-          (opt_str[special_opt_prefix_lengths[i]] == '-' ||
-           opt_str[special_opt_prefix_lengths[i]] == '_'))
-          {
-        /*
-          We were called with a special prefix, we can reuse opt_found
-        */
-        opt_str+= special_opt_prefix_lengths[i] + 1;
+	opt_str= check_struct_option(cur_arg, key_name);
+	optend= strcend(opt_str, '=');
+	length= (uint) (optend - opt_str);
+	if (*optend == '=')
+	  optend++;
+	else
+	  optend= 0;
+
+	/*
+	  Find first the right option. Return error in case of an ambiguous,
+	  or unknown option
+	*/
+	optp= longopts;
+	if (!(opt_found= findopt(opt_str, length, &optp, &prev_found)))
+	{
+	  /*
+	    Didn't find any matching option. Let's see if someone called
+	    option with a special option prefix
+	  */
+	  if (!must_be_var)
+	  {
+	    if (optend)
+	      must_be_var= 1; /* option is followed by an argument */
+	    for (i= 0; special_opt_prefix[i]; i++)
+	    {
+	      if (!getopt_compare_strings(special_opt_prefix[i], opt_str,
+					  special_opt_prefix_lengths[i]) &&
+		  (opt_str[special_opt_prefix_lengths[i]] == '-' ||
+		   opt_str[special_opt_prefix_lengths[i]] == '_'))
+	      {
+		/*
+		  We were called with a special prefix, we can reuse opt_found
+		*/
+		opt_str+= special_opt_prefix_lengths[i] + 1;
                 length-= special_opt_prefix_lengths[i] + 1;
-        if (i == OPT_LOOSE)
-          option_is_loose= 1;
-        if ((opt_found= findopt(opt_str, length, &optp, &prev_found)))
-        {
-          if (opt_found > 1)
-          {
-            if (my_getopt_print_errors)
+		if (i == OPT_LOOSE)
+		  option_is_loose= 1;
+		if ((opt_found= findopt(opt_str, length, &optp, &prev_found)))
+		{
+		  if (opt_found > 1)
+		  {
+		    if (my_getopt_print_errors)
                       my_getopt_error_reporter(ERROR_LEVEL,
                                                "%s: ambiguous option '--%s-%s' (--%s-%s)",
                                                my_progname, special_opt_prefix[i],
                                                opt_str, special_opt_prefix[i],
                                                prev_found);
-            return EXIT_AMBIGUOUS_OPTION;
-          }
-          switch (i) {
-          case OPT_SKIP:
-          case OPT_DISABLE: /* fall through */
-            /*
-              double negation is actually enable again,
-              for example: --skip-option=0 -> option = TRUE
-            */
-            optend= (optend && *optend == '0' && !(*(optend + 1))) ?
-              enabled_my_option : disabled_my_option;
-            break;
-          case OPT_ENABLE:
-            optend= (optend && *optend == '0' && !(*(optend + 1))) ?
+		    return EXIT_AMBIGUOUS_OPTION;
+		  }
+		  switch (i) {
+		  case OPT_SKIP:
+		  case OPT_DISABLE: /* fall through */
+		    /*
+		      double negation is actually enable again,
+		      for example: --skip-option=0 -> option = TRUE
+		    */
+		    optend= (optend && *optend == '0' && !(*(optend + 1))) ?
+		      enabled_my_option : disabled_my_option;
+		    break;
+		  case OPT_ENABLE:
+		    optend= (optend && *optend == '0' && !(*(optend + 1))) ?
                       disabled_my_option : enabled_my_option;
-            break;
-          case OPT_MAXIMUM:
-            set_maximum_value= 1;
-            must_be_var= 1;
-            break;
-          }
-          break; /* break from the inner loop, main loop continues */
-        }
+		    break;
+		  case OPT_MAXIMUM:
+		    set_maximum_value= 1;
+		    must_be_var= 1;
+		    break;
+		  }
+		  break; /* break from the inner loop, main loop continues */
+		}
                 i= -1; /* restart the loop */
-          }
-        }
-      }
-      if (!opt_found)
-      {
+	      }
+	    }
+	  }
+	  if (!opt_found)
+	  {
             if (my_getopt_skip_unknown)
             {
               /* Preserve all the components of this unknown option. */
@@ -300,177 +300,177 @@ int handle_options(int *argc, char ***argv,
               } while (first <= pos);
               continue;
             }
-        if (must_be_var)
-        {
-          if (my_getopt_print_errors)
-                my_getopt_error_reporter(option_is_loose ?
+	    if (must_be_var)
+	    {
+	      if (my_getopt_print_errors)
+                my_getopt_error_reporter(option_is_loose ? 
                                            WARNING_LEVEL : ERROR_LEVEL,
                                          "%s: unknown variable '%s'",
                                          my_progname, cur_arg);
-          if (!option_is_loose)
-        return EXIT_UNKNOWN_VARIABLE;
-        }
-        else
-        {
-          if (my_getopt_print_errors)
-                my_getopt_error_reporter(option_is_loose ?
+	      if (!option_is_loose)
+		return EXIT_UNKNOWN_VARIABLE;
+	    }
+	    else
+	    {
+	      if (my_getopt_print_errors)
+                my_getopt_error_reporter(option_is_loose ? 
                                            WARNING_LEVEL : ERROR_LEVEL,
-                                         "%s: unknown option '--%s'",
+                                         "%s: unknown option '--%s'", 
                                          my_progname, cur_arg);
-          if (!option_is_loose)
-        return EXIT_UNKNOWN_OPTION;
-        }
-        if (option_is_loose)
-        {
-          (*argc)--;
-          continue;
-        }
-      }
-    }
-    if (opt_found > 1)
-    {
-      if (must_be_var)
-      {
-        if (my_getopt_print_errors)
+	      if (!option_is_loose)
+		return EXIT_UNKNOWN_OPTION;
+	    }
+	    if (option_is_loose)
+	    {
+	      (*argc)--;
+	      continue;
+	    }
+	  }
+	}
+	if (opt_found > 1)
+	{
+	  if (must_be_var)
+	  {
+	    if (my_getopt_print_errors)
               my_getopt_error_reporter(ERROR_LEVEL,
                                        "%s: variable prefix '%s' is not unique",
                                        my_progname, opt_str);
-        return EXIT_VAR_PREFIX_NOT_UNIQUE;
-      }
-      else
-      {
-        if (my_getopt_print_errors)
+	    return EXIT_VAR_PREFIX_NOT_UNIQUE;
+	  }
+	  else
+	  {
+	    if (my_getopt_print_errors)
               my_getopt_error_reporter(ERROR_LEVEL,
                                        "%s: ambiguous option '--%s' (%s, %s)",
-                                       my_progname, opt_str, prev_found,
+                                       my_progname, opt_str, prev_found, 
                                        optp->name);
-        return EXIT_AMBIGUOUS_OPTION;
-      }
-    }
-    if ((optp->var_type & GET_TYPE_MASK) == GET_DISABLED)
-    {
-      if (my_getopt_print_errors)
-        fprintf(stderr,
-            "%s: %s: Option '%s' used, but is disabled\n", my_progname,
-            option_is_loose ? "WARNING" : "ERROR", opt_str);
-      if (option_is_loose)
-      {
-        (*argc)--;
-        continue;
-      }
-      return EXIT_OPTION_DISABLED;
-    }
+	    return EXIT_AMBIGUOUS_OPTION;
+	  }
+	}
+	if ((optp->var_type & GET_TYPE_MASK) == GET_DISABLED)
+	{
+	  if (my_getopt_print_errors)
+	    fprintf(stderr,
+		    "%s: %s: Option '%s' used, but is disabled\n", my_progname,
+		    option_is_loose ? "WARNING" : "ERROR", opt_str);
+	  if (option_is_loose)
+	  {
+	    (*argc)--;
+	    continue;
+	  }
+	  return EXIT_OPTION_DISABLED;
+	}
         error= 0;
-    value= optp->var_type & GET_ASK_ADDR ?
-      (*getopt_get_addr)(key_name, (uint) strlen(key_name), optp, &error) :
+	value= optp->var_type & GET_ASK_ADDR ?
+	  (*getopt_get_addr)(key_name, (uint) strlen(key_name), optp, &error) :
           optp->value;
         if (error)
           return error;
 
-    if (optp->arg_type == NO_ARG)
-    {
-      /*
-        Due to historical reasons GET_BOOL var_types still accepts arguments
-        despite the NO_ARG arg_type attribute. This can seems a bit unintuitive
-        and care should be taken when refactoring this code.
-      */
-      if (optend && (optp->var_type & GET_TYPE_MASK) != GET_BOOL)
-      {
-        if (my_getopt_print_errors)
+	if (optp->arg_type == NO_ARG)
+	{
+	  /*
+	    Due to historical reasons GET_BOOL var_types still accepts arguments
+	    despite the NO_ARG arg_type attribute. This can seems a bit unintuitive
+	    and care should be taken when refactoring this code.
+	  */
+	  if (optend && (optp->var_type & GET_TYPE_MASK) != GET_BOOL)
+	  {
+	    if (my_getopt_print_errors)
               my_getopt_error_reporter(ERROR_LEVEL,
                                        "%s: option '--%s' cannot take an argument",
                                        my_progname, optp->name);
-        return EXIT_NO_ARGUMENT_ALLOWED;
-      }
-      if ((optp->var_type & GET_TYPE_MASK) == GET_BOOL)
-      {
-        /*
-          Set bool to 1 if no argument or if the user has used
-          --enable-'option-name'.
-          *optend was set to '0' if one used --disable-option
-        */
-        (*argc)--;
-        if (!optend || *optend == '1' ||
-        !my_strcasecmp(&my_charset_latin1, optend, "true"))
-          *((my_bool*) value)= (my_bool) 1;
-        else if (*optend == '0' ||
-             !my_strcasecmp(&my_charset_latin1, optend, "false"))
-          *((my_bool*) value)= (my_bool) 0;
-        else
-        {
-          my_getopt_error_reporter(WARNING_LEVEL,
-                       "%s: ignoring option '--%s' "
+	    return EXIT_NO_ARGUMENT_ALLOWED;
+	  }
+	  if ((optp->var_type & GET_TYPE_MASK) == GET_BOOL)
+	  {
+	    /*
+	      Set bool to 1 if no argument or if the user has used
+	      --enable-'option-name'.
+	      *optend was set to '0' if one used --disable-option
+	    */
+	    (*argc)--;
+	    if (!optend || *optend == '1' ||
+		!my_strcasecmp(&my_charset_latin1, optend, "true"))
+	      *((my_bool*) value)= (my_bool) 1;
+	    else if (*optend == '0' ||
+		     !my_strcasecmp(&my_charset_latin1, optend, "false"))
+	      *((my_bool*) value)= (my_bool) 0;
+	    else
+	    {
+	      my_getopt_error_reporter(WARNING_LEVEL,
+				       "%s: ignoring option '--%s' "
                                        "due to invalid value '%s'",
-                       my_progname, optp->name, optend);
-          continue;
-        }
+				       my_progname, optp->name, optend);
+	      continue;
+	    }
             if (get_one_option && get_one_option(optp->id, optp,
                                *((my_bool*) value) ?
                                enabled_my_option : disabled_my_option))
               return EXIT_ARGUMENT_INVALID;
-        continue;
-      }
-      argument= optend;
-    }
-    else if (optp->arg_type == REQUIRED_ARG && !optend)
-    {
-      /* Check if there are more arguments after this one,
+	    continue;
+	  }
+	  argument= optend;
+	}
+	else if (optp->arg_type == REQUIRED_ARG && !optend)
+	{
+	  /* Check if there are more arguments after this one,
        Note: options loaded from config file that requires value
        should always be in the form '--option=value'.
     */
-      if (!is_cmdline_arg || !*++pos)
-      {
-        if (my_getopt_print_errors)
+	  if (!is_cmdline_arg || !*++pos)
+	  {
+	    if (my_getopt_print_errors)
               my_getopt_error_reporter(ERROR_LEVEL,
                                        "%s: option '--%s' requires an argument",
                                        my_progname, optp->name);
-        return EXIT_ARGUMENT_REQUIRED;
-      }
-      argument= *pos;
-      (*argc)--;
-    }
-    else
-      argument= optend;
+	    return EXIT_ARGUMENT_REQUIRED;
+	  }
+	  argument= *pos;
+	  (*argc)--;
+	}
+	else
+	  argument= optend;
       }
       else  /* must be short option */
       {
-    for (optend= cur_arg; *optend; optend++)
-    {
-      opt_found= 0;
-      for (optp= longopts; optp->name; optp++)
-      {
-        if (optp->id && optp->id == (int) (uchar) *optend)
-        {
-          /* Option recognized. Find next what to do with it */
-          opt_found= 1;
-          if ((optp->var_type & GET_TYPE_MASK) == GET_DISABLED)
-          {
-        if (my_getopt_print_errors)
-          fprintf(stderr,
-              "%s: ERROR: Option '-%c' used, but is disabled\n",
-              my_progname, optp->id);
-        return EXIT_OPTION_DISABLED;
-          }
-          if ((optp->var_type & GET_TYPE_MASK) == GET_BOOL &&
-          optp->arg_type == NO_ARG)
-          {
-        *((my_bool*) optp->value)= (my_bool) 1;
+	for (optend= cur_arg; *optend; optend++)
+	{
+	  opt_found= 0;
+	  for (optp= longopts; optp->name; optp++)
+	  {
+	    if (optp->id && optp->id == (int) (uchar) *optend)
+	    {
+	      /* Option recognized. Find next what to do with it */
+	      opt_found= 1;
+	      if ((optp->var_type & GET_TYPE_MASK) == GET_DISABLED)
+	      {
+		if (my_getopt_print_errors)
+		  fprintf(stderr,
+			  "%s: ERROR: Option '-%c' used, but is disabled\n",
+			  my_progname, optp->id);
+		return EXIT_OPTION_DISABLED;
+	      }
+	      if ((optp->var_type & GET_TYPE_MASK) == GET_BOOL &&
+		  optp->arg_type == NO_ARG)
+	      {
+		*((my_bool*) optp->value)= (my_bool) 1;
                 if (get_one_option && get_one_option(optp->id, optp, argument))
                   return EXIT_UNSPECIFIED_ERROR;
-        continue;
-          }
-          else if (optp->arg_type == REQUIRED_ARG ||
-               optp->arg_type == OPT_ARG)
-          {
-        if (*(optend + 1))
-        {
-          /* The rest of the option is option argument */
-          argument= optend + 1;
-          /* This is in effect a jump out of the outer loop */
-          optend= (char*) " ";
-        }
-        else
-        {
+		continue;
+	      }
+	      else if (optp->arg_type == REQUIRED_ARG ||
+		       optp->arg_type == OPT_ARG)
+	      {
+		if (*(optend + 1))
+		{
+		  /* The rest of the option is option argument */
+		  argument= optend + 1;
+		  /* This is in effect a jump out of the outer loop */
+		  optend= (char*) " ";
+		}
+		else
+		{
                   if (optp->arg_type == OPT_ARG)
                   {
                     if (optp->var_type == GET_BOOL)
@@ -479,30 +479,30 @@ int handle_options(int *argc, char ***argv,
                       return EXIT_UNSPECIFIED_ERROR;
                     continue;
                   }
-          /* Check if there are more arguments after this one */
-          if (!pos[1])
-          {
+		  /* Check if there are more arguments after this one */
+		  if (!pos[1])
+		  {
                     if (my_getopt_print_errors)
                       my_getopt_error_reporter(ERROR_LEVEL,
                                                "%s: option '-%c' requires an argument",
                                                my_progname, optp->id);
                     return EXIT_ARGUMENT_REQUIRED;
-          }
-          argument= *++pos;
-          (*argc)--;
-          /* the other loop will break, because *optend + 1 == 0 */
-        }
-          }
-          if ((error= setval(optp, optp->value, argument,
-                 set_maximum_value)))
-        return error;
+		  }
+		  argument= *++pos;
+		  (*argc)--;
+		  /* the other loop will break, because *optend + 1 == 0 */
+		}
+	      }
+	      if ((error= setval(optp, optp->value, argument,
+				 set_maximum_value)))
+		return error;
               if (get_one_option && get_one_option(optp->id, optp, argument))
                 return EXIT_UNSPECIFIED_ERROR;
-          break;
-        }
-      }
-      if (!opt_found)
-      {
+	      break;
+	    }
+	  }
+	  if (!opt_found)
+	  {
             if (my_getopt_skip_unknown)
             {
               /*
@@ -533,14 +533,14 @@ int handle_options(int *argc, char ***argv,
                                          my_progname, *optend);
               return EXIT_UNKNOWN_OPTION;
             }
-      }
-    }
+	  }
+	}
         if (opt_found)
           (*argc)--; /* option handled (short), decrease argument count */
-    continue;
+	continue;
       }
       if ((error= setval(optp, value, argument, set_maximum_value)))
-    return error;
+	return error;
       if (get_one_option && get_one_option(optp->id, optp, argument))
         return EXIT_UNSPECIFIED_ERROR;
 
@@ -559,6 +559,7 @@ int handle_options(int *argc, char ***argv,
   return 0;
 }
 
+
 /*
   function: check_struct_option
 
@@ -580,7 +581,7 @@ static char *check_struct_option(char *cur_arg, char *key_name)
   ptr= strcend(cur_arg + 1, '.'); /* Skip the first character */
   end= strcend(cur_arg, '=');
 
-  /*
+  /* 
      If the first dot is after an equal sign, then it is part
      of a variable value and the option is not a struct option.
      Also, if the last character in the string before the ending
@@ -635,7 +636,7 @@ static my_bool get_bool_argument(const struct my_option *opts,
 */
 
 static int setval(const struct my_option *opts, void *value, char *argument,
-          my_bool set_maximum_value)
+		  my_bool set_maximum_value)
 {
   int err= 0, res= 0;
 
@@ -709,6 +710,11 @@ static int setval(const struct my_option *opts, void *value, char *argument,
           }
           *(ulong*)value= arg;
         }
+        else if (type < 0)
+        {
+          res= EXIT_AMBIGUOUS_OPTION;
+          goto ret;
+        }
         else
           *(ulong*)value= type - 1;
       }
@@ -735,7 +741,7 @@ static int setval(const struct my_option *opts, void *value, char *argument,
         uint error_len;
 
         *((ulonglong*)value)=
-              find_set_from_flags(opts->typelib, opts->typelib->count,
+              find_set_from_flags(opts->typelib, opts->typelib->count, 
                                   *(ulonglong *)value, opts->def_value,
                                   argument, strlen(argument),
                                   &error, &error_len);
@@ -765,7 +771,8 @@ static int setval(const struct my_option *opts, void *value, char *argument,
   return res;
 }
 
-/*
+
+/* 
   Find option
 
   SYNOPSIS
@@ -788,8 +795,8 @@ static int setval(const struct my_option *opts, void *value, char *argument,
 */
 
 static int findopt(char *optpat, uint length,
-           const struct my_option **opt_res,
-           const char **ffname)
+		   const struct my_option **opt_res,
+		   const char **ffname)
 {
   uint count;
   const struct my_option *opt= *opt_res;
@@ -800,27 +807,28 @@ static int findopt(char *optpat, uint length,
     {
       (*opt_res)= opt;
       if (!opt->name[length])		/* Exact match */
-    return 1;
+	return 1;
       if (!count)
       {
         /* We only need to know one prev */
-    count= 1;
-    *ffname= opt->name;
+	count= 1;
+	*ffname= opt->name;
       }
       else if (strcmp(*ffname, opt->name))
       {
-    /*
-      The above test is to not count same option twice
-      (see mysql.cc, option "help")
-    */
-    count++;
+	/*
+	  The above test is to not count same option twice
+	  (see mysql.cc, option "help")
+	*/
+	count++;
       }
     }
   }
   return count;
 }
 
-/*
+
+/* 
   function: compare_strings
 
   Works like strncmp, other than 1.) considers '-' and '_' the same.
@@ -828,7 +836,7 @@ static int findopt(char *optpat, uint length,
 */
 
 my_bool getopt_compare_strings(register const char *s, register const char *t,
-                   uint length)
+			       uint length)
 {
   char const *end= s + length;
   for (;s != end ; s++, t++)
@@ -850,7 +858,7 @@ static longlong eval_num_suffix(char *argument, int *error, char *option_name)
 {
   char *endchar;
   longlong num;
-
+  
   *error= 0;
   errno= 0;
   num= strtoll(argument, &endchar, 10);
@@ -870,15 +878,15 @@ static longlong eval_num_suffix(char *argument, int *error, char *option_name)
   else if (*endchar)
   {
     fprintf(stderr,
-        "Unknown suffix '%c' used for variable '%s' (value '%s')\n",
-        *endchar, option_name, argument);
+	    "Unknown suffix '%c' used for variable '%s' (value '%s')\n",
+	    *endchar, option_name, argument);
     *error= 1;
     return 0;
   }
   return num;
 }
 
-/*
+/* 
   function: getopt_ll
 
   Evaluates and returns the value that user gave as an argument
@@ -971,6 +979,7 @@ static ulonglong getopt_ull(char *arg, const struct my_option *optp, int *err)
   return getopt_ull_limit_value(num, optp, NULL);
 }
 
+
 ulonglong getopt_ull_limit_value(ulonglong num, const struct my_option *optp,
                                  my_bool *fix)
 {
@@ -1092,7 +1101,7 @@ static double getopt_double(char *arg, const struct my_option *optp, int *err)
 */
 
 static void init_one_value(const struct my_option *option, void *variable,
-               longlong value)
+			   longlong value)
 {
   DBUG_ENTER("init_one_value");
   switch ((option->var_type & GET_TYPE_MASK)) {
@@ -1157,6 +1166,7 @@ static void init_one_value(const struct my_option *option, void *variable,
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Init one value to it's default values
 
@@ -1167,7 +1177,7 @@ static void init_one_value(const struct my_option *option, void *variable,
 */
 
 static void fini_one_value(const struct my_option *option, void *variable,
-               longlong value __attribute__ ((unused)))
+			   longlong value __attribute__ ((unused)))
 {
   DBUG_ENTER("fini_one_value");
   switch ((option->var_type & GET_TYPE_MASK)) {
@@ -1181,12 +1191,14 @@ static void fini_one_value(const struct my_option *option, void *variable,
   DBUG_VOID_RETURN;
 }
 
+
 void my_cleanup_options(const struct my_option *options)
 {
   init_variables(options, fini_one_value);
 }
 
-/*
+
+/* 
   initialize all variables to their default values
 
   SYNOPSIS
@@ -1215,7 +1227,7 @@ static void init_variables(const struct my_option *options,
     if (options->u_max_value)
       init_one_value(options, options->u_max_value, options->max_value);
     value= (options->var_type & GET_ASK_ADDR ?
-          (*getopt_get_addr)("", 0, options, 0) : options->value);
+		  (*getopt_get_addr)("", 0, options, 0) : options->value);
     if (value)
       init_one_value(options, value, options->def_value);
   }
@@ -1260,10 +1272,10 @@ void my_print_help(const struct my_option *options)
       printf("--");
       col+= 2 + print_name(optp);
       if (optp->arg_type == NO_ARG ||
-      (optp->var_type & GET_TYPE_MASK) == GET_BOOL)
+	  (optp->var_type & GET_TYPE_MASK) == GET_BOOL)
       {
-    putchar(' ');
-    col++;
+	putchar(' ');
+	col++;
       }
       else if ((optp->var_type & GET_TYPE_MASK) == GET_STR       ||
                (optp->var_type & GET_TYPE_MASK) == GET_STR_ALLOC ||
@@ -1271,20 +1283,20 @@ void my_print_help(const struct my_option *options)
                (optp->var_type & GET_TYPE_MASK) == GET_SET       ||
                (optp->var_type & GET_TYPE_MASK) == GET_FLAGSET    )
       {
-    printf("%s=name%s ", optp->arg_type == OPT_ARG ? "[" : "",
-           optp->arg_type == OPT_ARG ? "]" : "");
-    col+= (optp->arg_type == OPT_ARG) ? 8 : 6;
+	printf("%s=name%s ", optp->arg_type == OPT_ARG ? "[" : "",
+	       optp->arg_type == OPT_ARG ? "]" : "");
+	col+= (optp->arg_type == OPT_ARG) ? 8 : 6;
       }
       else
       {
-    printf("%s=#%s ", optp->arg_type == OPT_ARG ? "[" : "",
-           optp->arg_type == OPT_ARG ? "]" : "");
-    col+= (optp->arg_type == OPT_ARG) ? 5 : 3;
+	printf("%s=#%s ", optp->arg_type == OPT_ARG ? "[" : "",
+	       optp->arg_type == OPT_ARG ? "]" : "");
+	col+= (optp->arg_type == OPT_ARG) ? 5 : 3;
       }
       if (col > name_space && optp->comment && *optp->comment)
       {
-    putchar('\n');
-    col= 0;
+	putchar('\n');
+	col= 0;
       }
     }
     for (; col < name_space; col++)
@@ -1295,13 +1307,13 @@ void my_print_help(const struct my_option *options)
 
       while ((uint) (end - comment) > comment_space)
       {
-    for (line_end= comment + comment_space; *line_end != ' '; line_end--);
-    for (; comment != line_end; comment++)
-      putchar(*comment);
-    comment++; /* skip the space, as a newline will take it's place now */
-    putchar('\n');
-    for (col= 0; col < name_space; col++)
-      putchar(' ');
+	for (line_end= comment + comment_space; *line_end != ' '; line_end--);
+	for (; comment != line_end; comment++)
+	  putchar(*comment);
+	comment++; /* skip the space, as a newline will take it's place now */
+	putchar('\n');
+	for (col= 0; col < name_space; col++)
+	  putchar(' ');
       }
       printf("%s", comment);
     }
@@ -1318,6 +1330,7 @@ void my_print_help(const struct my_option *options)
   }
 }
 
+
 /*
   function: my_print_options
 
@@ -1344,76 +1357,76 @@ void my_print_variables(const struct my_option *options)
   for (length=1; length < 75; length++)
     putchar(length == name_space ? ' ' : '-');
   putchar('\n');
-
+  
   for (optp= options; optp->name; optp++)
   {
     void *value= (optp->var_type & GET_ASK_ADDR ?
-          (*getopt_get_addr)("", 0, optp, 0) : optp->value);
+		  (*getopt_get_addr)("", 0, optp, 0) : optp->value);
     if (value)
     {
       length= print_name(optp);
       for (; length < name_space; length++)
-    putchar(' ');
+	putchar(' ');
       switch ((optp->var_type & GET_TYPE_MASK)) {
       case GET_SET:
         if (!(llvalue= *(ulonglong*) value))
-      printf("%s\n", "");
-    else
+	  printf("%s\n", "");
+	else
         for (nr= 0; llvalue && nr < optp->typelib->count; nr++, llvalue >>=1)
-    {
-      if (llvalue & 1)
+	{
+	  if (llvalue & 1)
             printf( llvalue > 1 ? "%s," : "%s\n", get_type(optp->typelib, nr));
-    }
-    break;
+	}
+	break;
       case GET_FLAGSET:
         llvalue= *(ulonglong*) value;
         for (nr= 0; llvalue && nr < optp->typelib->count; nr++, llvalue >>=1)
-    {
+	{
           printf("%s%s=", (nr ? "," : ""), get_type(optp->typelib, nr));
-      printf(llvalue & 1 ? "on" : "off");
-    }
+	  printf(llvalue & 1 ? "on" : "off");
+	}
         printf("\n");
-    break;
+	break;
       case GET_ENUM:
         printf("%s\n", get_type(optp->typelib, *(ulong*) value));
-    break;
+	break;
       case GET_STR:
       case GET_STR_ALLOC:                    /* fall through */
-    printf("%s\n", *((char**) value) ? *((char**) value) :
-           "(No default value)");
-    break;
+	printf("%s\n", *((char**) value) ? *((char**) value) :
+	       "(No default value)");
+	break;
       case GET_BOOL:
-    printf("%s\n", *((my_bool*) value) ? "TRUE" : "FALSE");
-    break;
+	printf("%s\n", *((my_bool*) value) ? "TRUE" : "FALSE");
+	break;
       case GET_INT:
-    printf("%d\n", *((int*) value));
-    break;
+	printf("%d\n", *((int*) value));
+	break;
       case GET_UINT:
-    printf("%d\n", *((uint*) value));
-    break;
+	printf("%d\n", *((uint*) value));
+	break;
       case GET_LONG:
-    printf("%ld\n", *((long*) value));
-    break;
+	printf("%ld\n", *((long*) value));
+	break;
       case GET_ULONG:
-    printf("%lu\n", *((ulong*) value));
-    break;
+	printf("%lu\n", *((ulong*) value));
+	break;
       case GET_LL:
-    printf("%s\n", llstr(*((longlong*) value), buff));
-    break;
+	printf("%s\n", llstr(*((longlong*) value), buff));
+	break;
       case GET_ULL:
-    longlong2str(*((ulonglong*) value), buff, 10);
-    printf("%s\n", buff);
-    break;
+	longlong2str(*((ulonglong*) value), buff, 10);
+	printf("%s\n", buff);
+	break;
       case GET_DOUBLE:
-    printf("%g\n", *(double*) value);
-    break;
+	printf("%g\n", *(double*) value);
+	break;
       case GET_NO_ARG:
-    printf("(No default value)\n");
-    break;
+	printf("(No default value)\n");
+	break;
       default:
-    printf("(Disabled)\n");
-    break;
+	printf("(Disabled)\n");
+	break;
       }
     }
   }
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_getpagesize.c b/dep/mysqllite/mysys/my_getpagesize.c
index 9bb00ac..b0560ce 100644
--- a/dep/mysqllite/mysys/my_getpagesize.c
+++ b/dep/mysqllite/mysys/my_getpagesize.c
@@ -36,4 +36,5 @@ int my_getpagesize(void)
 
 #endif
 
-#endif
\ No newline at end of file
+#endif
+
diff --git a/dep/mysqllite/mysys/my_getsystime.c b/dep/mysqllite/mysys/my_getsystime.c
index 9fff0f9..63280f4 100644
--- a/dep/mysqllite/mysys/my_getsystime.c
+++ b/dep/mysqllite/mysys/my_getsystime.c
@@ -17,7 +17,7 @@
 /* thus to get the current time we should use the system function
    with the highest possible resolution */
 
-/*
+/* 
    TODO: in functions my_micro_time() and my_micro_time_and_time() there
    exists some common code that should be merged into a function.
 */
@@ -61,6 +61,7 @@ ulonglong my_getsystime()
 #endif
 }
 
+
 /**
   Return current time.
 
@@ -81,6 +82,7 @@ time_t my_time(myf flags)
   return t;
 }
 
+
 /**
   Return time in microseconds.
 
@@ -111,6 +113,7 @@ ulonglong my_micro_time()
 #endif
 }
 
+
 /**
   Return time in seconds and timer in microseconds (not different start!)
 
@@ -152,6 +155,7 @@ ulonglong my_micro_time_and_time(time_t *time_arg)
 #endif
 }
 
+
 /**
   Returns current time.
 
@@ -174,4 +178,5 @@ time_t my_time_possible_from_micro(ulonglong microtime __attribute__((unused)))
 #else
   return (time_t) (microtime / 1000000);
 #endif
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/my_getwd.c b/dep/mysqllite/mysys/my_getwd.c
index 72be0a3..3552081 100644
--- a/dep/mysqllite/mysys/my_getwd.c
+++ b/dep/mysqllite/mysys/my_getwd.c
@@ -85,6 +85,7 @@ int my_getwd(char * buf, size_t size, myf MyFlags)
   DBUG_RETURN(0);
 } /* my_getwd */
 
+
 /* Set new working directory */
 
 int my_setwd(const char *dir, myf MyFlags)
@@ -111,9 +112,9 @@ int my_setwd(const char *dir, myf MyFlags)
       pos= strmake(&curr_dir[0],start,(size_t) FN_REFLEN-1);
       if (pos[-1] != FN_LIBCHAR)
       {
-    length=(uint) (pos-(char*) curr_dir);
-    curr_dir[length]=FN_LIBCHAR;		/* must end with '/' */
-    curr_dir[length+1]='\0';
+	length=(uint) (pos-(char*) curr_dir);
+	curr_dir[length]=FN_LIBCHAR;		/* must end with '/' */
+	curr_dir[length+1]='\0';
       }
     }
     else
@@ -122,8 +123,10 @@ int my_setwd(const char *dir, myf MyFlags)
   DBUG_RETURN(res);
 } /* my_setwd */
 
-    /* Test if hard pathname */
-    /* Returns 1 if dirname is a hard path */
+
+
+	/* Test if hard pathname */
+	/* Returns 1 if dirname is a hard path */
 
 int test_if_hard_path(register const char *dir_name)
 {
@@ -138,6 +141,7 @@ int test_if_hard_path(register const char *dir_name)
 #endif
 } /* test_if_hard_path */
 
+
 /*
   Test if a name contains an (absolute or relative) path.
 
@@ -152,7 +156,7 @@ int test_if_hard_path(register const char *dir_name)
 
 my_bool has_path(const char *name)
 {
-  return test(strchr(name, FN_LIBCHAR))
+  return test(strchr(name, FN_LIBCHAR)) 
 #if FN_LIBCHAR != '/'
     || test(strchr(name,'/'))
 #endif
@@ -160,4 +164,4 @@ my_bool has_path(const char *name)
     || test(strchr(name, FN_DEVCHAR))
 #endif
     ;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_handler_errors.h b/dep/mysqllite/mysys/my_handler_errors.h
index 3bd8339..1c2f02f 100644
--- a/dep/mysqllite/mysys/my_handler_errors.h
+++ b/dep/mysqllite/mysys/my_handler_errors.h
@@ -1,7 +1,7 @@
 #ifndef MYSYS_MY_HANDLER_ERRORS_INCLUDED
 #define MYSYS_MY_HANDLER_ERRORS_INCLUDED
 
-/* Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -13,8 +13,8 @@
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA */
 
 /*
   Errors a handler can give you
@@ -81,7 +81,10 @@
   "File to short; Expected more data in file",
   "Read page with wrong checksum",
   "Too many active concurrent transactions",
-  "Index column length exceeds limit"
+  "Index column length exceeds limit",
+  "Index corrupted",
+  "Undo record too big",
+  "Table is being used in foreign key check"
 };
 
 extern void my_handler_error_register(void);
diff --git a/dep/mysqllite/mysys/my_init.c b/dep/mysqllite/mysys/my_init.c
index 06f4c1f..590fc7b 100644
--- a/dep/mysqllite/mysys/my_init.c
+++ b/dep/mysqllite/mysys/my_init.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -46,14 +46,15 @@ static ulong atoi_octal(const char *str)
   while (*str && my_isspace(&my_charset_latin1, *str))
     str++;
   str2int(str,
-      (*str == '0' ? 8 : 10),       /* Octalt or decimalt */
-      0, INT_MAX, &tmp);
+	  (*str == '0' ? 8 : 10),       /* Octalt or decimalt */
+	  0, INT_MAX, &tmp);
   return (ulong) tmp;
 }
 
 MYSQL_FILE *mysql_stdin= NULL;
 static MYSQL_FILE instrumented_stdin;
 
+
 /**
   Initialize my_sys functions, resources and variables
 
@@ -98,10 +99,6 @@ my_bool my_init(void)
   fastmutex_global_init();              /* Must be called early */
 #endif
 
-#if defined(HAVE_PTHREAD_INIT)
-  pthread_init();			/* Must be called before DBUG_ENTER */
-#endif
-
   /* $HOME is needed early to parse configuration files located in ~/ */
   if ((home_dir= getenv("HOME")) != 0)
     home_dir= intern_filename(home_dir_buff, home_dir);
@@ -118,7 +115,8 @@ my_bool my_init(void)
   }
 } /* my_init */
 
-    /* End my_sys */
+
+	/* End my_sys */
 
 void my_end(int infoflag)
 {
@@ -177,15 +175,15 @@ void my_end(int infoflag)
 Non-physical pagefaults %ld, Physical pagefaults %ld, Swaps %ld\n\
 Blocks in %ld out %ld, Messages in %ld out %ld, Signals %ld\n\
 Voluntary context switches %ld, Involuntary context switches %ld\n",
-          (rus.ru_utime.tv_sec * SCALE_SEC +
-           rus.ru_utime.tv_usec / SCALE_USEC) / 100.0,
-          (rus.ru_stime.tv_sec * SCALE_SEC +
-           rus.ru_stime.tv_usec / SCALE_USEC) / 100.0,
-          rus.ru_maxrss, rus.ru_idrss,
-          rus.ru_minflt, rus.ru_majflt,
-          rus.ru_nswap, rus.ru_inblock, rus.ru_oublock,
-          rus.ru_msgsnd, rus.ru_msgrcv, rus.ru_nsignals,
-          rus.ru_nvcsw, rus.ru_nivcsw);
+	      (rus.ru_utime.tv_sec * SCALE_SEC +
+	       rus.ru_utime.tv_usec / SCALE_USEC) / 100.0,
+	      (rus.ru_stime.tv_sec * SCALE_SEC +
+	       rus.ru_stime.tv_usec / SCALE_USEC) / 100.0,
+	      rus.ru_maxrss, rus.ru_idrss,
+	      rus.ru_minflt, rus.ru_majflt,
+	      rus.ru_nswap, rus.ru_inblock, rus.ru_oublock,
+	      rus.ru_msgsnd, rus.ru_msgrcv, rus.ru_nsignals,
+	      rus.ru_nvcsw, rus.ru_nivcsw);
 #endif
 #if defined(__WIN__) && defined(_MSC_VER)
    _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
@@ -223,11 +221,13 @@ void my_end(int infoflag)
   my_init_done=0;
 } /* my_end */
 
+
 #ifdef __WIN__
 
+
 /*
   my_parameter_handler
-
+  
   Invalid parameter handler we will use instead of the one "baked"
   into the CRT for MSC v8.  This one just prints out what invalid
   parameter was encountered.  By providing this routine, routines like
@@ -239,9 +239,10 @@ void my_parameter_handler(const wchar_t * expression, const wchar_t * function,
                           uintptr_t pReserved)
 {
   DBUG_PRINT("my",("Expression: %s  function: %s  file: %s, line: %d",
-           expression, function, file, line));
+		   expression, function, file, line));
 }
 
+
 #ifdef __MSVC_RUNTIME_CHECKS
 #include <rtcapi.h>
 
@@ -297,6 +298,7 @@ static void win_init_time(void)
   }
 }
 
+
 /*
   Open HKEY_LOCAL_MACHINE\SOFTWARE\MySQL and set any strings found
   there as environment variables
@@ -351,6 +353,7 @@ static void win_init_registry(void)
   }
 }
 
+
 static void my_win_init(void)
 {
   DBUG_ENTER("my_win_init");
@@ -385,6 +388,7 @@ static void my_win_init(void)
   DBUG_VOID_RETURN;
 }
 
+
 /*------------------------------------------------------------------
   Name: CheckForTcpip| Desc: checks if tcpip has been installed on system
   According to Microsoft Developers documentation the first registry
@@ -400,48 +404,49 @@ static my_bool win32_have_tcpip(void)
 {
   HKEY hTcpipRegKey;
   if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE, TCPIPKEY, 0, KEY_READ,
-              &hTcpipRegKey) != ERROR_SUCCESS)
+		      &hTcpipRegKey) != ERROR_SUCCESS)
   {
     if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE, WINSOCK2KEY, 0, KEY_READ,
-              &hTcpipRegKey) != ERROR_SUCCESS)
+		      &hTcpipRegKey) != ERROR_SUCCESS)
     {
       if (RegOpenKeyEx ( HKEY_LOCAL_MACHINE, WINSOCKKEY, 0, KEY_READ,
-             &hTcpipRegKey) != ERROR_SUCCESS)
-    if (!getenv("HAVE_TCPIP") || have_tcpip)	/* Provide a workaround */
-      return (FALSE);
+			 &hTcpipRegKey) != ERROR_SUCCESS)
+	if (!getenv("HAVE_TCPIP") || have_tcpip)	/* Provide a workaround */
+	  return (FALSE);
     }
   }
   RegCloseKey ( hTcpipRegKey);
   return (TRUE);
 }
 
+
 static my_bool win32_init_tcp_ip()
 {
   if (win32_have_tcpip())
   {
     WORD wVersionRequested = MAKEWORD( 2, 2 );
     WSADATA wsaData;
-    /* Be a good citizen: maybe another lib has already initialised
-        sockets, so dont clobber them unless necessary */
+ 	/* Be a good citizen: maybe another lib has already initialised
+ 		sockets, so dont clobber them unless necessary */
     if (WSAStartup( wVersionRequested, &wsaData ))
     {
       /* Load failed, maybe because of previously loaded
-     incompatible version; try again */
+	 incompatible version; try again */
       WSACleanup( );
       if (!WSAStartup( wVersionRequested, &wsaData ))
-    have_tcpip=1;
+	have_tcpip=1;
     }
     else
     {
       if (wsaData.wVersion != wVersionRequested)
       {
-    /* Version is no good, try again */
-    WSACleanup( );
-    if (!WSAStartup( wVersionRequested, &wsaData ))
-      have_tcpip=1;
+	/* Version is no good, try again */
+	WSACleanup( );
+	if (!WSAStartup( wVersionRequested, &wsaData ))
+	  have_tcpip=1;
       }
       else
-    have_tcpip=1;
+	have_tcpip=1;
     }
   }
   return(0);
@@ -552,4 +557,5 @@ void my_init_mysys_psi_keys()
   count= sizeof(all_mysys_files)/sizeof(all_mysys_files[0]);
   PSI_server->register_file(category, all_mysys_files, count);
 }
-#endif /* HAVE_PSI_INTERFACE */
\ No newline at end of file
+#endif /* HAVE_PSI_INTERFACE */
+
diff --git a/dep/mysqllite/mysys/my_lib.c b/dep/mysqllite/mysys/my_lib.c
index 8c313db..b42a3d5 100644
--- a/dep/mysqllite/mysys/my_lib.c
+++ b/dep/mysqllite/mysys/my_lib.c
@@ -48,7 +48,7 @@
 #endif
 
 /*
-  We are assuming that directory we are reading is either has less than
+  We are assuming that directory we are reading is either has less than 
   100 files and so can be read in one initial chunk or has more than 1000
   files and so big increment are suitable.
 */
@@ -56,31 +56,35 @@
 #define ENTRIES_INCREMENT  (65536/sizeof(FILEINFO))
 #define NAMES_START_SIZE   32768
 
+
 static int	comp_names(struct fileinfo *a,struct fileinfo *b);
 
-    /* We need this because program don't know with malloc we used */
+
+	/* We need this because program don't know with malloc we used */
 
 void my_dirend(MY_DIR *buffer)
 {
   DBUG_ENTER("my_dirend");
   if (buffer)
   {
-    delete_dynamic((DYNAMIC_ARRAY*)((char*)buffer +
+    delete_dynamic((DYNAMIC_ARRAY*)((char*)buffer + 
                                     ALIGN_SIZE(sizeof(MY_DIR))));
-    free_root((MEM_ROOT*)((char*)buffer + ALIGN_SIZE(sizeof(MY_DIR)) +
+    free_root((MEM_ROOT*)((char*)buffer + ALIGN_SIZE(sizeof(MY_DIR)) + 
                           ALIGN_SIZE(sizeof(DYNAMIC_ARRAY))), MYF(0));
     my_free(buffer);
   }
   DBUG_VOID_RETURN;
 } /* my_dirend */
 
-    /* Compare in sort of filenames */
+
+	/* Compare in sort of filenames */
 
 static int comp_names(struct fileinfo *a, struct fileinfo *b)
 {
   return (strcmp(a->name,b->name));
 } /* comp_names */
 
+
 #if !defined(_WIN32)
 
 MY_DIR	*my_dir(const char *path, myf MyFlags)
@@ -107,16 +111,16 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   if ((dirp->dd_fd) < 0)			/* Directory doesn't exists */
     goto error;
 #endif
-  if (dirp == NULL ||
-      ! (buffer= my_malloc(ALIGN_SIZE(sizeof(MY_DIR)) +
+  if (dirp == NULL || 
+      ! (buffer= my_malloc(ALIGN_SIZE(sizeof(MY_DIR)) + 
                            ALIGN_SIZE(sizeof(DYNAMIC_ARRAY)) +
                            sizeof(MEM_ROOT), MyFlags)))
     goto error;
 
-  dir_entries_storage= (DYNAMIC_ARRAY*)(buffer + ALIGN_SIZE(sizeof(MY_DIR)));
+  dir_entries_storage= (DYNAMIC_ARRAY*)(buffer + ALIGN_SIZE(sizeof(MY_DIR))); 
   names_storage= (MEM_ROOT*)(buffer + ALIGN_SIZE(sizeof(MY_DIR)) +
                              ALIGN_SIZE(sizeof(DYNAMIC_ARRAY)));
-
+  
   if (my_init_dynamic_array(dir_entries_storage, sizeof(FILEINFO),
                             ENTRIES_START_SIZE, ENTRIES_INCREMENT))
   {
@@ -124,25 +128,25 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
     goto error;
   }
   init_alloc_root(names_storage, NAMES_START_SIZE, NAMES_START_SIZE);
-
+  
   /* MY_DIR structure is allocated and completly initialized at this point */
   result= (MY_DIR*)buffer;
 
   tmp_file=strend(tmp_path);
 
   dp= (struct dirent*) dirent_tmp;
-
+  
   while (!(READDIR(dirp,(struct dirent*) dirent_tmp,dp)))
   {
     if (!(finfo.name= strdup_root(names_storage, dp->d_name)))
       goto error;
-
+    
     if (MyFlags & MY_WANT_STAT)
     {
-      if (!(finfo.mystat= (MY_STAT*)alloc_root(names_storage,
+      if (!(finfo.mystat= (MY_STAT*)alloc_root(names_storage, 
                                                sizeof(MY_STAT))))
         goto error;
-
+      
       bzero(finfo.mystat, sizeof(MY_STAT));
       (void) strmov(tmp_file,dp->d_name);
       (void) my_stat(tmp_path, finfo.mystat, MyFlags);
@@ -162,7 +166,7 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
 #endif
   result->dir_entry= (FILEINFO *)dir_entries_storage->buffer;
   result->number_off_files= dir_entries_storage->elements;
-
+  
   if (!(MyFlags & MY_DONT_SORT))
     my_qsort((void *) result->dir_entry, result->number_off_files,
           sizeof(FILEINFO), (qsort_cmp) comp_names);
@@ -181,6 +185,7 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   DBUG_RETURN((MY_DIR *) NULL);
 } /* my_dir */
 
+
 /*
  * Convert from directory name to filename.
  * On UNIX, it's simple: just make sure there is a terminating /
@@ -248,15 +253,15 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   tmp_file[2]='*';
   tmp_file[3]='\0';
 
-  if (!(buffer= my_malloc(ALIGN_SIZE(sizeof(MY_DIR)) +
+  if (!(buffer= my_malloc(ALIGN_SIZE(sizeof(MY_DIR)) + 
                           ALIGN_SIZE(sizeof(DYNAMIC_ARRAY)) +
                           sizeof(MEM_ROOT), MyFlags)))
     goto error;
 
-  dir_entries_storage= (DYNAMIC_ARRAY*)(buffer + ALIGN_SIZE(sizeof(MY_DIR)));
+  dir_entries_storage= (DYNAMIC_ARRAY*)(buffer + ALIGN_SIZE(sizeof(MY_DIR))); 
   names_storage= (MEM_ROOT*)(buffer + ALIGN_SIZE(sizeof(MY_DIR)) +
                              ALIGN_SIZE(sizeof(DYNAMIC_ARRAY)));
-
+  
   if (my_init_dynamic_array(dir_entries_storage, sizeof(FILEINFO),
                             ENTRIES_START_SIZE, ENTRIES_INCREMENT))
   {
@@ -264,7 +269,7 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
     goto error;
   }
   init_alloc_root(names_storage, NAMES_START_SIZE, NAMES_START_SIZE);
-
+  
   /* MY_DIR structure is allocated and completly initialized at this point */
   result= (MY_DIR*)buffer;
 
@@ -285,6 +290,7 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
   }
   else
   {
+
     do
     {
 #ifdef __BORLANDC__
@@ -370,7 +376,8 @@ MY_DIR	*my_dir(const char *path, myf MyFlags)
 /****************************************************************************
 ** File status
 ** Note that MY_STAT is assumed to be same as struct stat
-****************************************************************************/
+****************************************************************************/ 
+
 
 int my_fstat(File Filedes, MY_STAT *stat_area,
              myf MyFlags __attribute__((unused)))
@@ -384,6 +391,7 @@ int my_fstat(File Filedes, MY_STAT *stat_area,
 #endif
 }
 
+
 MY_STAT *my_stat(const char *path, MY_STAT *stat_area, myf my_flags)
 {
   int m_used;
@@ -413,4 +421,4 @@ MY_STAT *my_stat(const char *path, MY_STAT *stat_area, myf my_flags)
     DBUG_RETURN((MY_STAT *) NULL);
   }
   DBUG_RETURN((MY_STAT *) NULL);
-} /* my_stat */
\ No newline at end of file
+} /* my_stat */
diff --git a/dep/mysqllite/mysys/my_lock.c b/dep/mysqllite/mysys/my_lock.c
index 7624c4e..b1e347b 100644
--- a/dep/mysqllite/mysys/my_lock.c
+++ b/dep/mysqllite/mysys/my_lock.c
@@ -97,7 +97,7 @@ static int win_lock(File fd, int locktype, my_off_t start, my_off_t length,
       DBUG_RETURN(0);
     goto error;
   }
-
+  
   dwFlags|= LOCKFILE_FAIL_IMMEDIATELY;
   timeout_millis= timeout_sec * 1000;
   /* Try lock in a loop, until the lock is acquired or timeout happens */
@@ -124,8 +124,10 @@ static int win_lock(File fd, int locktype, my_off_t start, my_off_t length,
 }
 #endif
 
-/*
-  Lock a part of a file
+
+
+/* 
+  Lock a part of a file 
 
   RETURN VALUE
     0   Success
@@ -134,7 +136,7 @@ static int win_lock(File fd, int locktype, my_off_t start, my_off_t length,
 */
 
 int my_lock(File fd, int locktype, my_off_t start, my_off_t length,
-        myf MyFlags)
+	    myf MyFlags)
 {
 #ifdef HAVE_FCNTL
   int value;
@@ -143,7 +145,7 @@ int my_lock(File fd, int locktype, my_off_t start, my_off_t length,
 
   DBUG_ENTER("my_lock");
   DBUG_PRINT("my",("fd: %d  Op: %d  start: %ld  Length: %ld  MyFlags: %d",
-           fd,locktype,(long) start,(long) length,MyFlags));
+		   fd,locktype,(long) start,(long) length,MyFlags));
   if (my_disable_locking)
     DBUG_RETURN(0);
 
@@ -171,19 +173,19 @@ int my_lock(File fd, int locktype, my_off_t start, my_off_t length,
     if (MyFlags & MY_DONT_WAIT)
     {
       if (fcntl(fd,F_SETLK,&lock) != -1)	/* Check if we can lock */
-    DBUG_RETURN(0);			/* Ok, file locked */
+	DBUG_RETURN(0);			/* Ok, file locked */
       DBUG_PRINT("info",("Was locked, trying with alarm"));
       ALARM_INIT;
       while ((value=fcntl(fd,F_SETLKW,&lock)) && ! ALARM_TEST &&
-         errno == EINTR)
+	     errno == EINTR)
       {			/* Setup again so we don`t miss it */
-    ALARM_REINIT;
+	ALARM_REINIT;
       }
       ALARM_END;
       if (value != -1)
-    DBUG_RETURN(0);
+	DBUG_RETURN(0);
       if (errno == EINTR)
-    errno=EAGAIN;
+	errno=EAGAIN;
     }
     else if (fcntl(fd,F_SETLKW,&lock) != -1) /* Wait until a lock */
       DBUG_RETURN(0);
@@ -218,4 +220,4 @@ int my_lock(File fd, int locktype, my_off_t start, my_off_t length,
   }
   DBUG_PRINT("error",("my_errno: %d (%d)",my_errno,errno));
   DBUG_RETURN(-1);
-} /* my_lock */
\ No newline at end of file
+} /* my_lock */
diff --git a/dep/mysqllite/mysys/my_malloc.c b/dep/mysqllite/mysys/my_malloc.c
index 7b4bea6..fc2dc98 100644
--- a/dep/mysqllite/mysys/my_malloc.c
+++ b/dep/mysqllite/mysys/my_malloc.c
@@ -60,6 +60,7 @@ void *my_malloc(size_t size, myf my_flags)
   DBUG_RETURN(point);
 }
 
+
 /**
    @brief wrapper around realloc()
 
@@ -112,6 +113,7 @@ void *my_realloc(void *oldpoint, size_t size, myf my_flags)
   DBUG_RETURN(point);
 }
 
+
 /**
   Free memory allocated with my_malloc.
 
@@ -127,6 +129,7 @@ void my_free(void *ptr)
   DBUG_VOID_RETURN;
 }
 
+
 void *my_memdup(const void *from, size_t length, myf my_flags)
 {
   void *ptr;
@@ -135,6 +138,7 @@ void *my_memdup(const void *from, size_t length, myf my_flags)
   return ptr;
 }
 
+
 char *my_strdup(const char *from, myf my_flags)
 {
   char *ptr;
@@ -144,6 +148,7 @@ char *my_strdup(const char *from, myf my_flags)
   return ptr;
 }
 
+
 char *my_strndup(const char *from, size_t length, myf my_flags)
 {
   char *ptr;
@@ -153,4 +158,5 @@ char *my_strndup(const char *from, size_t length, myf my_flags)
     ptr[length]= 0;
   }
   return ptr;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/my_memmem.c b/dep/mysqllite/mysys/my_memmem.c
index 5f4252d..c000f14 100644
--- a/dep/mysqllite/mysys/my_memmem.c
+++ b/dep/mysqllite/mysys/my_memmem.c
@@ -45,6 +45,8 @@ void *my_memmem(const void *haystack, size_t haystacklen,
   return(NULL);
 }
 
+  
+
 #ifdef MAIN
 #include <assert.h>
 
@@ -78,4 +80,4 @@ int main(int argc, char *argv[]) {
   return(0);
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/my_mess.c b/dep/mysqllite/mysys/my_mess.c
index 647ddcb..8ee816b 100644
--- a/dep/mysqllite/mysys/my_mess.c
+++ b/dep/mysqllite/mysys/my_mess.c
@@ -31,4 +31,4 @@ void my_message_stderr(uint error __attribute__((unused)),
   (void)fputc('\n',stderr);
   (void)fflush(stderr);
   DBUG_VOID_RETURN;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_mkdir.c b/dep/mysqllite/mysys/my_mkdir.c
index 79c5f84..676c6c1 100644
--- a/dep/mysqllite/mysys/my_mkdir.c
+++ b/dep/mysqllite/mysys/my_mkdir.c
@@ -39,4 +39,4 @@ int my_mkdir(const char *dir, int Flags, myf MyFlags)
     DBUG_RETURN(-1);
   }
   DBUG_RETURN(0);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_mmap.c b/dep/mysqllite/mysys/my_mmap.c
index 6c9b022..acd4862 100644
--- a/dep/mysqllite/mysys/my_mmap.c
+++ b/dep/mysqllite/mysys/my_mmap.c
@@ -84,4 +84,5 @@ int my_msync(int fd, void *addr, size_t len, int flags)
 
 #else
 #warning "no mmap!"
-#endif
\ No newline at end of file
+#endif
+
diff --git a/dep/mysqllite/mysys/my_once.c b/dep/mysqllite/mysys/my_once.c
index 8f28334..7df9b0a 100644
--- a/dep/mysqllite/mysys/my_once.c
+++ b/dep/mysqllite/mysys/my_once.c
@@ -30,7 +30,7 @@
       MyFlags
 
   NOTES
-    No DBUG_ENTER... here to get smaller dbug-startup
+    No DBUG_ENTER... here to get smaller dbug-startup 
 */
 
 void* my_once_alloc(size_t Size, myf MyFlags)
@@ -59,7 +59,7 @@ void* my_once_alloc(size_t Size, myf MyFlags)
     {
       my_errno=errno;
       if (MyFlags & (MY_FAE+MY_WME))
-    my_error(EE_OUTOFMEMORY, MYF(ME_BELL+ME_WAITTANG),get_size);
+	my_error(EE_OUTOFMEMORY, MYF(ME_BELL+ME_WAITTANG),get_size);
       return((uchar*) 0);
     }
     DBUG_PRINT("test",("my_once_malloc %lu byte malloced", (ulong) get_size));
@@ -76,6 +76,7 @@ void* my_once_alloc(size_t Size, myf MyFlags)
   return((void*) point);
 } /* my_once_alloc */
 
+
 char *my_once_strdup(const char *src,myf myflags)
 {
   size_t len= strlen(src)+1;
@@ -85,6 +86,7 @@ char *my_once_strdup(const char *src,myf myflags)
   return (char*) dst;
 }
 
+
 void *my_once_memdup(const void *src, size_t len, myf myflags)
 {
   uchar *dst= my_once_alloc(len, myflags);
@@ -93,6 +95,7 @@ void *my_once_memdup(const void *src, size_t len, myf myflags)
   return dst;
 }
 
+
 /*
   Deallocate everything that was allocated with my_once_alloc
 
@@ -113,4 +116,4 @@ void my_once_free(void)
   my_once_root_block=0;
 
   DBUG_VOID_RETURN;
-} /* my_once_free */
\ No newline at end of file
+} /* my_once_free */
diff --git a/dep/mysqllite/mysys/my_open.c b/dep/mysqllite/mysys/my_open.c
index d66b5d3..c707839 100644
--- a/dep/mysqllite/mysys/my_open.c
+++ b/dep/mysqllite/mysys/my_open.c
@@ -18,13 +18,14 @@
 #include <my_dir.h>
 #include <errno.h>
 
+
 /*
   Open a file
 
   SYNOPSIS
     my_open()
       FileName	Fully qualified file name
-      Flags	Read | write
+      Flags	Read | write 
       MyFlags	Special flags
 
   RETURN VALUE
@@ -32,14 +33,14 @@
 */
 
 File my_open(const char *FileName, int Flags, myf MyFlags)
-                /* Path-name of file */
-                /* Read | write .. */
-                /* Special flags */
+				/* Path-name of file */
+				/* Read | write .. */
+				/* Special flags */
 {
   File fd;
   DBUG_ENTER("my_open");
   DBUG_PRINT("my",("Name: '%s'  Flags: %d  MyFlags: %d",
-           FileName, Flags, MyFlags));
+		   FileName, Flags, MyFlags));
 #if defined(_WIN32)
   fd= my_win_open(FileName, Flags);
 #elif !defined(NO_OPEN_3)
@@ -49,9 +50,10 @@ File my_open(const char *FileName, int Flags, myf MyFlags)
 #endif
 
   DBUG_RETURN(my_register_filename(fd, FileName, FILE_BY_OPEN,
-                   EE_FILENOTFOUND, MyFlags));
+				   EE_FILENOTFOUND, MyFlags));
 } /* my_open */
 
+
 /*
   Close a file
 
@@ -97,9 +99,10 @@ int my_close(File fd, myf MyFlags)
   DBUG_RETURN(err);
 } /* my_close */
 
+
 /*
   Register file in my_file_info[]
-
+   
   SYNOPSIS
     my_register_filename()
     fd			   File number opened, -1 if error on open
@@ -115,14 +118,14 @@ int my_close(File fd, myf MyFlags)
 */
 
 File my_register_filename(File fd, const char *FileName, enum file_type
-              type_of_file, uint error_message_number, myf MyFlags)
+			  type_of_file, uint error_message_number, myf MyFlags)
 {
   DBUG_ENTER("my_register_filename");
   if ((int) fd >= MY_FILE_MIN)
   {
     if ((uint) fd >= my_file_limit)
     {
-#if !defined(HAVE_PREAD)
+#if !defined(HAVE_PREAD) 
       my_errno= EMFILE;
 #else
       thread_safe_increment(my_file_opened,&THR_LOCK_open);
@@ -165,6 +168,9 @@ File my_register_filename(File fd, const char *FileName, enum file_type
   DBUG_RETURN(-1);
 }
 
+
+
+
 #ifdef EXTRA_DEBUG
 
 void my_print_open_files(void)
@@ -183,4 +189,4 @@ void my_print_open_files(void)
   }
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/my_pread.c b/dep/mysqllite/mysys/my_pread.c
index cb5ff87..310291d 100644
--- a/dep/mysqllite/mysys/my_pread.c
+++ b/dep/mysqllite/mysys/my_pread.c
@@ -22,6 +22,8 @@
 #include <unistd.h>
 #endif
 
+
+
 /*
   Read a chunk of bytes from a file from a given position
 
@@ -69,7 +71,7 @@ size_t my_pread(File Filedes, uchar *Buffer, size_t Count, my_off_t offset,
 #else
 #if defined(_WIN32)
     readbytes= my_win_pread(Filedes, Buffer, Count, offset);
-#else
+#else 
     readbytes= pread(Filedes, Buffer, Count, offset);
 #endif
     error= (readbytes != Count);
@@ -109,6 +111,7 @@ size_t my_pread(File Filedes, uchar *Buffer, size_t Count, my_off_t offset,
   }
 } /* my_pread */
 
+
 /*
   Write a chunk of bytes to a file at a given position
 
@@ -200,4 +203,4 @@ size_t my_pwrite(File Filedes, const uchar *Buffer, size_t Count,
   if (MyFlags & (MY_NABP | MY_FNABP))
     DBUG_RETURN(0);			/* Want only errors */
   DBUG_RETURN(writtenbytes+written); /* purecov: inspected */
-} /* my_pwrite */
\ No newline at end of file
+} /* my_pwrite */
diff --git a/dep/mysqllite/mysys/my_pthread.c b/dep/mysqllite/mysys/my_pthread.c
index 499f576..81d1f2a 100644
--- a/dep/mysqllite/mysys/my_pthread.c
+++ b/dep/mysqllite/mysys/my_pthread.c
@@ -84,8 +84,8 @@ struct tm *localtime_r(const time_t *clock, struct tm *res)
 #endif
 
 #if !defined(HAVE_GMTIME_R)
-/*
-  Reentrant version of standard gmtime() function.
+/* 
+  Reentrant version of standard gmtime() function. 
   Needed on some systems which don't implement it.
 */
 
@@ -128,6 +128,7 @@ void px_handle_sig(int sig)
   sigaddset(&px_recd, sig);
 }
 
+
 void sigwait_setup(sigset_t *set)
 {
   int i;
@@ -146,19 +147,19 @@ void sigwait_setup(sigset_t *set)
     {
       sigdelset(&rev_sigwait_set,i);
       if (!sigismember(&sigwait_set,i))
-    sigaction(i, &sact, (struct sigaction*) 0);
+	sigaction(i, &sact, (struct sigaction*) 0);
     }
     else
     {
       sigdelset(&px_recd,i);			/* Don't handle this */
       if (sigismember(&sigwait_set,i))
       {						/* Remove the old handler */
-    sigaddset(&unblock_mask,i);
-    sigdelset(&rev_sigwait_set,i);
-    sact1.sa_flags = 0;
-    sact1.sa_handler = SIG_DFL;
-    sigemptyset(&sact1.sa_mask);
-    sigaction(i, &sact1, 0);
+	sigaddset(&unblock_mask,i);
+	sigdelset(&rev_sigwait_set,i);
+	sact1.sa_flags = 0;
+	sact1.sa_handler = SIG_DFL;
+	sigemptyset(&sact1.sa_mask);
+	sigaction(i, &sact1, 0);
       }
     }
   }
@@ -167,6 +168,7 @@ void sigwait_setup(sigset_t *set)
   pthread_sigmask(SIG_UNBLOCK,&unblock_mask,(sigset_t*) 0);
 }
 
+
 int sigwait(sigset_t *setp, int *sigp)
 {
   if (memcmp(setp,&sigwait_set,sizeof(sigwait_set)))
@@ -188,16 +190,16 @@ int sigwait(sigset_t *setp, int *sigp)
     {
       if (*ptr)
       {
-    ulong set= *ptr;
-    int found= (int) ((char*) ptr - (char*) &px_recd)*8+1;
-    while (!(set & 1))
-    {
-      found++;
-      set>>=1;
-    }
-    *sigp=found;
-    sigdelset(&px_recd,found);
-    return 0;
+	ulong set= *ptr;
+	int found= (int) ((char*) ptr - (char*) &px_recd)*8+1;
+	while (!(set & 1))
+	{
+	  found++;
+	  set>>=1;
+	}
+	*sigp=found;
+	sigdelset(&px_recd,found);
+	return 0;
       }
     }
     sigsuspend(&rev_sigwait_set);
@@ -232,6 +234,7 @@ int sigwait(sigset_t *setp, int *sigp)
 static pthread_cond_t  COND_sigwait;
 static pthread_mutex_t LOCK_sigwait;
 
+
 void sigwait_handle_sig(int sig)
 {
   pthread_mutex_lock(&LOCK_sigwait);
@@ -276,6 +279,7 @@ void *sigwait_thread(void *set_arg)
   }
 }
 
+
 int sigwait(sigset_t *setp, int *sigp)
 {
   if (!inited)
@@ -305,17 +309,17 @@ int sigwait(sigset_t *setp, int *sigp)
     {
       if (*ptr)
       {
-    ulong set= *ptr;
-    int found= (int) ((char*) ptr - (char*) &pending_set)*8+1;
-    while (!(set & 1))
-    {
-      found++;
-      set>>=1;
-    }
-    *sigp=found;
-    sigdelset(&pending_set,found);
-    pthread_mutex_unlock(&LOCK_sigwait);
-    return 0;
+	ulong set= *ptr;
+	int found= (int) ((char*) ptr - (char*) &pending_set)*8+1;
+	while (!(set & 1))
+	{
+	  found++;
+	  set>>=1;
+	}
+	*sigp=found;
+	sigdelset(&pending_set,found);
+	pthread_mutex_unlock(&LOCK_sigwait);
+	return 0;
       }
     }
     pthread_cond_wait(&COND_sigwait, &LOCK_sigwait);
@@ -326,6 +330,7 @@ int sigwait(sigset_t *setp, int *sigp)
 #endif /* DONT_USE_SIGSUSPEND */
 #endif /* HAVE_SIGWAIT */
 
+
 /****************************************************************************
  The following functions fixes that all pthread functions should work
  according to latest posix standard
@@ -376,6 +381,7 @@ int my_pthread_cond_init(pthread_cond_t *mp, const pthread_condattr_t *attr)
 
 #endif
 
+
 /*****************************************************************************
   Patches for HPUX
   We need these because the pthread_mutex.. code returns -1 on error,
@@ -389,7 +395,7 @@ int my_pthread_cond_init(pthread_cond_t *mp, const pthread_condattr_t *attr)
 #if defined(HPUX10) || defined(HAVE_BROKEN_PTHREAD_COND_TIMEDWAIT)
 
 int my_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
-                  struct timespec *abstime)
+			      struct timespec *abstime)
 {
   int error=pthread_cond_timedwait(cond, mutex, abstime);
   if (error == -1)			/* Safety if the lib is fixed */
@@ -406,12 +412,13 @@ int my_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 #if defined(HPUX10)
 
 void my_pthread_attr_getstacksize(pthread_attr_t *connection_attrib,
-                  size_t *stack_size)
+				  size_t *stack_size)
 {
   *stack_size= pthread_attr_getstacksize(*connection_attrib);
 }
 #endif
 
+
 #ifdef HAVE_POSIX1003_4a_MUTEX
 /*
   In HP-UX-10.20 and other old Posix 1003.4a Draft 4 implementations
@@ -438,7 +445,7 @@ void my_pthread_attr_getstacksize(pthread_attr_t *connection_attrib,
   0		If we are able successfully lock the mutex.
   EBUSY		Mutex was locked by another thread
   #		Other error number returned by pthread_mutex_trylock()
-        (Not likely)
+		(Not likely)  
 */
 
 int my_pthread_mutex_trylock(pthread_mutex_t *mutex)
@@ -459,4 +466,4 @@ int my_pthread_mutex_trylock(pthread_mutex_t *mutex)
 int pthread_dummy(int ret)
 {
   return ret;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_quick.c b/dep/mysqllite/mysys/my_quick.c
index 4b476b2..2d5e9fb 100644
--- a/dep/mysqllite/mysys/my_quick.c
+++ b/dep/mysqllite/mysys/my_quick.c
@@ -19,6 +19,7 @@
 #include "mysys_priv.h"
 #include "my_nosys.h"
 
+
 #ifdef _WIN32
 extern size_t my_win_read(File Filedes,uchar *Buffer,size_t Count);
 #endif
@@ -35,7 +36,7 @@ size_t my_quick_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags)
   {
 #ifndef DBUG_OFF
     if ((readbytes == 0 || readbytes == (size_t) -1) && errno == EINTR)
-    {
+    {  
       DBUG_PRINT("error", ("my_quick_read() was interrupted and returned %d"
                            ".  This function does not retry the read!",
                            (int) readbytes));
@@ -47,6 +48,8 @@ size_t my_quick_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags)
   return (MyFlags & (MY_NABP | MY_FNABP)) ? 0 : readbytes;
 }
 
+
+
 size_t my_quick_write(File Filedes, const uchar *Buffer, size_t Count)
 {
 #ifdef _WIN32
@@ -65,7 +68,7 @@ size_t my_quick_write(File Filedes, const uchar *Buffer, size_t Count)
   {
 #ifndef DBUG_OFF
     if ((writtenbytes == 0 || writtenbytes == (size_t) -1) && errno == EINTR)
-    {
+    {  
       DBUG_PRINT("error", ("my_quick_write() was interrupted and returned %d"
                            ".  This function does not retry the write!",
                            (int) writtenbytes));
@@ -76,4 +79,4 @@ size_t my_quick_write(File Filedes, const uchar *Buffer, size_t Count)
   }
   return 0;
 #endif
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_rdtsc.c b/dep/mysqllite/mysys/my_rdtsc.c
index bf3e6e8..028c7f8 100644
--- a/dep/mysqllite/mysys/my_rdtsc.c
+++ b/dep/mysqllite/mysys/my_rdtsc.c
@@ -958,4 +958,5 @@ void my_timer_init(MY_TIMER_INFO *mti)
    Itanium), Windows, 64-bit Windows, QNX, FreeBSD, HPUX,
    Irix, Mac. We didn't test with SCO.
 
-*/
\ No newline at end of file
+*/
+
diff --git a/dep/mysqllite/mysys/my_read.c b/dep/mysqllite/mysys/my_read.c
index b859585..ca5fbfa 100644
--- a/dep/mysqllite/mysys/my_read.c
+++ b/dep/mysqllite/mysys/my_read.c
@@ -61,7 +61,7 @@ size_t my_read(File Filedes, uchar *Buffer, size_t Count, myf MyFlags)
                             my_errno));
 
       if ((readbytes == 0 || (int) readbytes == -1) && errno == EINTR)
-      {
+      {  
         DBUG_PRINT("debug", ("my_read() was interrupted and returned %ld",
                              (long) readbytes));
         continue;                              /* Interrupted */
@@ -94,4 +94,4 @@ size_t my_read(File Filedes, uchar *Buffer, size_t Count, myf MyFlags)
     break;
   }
   DBUG_RETURN(readbytes);
-} /* my_read */
\ No newline at end of file
+} /* my_read */
diff --git a/dep/mysqllite/mysys/my_redel.c b/dep/mysqllite/mysys/my_redel.c
index ee08c1b..a47df82 100644
--- a/dep/mysqllite/mysys/my_redel.c
+++ b/dep/mysqllite/mysys/my_redel.c
@@ -28,14 +28,14 @@ struct utimbuf {
 };
 #endif
 
-    /*
-      Rename with copy stat form old file
-      Copy stats from old file to new file, deletes orginal and
-      changes new file name to old file name
+	/*
+	  Rename with copy stat form old file
+	  Copy stats from old file to new file, deletes orginal and
+	  changes new file name to old file name
 
-      if MY_REDEL_MAKE_COPY is given, then the orginal file
-      is renamed to org_name-'current_time'.BAK
-    */
+	  if MY_REDEL_MAKE_COPY is given, then the orginal file
+	  is renamed to org_name-'current_time'.BAK
+	*/
 
 #define REDEL_EXT ".BAK"
 
@@ -44,19 +44,19 @@ int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)
   int error=1;
   DBUG_ENTER("my_redel");
   DBUG_PRINT("my",("org_name: '%s' tmp_name: '%s'  MyFlags: %d",
-           org_name,tmp_name,MyFlags));
+		   org_name,tmp_name,MyFlags));
 
   if (my_copystat(org_name,tmp_name,MyFlags) < 0)
     goto end;
   if (MyFlags & MY_REDEL_MAKE_BACKUP)
   {
-    char name_buff[FN_REFLEN+20];
+    char name_buff[FN_REFLEN+20];    
     char ext[20];
     ext[0]='-';
     get_date(ext+1,2+4,(time_t) 0);
     strmov(strend(ext),REDEL_EXT);
     if (my_rename(org_name, fn_format(name_buff, org_name, "", ext, 2),
-          MyFlags))
+		  MyFlags))
       goto end;
   }
   else if (my_delete_allow_opened(org_name, MyFlags))
@@ -69,8 +69,9 @@ int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)
   DBUG_RETURN(error);
 } /* my_redel */
 
-    /* Copy stat from one file to another */
-    /* Return -1 if can't get stat, 1 if wrong type of file */
+
+	/* Copy stat from one file to another */
+	/* Return -1 if can't get stat, 1 if wrong type of file */
 
 int my_copystat(const char *from, const char *to, int MyFlags)
 {
@@ -120,4 +121,4 @@ int my_copystat(const char *from, const char *to, int MyFlags)
   }
 
   return 0;
-} /* my_copystat */
\ No newline at end of file
+} /* my_copystat */
diff --git a/dep/mysqllite/mysys/my_rename.c b/dep/mysqllite/mysys/my_rename.c
index 85fb9c3..6704d7c 100644
--- a/dep/mysqllite/mysys/my_rename.c
+++ b/dep/mysqllite/mysys/my_rename.c
@@ -19,7 +19,7 @@
 #include "m_string.h"
 #undef my_rename
 
-    /* On unix rename deletes to file if it exists */
+	/* On unix rename deletes to file if it exists */
 
 int my_rename(const char *from, const char *to, myf MyFlags)
 {
@@ -37,7 +37,7 @@ int my_rename(const char *from, const char *to, myf MyFlags)
       my_errno=EEXIST;
       error= -1;
       if (MyFlags & MY_FAE+MY_WME)
-    my_error(EE_LINK, MYF(ME_BELL+ME_WAITTANG),from,to,my_errno);
+	my_error(EE_LINK, MYF(ME_BELL+ME_WAITTANG),from,to,my_errno);
       DBUG_RETURN(error);
     }
     my_errno=save_errno;
@@ -76,4 +76,4 @@ int my_rename(const char *from, const char *to, myf MyFlags)
 #endif
   }
   DBUG_RETURN(error);
-} /* my_rename */
\ No newline at end of file
+} /* my_rename */
diff --git a/dep/mysqllite/mysys/my_seek.c b/dep/mysqllite/mysys/my_seek.c
index 5a8a335..7d2c753 100644
--- a/dep/mysqllite/mysys/my_seek.c
+++ b/dep/mysqllite/mysys/my_seek.c
@@ -16,13 +16,13 @@
 #include "mysys_priv.h"
 #include "mysys_err.h"
 
-/*
+/* 
   Seek to a position in a file.
 
   ARGUMENTS
   File fd          The file descriptor
   my_off_t pos     The expected position (absolute or relative)
-  int whence       A direction parameter and one of
+  int whence       A direction parameter and one of 
                    {SEEK_SET, SEEK_CUR, SEEK_END}
   myf MyFlags      MY_THREADSAFE must be set in case my_seek may be mixed
                    with my_pread/my_pwrite calls and fd is shared among
@@ -30,7 +30,7 @@
 
   DESCRIPTION
     The my_seek  function  is a wrapper around the system call lseek and
-    repositions  the  offset of the file descriptor fd to the argument
+    repositions  the  offset of the file descriptor fd to the argument 
     offset according to the directive whence as follows:
       SEEK_SET    The offset is set to offset bytes.
       SEEK_CUR    The offset is set to its current location plus offset bytes
@@ -38,7 +38,7 @@
 
   RETURN VALUE
     my_off_t newpos    The new position in the file.
-    MY_FILEPOS_ERROR   An error was encountered while performing
+    MY_FILEPOS_ERROR   An error was encountered while performing 
                        the seek. my_errno is set to indicate the
                        actual error.
 */
@@ -75,6 +75,7 @@ my_off_t my_seek(File fd, my_off_t pos, int whence, myf MyFlags)
   DBUG_RETURN((my_off_t) newpos);
 } /* my_seek */
 
+
 	/* Tell current position of file */
 	/* ARGSUSED */
 
@@ -98,4 +99,4 @@ my_off_t my_tell(File fd, myf MyFlags)
   }
   DBUG_PRINT("exit",("pos: %llu", (ulonglong) pos));
   DBUG_RETURN((my_off_t) pos);
-} /* my_tell */
\ No newline at end of file
+} /* my_tell */
diff --git a/dep/mysqllite/mysys/my_sleep.c b/dep/mysqllite/mysys/my_sleep.c
index 18ee245..52ae6af 100644
--- a/dep/mysqllite/mysys/my_sleep.c
+++ b/dep/mysqllite/mysys/my_sleep.c
@@ -32,4 +32,4 @@ void my_sleep(ulong m_seconds)
   ulong start= (ulong) time((time_t*) 0);
   while ((ulong) time((time_t*) 0) < start+sec);
 #endif
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_static.c b/dep/mysqllite/mysys/my_static.c
index 984a409..a625946 100644
--- a/dep/mysqllite/mysys/my_static.c
+++ b/dep/mysqllite/mysys/my_static.c
@@ -24,11 +24,11 @@
 
 my_bool timed_mutexes= 0;
 
-    /* from my_init */
+	/* from my_init */
 char *	home_dir=0;
 const char      *my_progname=0;
 char		curr_dir[FN_REFLEN]= {0},
-        home_dir_buff[FN_REFLEN]= {0};
+		home_dir_buff[FN_REFLEN]= {0};
 ulong		my_stream_opened=0,my_file_opened=0, my_tmp_file_created=0;
 ulong           my_file_total_opened= 0;
 int		my_umask=0664, my_umask_dir=0777;
@@ -37,34 +37,34 @@
 uint   my_file_limit= MY_NFILE;
 struct st_my_file_info *my_file_info= my_file_info_default;
 
-    /* From mf_brkhant */
+	/* From mf_brkhant */
 int			my_dont_interrupt=0;
 volatile int		_my_signals=0;
 struct st_remember _my_sig_remember[MAX_SIGNALS]={{0,0}};
 
-    /* from mf_reccache.c */
+	/* from mf_reccache.c */
 ulong my_default_record_cache_size=RECORD_CACHE_SIZE;
 
-    /* from soundex.c */
-                /* ABCDEFGHIJKLMNOPQRSTUVWXYZ */
-                /* :::::::::::::::::::::::::: */
+	/* from soundex.c */
+				/* ABCDEFGHIJKLMNOPQRSTUVWXYZ */
+				/* :::::::::::::::::::::::::: */
 const char *soundex_map=	  "01230120022455012623010202";
 
-    /* from my_malloc */
+	/* from my_malloc */
 USED_MEM* my_once_root_block=0;			/* pointer to first block */
 uint	  my_once_extra=ONCE_ALLOC_INIT;	/* Memory to alloc / block */
 
-    /* from my_largepage.c */
+	/* from my_largepage.c */
 #ifdef HAVE_LARGE_PAGES
 my_bool my_use_large_pages= 0;
 uint    my_large_page_size= 0;
 #endif
 
-    /* from my_alarm */
+	/* from my_alarm */
 int volatile my_have_got_alarm=0;	/* declare variable to reset */
 ulong my_time_to_wait_for_lock=2;	/* In seconds */
 
-    /* from errors.c */
+	/* from errors.c */
 #ifdef SHARED_LIBRARY
 const char *globerrs[GLOBERRS];		/* my_error_messages is here */
 #endif
@@ -100,7 +100,7 @@ static const char *proc_info_dummy(void *a __attribute__((unused)),
 ulonglong query_performance_frequency, query_performance_offset;
 #endif
 
-    /* How to disable options */
+	/* How to disable options */
 my_bool my_disable_locking=0;
 my_bool my_disable_async_io=0;
 my_bool my_disable_flush_key_blocks=0;
@@ -131,4 +131,5 @@ static const char *proc_info_dummy(void *a __attribute__((unused)),
   xyz_psi_server variable, obtained from PSI_bootstrap::get_interface()
   with the version used at compile time for plugin XYZ.
 */
-PSI *PSI_server= NULL;
\ No newline at end of file
+PSI *PSI_server= NULL;
+
diff --git a/dep/mysqllite/mysys/my_symlink.c b/dep/mysqllite/mysys/my_symlink.c
index 0470b07..cdb16a7 100644
--- a/dep/mysqllite/mysys/my_symlink.c
+++ b/dep/mysqllite/mysys/my_symlink.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -53,7 +53,7 @@ int my_readlink(char *to, const char *filename, myf MyFlags)
     else
     {
       if (MyFlags & MY_WME)
-    my_error(EE_CANT_READLINK, MYF(0), filename, errno);
+	my_error(EE_CANT_READLINK, MYF(0), filename, errno);
       result= -1;
     }
   }
@@ -64,6 +64,7 @@ int my_readlink(char *to, const char *filename, myf MyFlags)
 #endif /* HAVE_READLINK */
 }
 
+
 /* Create a symbolic link */
 
 int my_symlink(const char *content, const char *linkname, myf MyFlags)
@@ -97,6 +98,7 @@ int my_symlink(const char *content, const char *linkname, myf MyFlags)
 #define BUFF_LEN FN_LEN
 #endif
 
+
 int my_is_symlink(const char *filename __attribute__((unused)))
 {
 #if defined (HAVE_LSTAT) && defined (S_ISLNK)
@@ -149,11 +151,11 @@ int my_realpath(char *to, const char *filename, myf MyFlags)
     my_errno= (ret > FN_REFLEN) ? ENAMETOOLONG : GetLastError();
     if (MyFlags & MY_WME)
       my_error(EE_REALPATH, MYF(0), filename, my_errno);
-    /*
-      GetFullPathName didn't work : use my_load_path() which is a poor
-      substitute original name but will at least be able to resolve
+    /* 
+      GetFullPathName didn't work : use my_load_path() which is a poor 
+      substitute original name but will at least be able to resolve 
       paths that starts with '.'.
-    */
+    */  
     my_load_path(to, filename, NullS);
     return -1;
   }
@@ -161,4 +163,4 @@ int my_realpath(char *to, const char *filename, myf MyFlags)
   my_load_path(to, filename, NullS);
 #endif
   return 0;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_symlink2.c b/dep/mysqllite/mysys/my_symlink2.c
index 3c3bf8d..7c3ddbb 100644
--- a/dep/mysqllite/mysys/my_symlink2.c
+++ b/dep/mysqllite/mysys/my_symlink2.c
@@ -25,7 +25,7 @@
 #include <m_string.h>
 
 File my_create_with_symlink(const char *linkname, const char *filename,
-                int createflags, int access_flags, myf MyFlags)
+			    int createflags, int access_flags, myf MyFlags)
 {
   File file;
   int tmp_errno;
@@ -74,16 +74,16 @@ File my_create_with_symlink(const char *linkname, const char *filename,
     {
       /* Delete old link/file */
       if (MyFlags & MY_DELETE_OLD)
-    my_delete(linkname, MYF(0));
+	my_delete(linkname, MYF(0));
       /* Create link */
       if (my_symlink(filename, linkname, MyFlags))
       {
-    /* Fail, remove everything we have done */
-    tmp_errno=my_errno;
-    my_close(file,MYF(0));
-    my_delete(filename, MYF(0));
-    file= -1;
-    my_errno=tmp_errno;
+	/* Fail, remove everything we have done */
+	tmp_errno=my_errno;
+	my_close(file,MYF(0));
+	my_delete(filename, MYF(0));
+	file= -1;
+	my_errno=tmp_errno;
       }
     }
   }
@@ -99,7 +99,7 @@ int my_delete_with_symlink(const char *name, myf MyFlags)
 {
   char link_name[FN_REFLEN];
   int was_symlink= (!my_disable_symlinks &&
-            !my_readlink(link_name, name, MYF(0)));
+		    !my_readlink(link_name, name, MYF(0)));
   int result;
   DBUG_ENTER("my_delete_with_symlink");
 
@@ -128,7 +128,7 @@ int my_rename_with_symlink(const char *from, const char *to, myf MyFlags)
 #else
   char link_name[FN_REFLEN], tmp_name[FN_REFLEN];
   int was_symlink= (!my_disable_symlinks &&
-            !my_readlink(link_name, from, MYF(0)));
+		    !my_readlink(link_name, from, MYF(0)));
   int result=0;
   int name_is_different;
   DBUG_ENTER("my_rename_with_symlink");
@@ -180,4 +180,4 @@ int my_rename_with_symlink(const char *from, const char *to, myf MyFlags)
   }
   DBUG_RETURN(result);
 #endif /* HAVE_READLINK */
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_sync.c b/dep/mysqllite/mysys/my_sync.c
index f57835d..65775f1 100644
--- a/dep/mysqllite/mysys/my_sync.c
+++ b/dep/mysqllite/mysys/my_sync.c
@@ -106,8 +106,10 @@ int my_sync(File fd, myf my_flags)
   DBUG_RETURN(res);
 } /* my_sync */
 
+
 static const char cur_dir_name[]= {FN_CURLIB, 0};
 
+
 /*
   Force directory information to disk.
 
@@ -157,6 +159,7 @@ int my_sync_dir(const char *dir_name __attribute__((unused)),
 
 #endif /* NEED_EXPLICIT_SYNC_DIR */
 
+
 /*
   Force directory information to disk.
 
@@ -187,4 +190,5 @@ int my_sync_dir_by_file(const char *file_name __attribute__((unused)),
   return 0;
 }
 
-#endif /* NEED_EXPLICIT_SYNC_DIR */
\ No newline at end of file
+#endif /* NEED_EXPLICIT_SYNC_DIR */
+
diff --git a/dep/mysqllite/mysys/my_thr_init.c b/dep/mysqllite/mysys/my_thr_init.c
index cd22e72..d213b67 100644
--- a/dep/mysqllite/mysys/my_thr_init.c
+++ b/dep/mysqllite/mysys/my_thr_init.c
@@ -60,11 +60,13 @@
 
 #endif /* TARGET_OS_LINUX */
 
+
 static uint get_thread_lib(void);
 
 /** True if @c my_thread_global_init() has been called. */
 static my_bool my_thread_global_init_done= 0;
 
+
 /**
   Re-initialize components initialized early with @c my_thread_global_init.
   Some mutexes were initialized before the instrumentation.
@@ -225,6 +227,7 @@ my_bool my_thread_global_init(void)
   return 0;
 }
 
+
 void my_thread_global_end(void)
 {
   struct timespec abstime;
@@ -313,14 +316,14 @@ my_bool my_thread_init(void)
 #ifdef EXTRA_DEBUG_THREADS
   fprintf(stderr,"my_thread_init(): thread_id: 0x%lx\n",
           (ulong) pthread_self());
-#endif
+#endif  
 
   if (my_pthread_getspecific(struct st_my_thread_var *,THR_KEY_mysys))
   {
 #ifdef EXTRA_DEBUG_THREADS
     fprintf(stderr,"my_thread_init() called more than once in thread 0x%lx\n",
             (long) pthread_self());
-#endif
+#endif    
     goto end;
   }
 
@@ -355,6 +358,7 @@ my_bool my_thread_init(void)
   return error;
 }
 
+
 /*
   Deallocate memory used by the thread for book-keeping
 
@@ -374,8 +378,8 @@ void my_thread_end(void)
 
 #ifdef EXTRA_DEBUG_THREADS
   fprintf(stderr,"my_thread_end(): tmp: 0x%lx  pthread_self: 0x%lx  thread_id: %ld\n",
-      (long) tmp, (long) pthread_self(), tmp ? (long) tmp->id : 0L);
-#endif
+	  (long) tmp, (long) pthread_self(), tmp ? (long) tmp->id : 0L);
+#endif  
 
 #ifdef HAVE_PSI_INTERFACE
   /*
@@ -425,6 +429,7 @@ struct st_my_thread_var *_my_thread_var(void)
   return  my_pthread_getspecific(struct st_my_thread_var*,THR_KEY_mysys);
 }
 
+
 /****************************************************************************
   Get name of current thread.
 ****************************************************************************/
@@ -465,11 +470,12 @@ extern void **my_thread_var_dbug()
 }
 #endif /* DBUG_OFF */
 
+
 static uint get_thread_lib(void)
 {
 #ifdef _CS_GNU_LIBPTHREAD_VERSION
   char buff[64];
-
+    
   confstr(_CS_GNU_LIBPTHREAD_VERSION, buff, sizeof(buff));
 
   if (!strncasecmp(buff, "NPTL", 4))
@@ -485,7 +491,7 @@ static uint get_thread_lib(void)
   In Visual Studio 2005 and later, default SIGABRT handler will overwrite
   any unhandled exception filter set by the application  and will try to
   call JIT debugger. This is not what we want, this we calling __debugbreak
-  to stop in debugger, if process is being debugged or to generate
+  to stop in debugger, if process is being debugged or to generate 
   EXCEPTION_BREAKPOINT and then handle_segfault will do its magic.
 */
 
@@ -504,4 +510,5 @@ static void install_sigabrt_handler(void)
   signal(SIGABRT,my_sigabrt_handler);
 #endif /* _MSC_VER >=1400 */
 }
-#endif
\ No newline at end of file
+#endif
+
diff --git a/dep/mysqllite/mysys/my_wincond.c b/dep/mysqllite/mysys/my_wincond.c
index 438eefa..fe06bf3 100644
--- a/dep/mysqllite/mysys/my_wincond.c
+++ b/dep/mysqllite/mysys/my_wincond.c
@@ -24,18 +24,19 @@
 #include <process.h>
 #include <sys/timeb.h>
 
+
 /*
-  Windows native condition variables. We use runtime loading / function
-  pointers, because they are not available on XP
+  Windows native condition variables. We use runtime loading / function 
+  pointers, because they are not available on XP 
 */
 
 /* Prototypes and function pointers for condition variable functions */
-typedef VOID (WINAPI * InitializeConditionVariableProc)
+typedef VOID (WINAPI * InitializeConditionVariableProc) 
   (PCONDITION_VARIABLE ConditionVariable);
 
 typedef BOOL (WINAPI * SleepConditionVariableCSProc)
   (PCONDITION_VARIABLE ConditionVariable,
-  PCRITICAL_SECTION CriticalSection,
+  PCRITICAL_SECTION CriticalSection, 
   DWORD dwMilliseconds);
 
 typedef VOID (WINAPI * WakeAllConditionVariableProc)
@@ -49,6 +50,7 @@ typedef VOID (WINAPI * WakeConditionVariableProc)
 static WakeAllConditionVariableProc my_WakeAllConditionVariable;
 static WakeConditionVariableProc my_WakeConditionVariable;
 
+
 /**
  Indicates if we have native condition variables,
  initialized first time pthread_cond_init is called.
@@ -56,8 +58,9 @@ typedef VOID (WINAPI * WakeConditionVariableProc)
 
 static BOOL have_native_conditions= FALSE;
 
+
 /**
-  Check if native conditions can be used, load function pointers
+  Check if native conditions can be used, load function pointers 
 */
 
 static void check_native_cond_availability(void)
@@ -77,13 +80,15 @@ static void check_native_cond_availability(void)
     have_native_conditions= TRUE;
 }
 
+
+
 /**
   Convert abstime to milliseconds
 */
 
 static DWORD get_milliseconds(const struct timespec *abstime)
 {
-  long long millis;
+  long long millis; 
   union ft64 now;
 
   if (abstime == NULL)
@@ -97,7 +102,7 @@ static DWORD get_milliseconds(const struct timespec *abstime)
     - convert to millisec by dividing with 10000
   */
   millis= (abstime->tv.i64 - now.i64) / 10000;
-
+  
   /* Don't allow the timeout to be negative */
   if (millis < 0)
     return 0;
@@ -108,13 +113,14 @@ static DWORD get_milliseconds(const struct timespec *abstime)
   */
   if (millis > abstime->max_timeout_msec)
     millis= abstime->max_timeout_msec;
-
+  
   if (millis > UINT_MAX)
     millis= UINT_MAX;
 
   return (DWORD)millis;
 }
 
+
 /*
   Old (pre-vista) implementation using events
 */
@@ -123,7 +129,7 @@ static int legacy_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr
 {
   cond->waiting= 0;
   InitializeCriticalSection(&cond->lock_waiting);
-
+    
   cond->events[SIGNAL]= CreateEvent(NULL,  /* no security */
                                     FALSE, /* auto-reset event */
                                     FALSE, /* non-signaled initially */
@@ -135,11 +141,12 @@ static int legacy_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr
                                        FALSE, /* non-signaled initially */
                                        NULL); /* unnamed */
 
+
   cond->broadcast_block_event= CreateEvent(NULL,  /* no security */
                                            TRUE,  /* manual-reset */
                                            TRUE,  /* signaled initially */
                                            NULL); /* unnamed */
-
+  
   if( cond->events[SIGNAL] == NULL ||
       cond->events[BROADCAST] == NULL ||
       cond->broadcast_block_event == NULL )
@@ -147,6 +154,7 @@ static int legacy_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr
   return 0;
 }
 
+
 static int legacy_cond_destroy(pthread_cond_t *cond)
 {
   DeleteCriticalSection(&cond->lock_waiting);
@@ -158,14 +166,15 @@ static int legacy_cond_destroy(pthread_cond_t *cond)
   return 0;
 }
 
+
 static int legacy_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
                            struct timespec *abstime)
 {
   int result;
-  DWORD timeout;
+  DWORD timeout; 
 
   timeout= get_milliseconds(abstime);
-  /*
+  /* 
     Block access if previous broadcast hasn't finished.
     This is just for safety and should normally not
     affect the total time spent in this function.
@@ -178,15 +187,15 @@ static int legacy_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 
   LeaveCriticalSection(mutex);
   result= WaitForMultipleObjects(2, cond->events, FALSE, timeout);
-
+  
   EnterCriticalSection(&cond->lock_waiting);
   cond->waiting--;
-
+  
   if (cond->waiting == 0)
   {
     /*
       We're the last waiter to be notified or to stop waiting, so
-      reset the manual event.
+      reset the manual event. 
     */
     /* Close broadcast gate */
     ResetEvent(cond->events[BROADCAST]);
@@ -194,7 +203,7 @@ static int legacy_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
     SetEvent(cond->broadcast_block_event);
   }
   LeaveCriticalSection(&cond->lock_waiting);
-
+  
   EnterCriticalSection(mutex);
 
   return result == WAIT_TIMEOUT ? ETIMEDOUT : 0;
@@ -203,15 +212,16 @@ static int legacy_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
 static int legacy_cond_signal(pthread_cond_t *cond)
 {
   EnterCriticalSection(&cond->lock_waiting);
-
+  
   if(cond->waiting > 0)
     SetEvent(cond->events[SIGNAL]);
 
   LeaveCriticalSection(&cond->lock_waiting);
-
+  
   return 0;
 }
 
+
 static int legacy_cond_broadcast(pthread_cond_t *cond)
 {
   EnterCriticalSection(&cond->lock_waiting);
@@ -223,24 +233,25 @@ static int legacy_cond_broadcast(pthread_cond_t *cond)
   if(cond->waiting > 0)
   {
     /* Close block gate */
-    ResetEvent(cond->broadcast_block_event);
+    ResetEvent(cond->broadcast_block_event); 
     /* Open broadcast gate */
     SetEvent(cond->events[BROADCAST]);
   }
 
-  LeaveCriticalSection(&cond->lock_waiting);
+  LeaveCriticalSection(&cond->lock_waiting);  
 
   return 0;
 }
 
-/*
+
+/* 
  Posix API functions. Just choose between native and legacy implementation.
 */
 
 int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
 {
   /*
-    Once initialization is used here rather than in my_init(), to
+    Once initialization is used here rather than in my_init(), to 
     1) avoid  my_init() pitfalls- undefined order in which initialization should
     run
     2) be potentially useful C++ (in static constructors that run before main())
@@ -255,10 +266,11 @@ int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)
     my_InitializeConditionVariable(&cond->native_cond);
     return 0;
   }
-  else
+  else 
     return legacy_cond_init(cond, attr);
 }
 
+
 int pthread_cond_destroy(pthread_cond_t *cond)
 {
   if (have_native_conditions)
@@ -267,6 +279,7 @@ int pthread_cond_destroy(pthread_cond_t *cond)
     return legacy_cond_destroy(cond);
 }
 
+
 int pthread_cond_broadcast(pthread_cond_t *cond)
 {
   if (have_native_conditions)
@@ -278,6 +291,7 @@ int pthread_cond_broadcast(pthread_cond_t *cond)
     return legacy_cond_broadcast(cond);
 }
 
+
 int pthread_cond_signal(pthread_cond_t *cond)
 {
   if (have_native_conditions)
@@ -289,6 +303,7 @@ int pthread_cond_signal(pthread_cond_t *cond)
     return legacy_cond_signal(cond);
 }
 
+
 int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
   struct timespec *abstime)
 {
@@ -297,17 +312,19 @@ int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
     DWORD timeout= get_milliseconds(abstime);
     if (!my_SleepConditionVariableCS(&cond->native_cond, mutex, timeout))
       return ETIMEDOUT;
-    return 0;
+    return 0;  
   }
   else
     return legacy_cond_timedwait(cond, mutex, abstime);
 }
 
+
 int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
 {
   return pthread_cond_timedwait(cond, mutex, NULL);
 }
 
+
 int pthread_attr_init(pthread_attr_t *connect_att)
 {
   connect_att->dwStackSize	= 0;
@@ -349,4 +366,4 @@ struct tm *localtime_r(const time_t *timep,struct tm *tmp)
   }
   return tmp;
 }
-#endif /* __WIN__ */
\ No newline at end of file
+#endif /* __WIN__ */
diff --git a/dep/mysqllite/mysys/my_windac.c b/dep/mysqllite/mysys/my_windac.c
index 0b73b6d..51fe22e 100644
--- a/dep/mysqllite/mysys/my_windac.c
+++ b/dep/mysqllite/mysys/my_windac.c
@@ -43,6 +43,7 @@ static my_bool is_nt()
   PACL dacl;
 } My_security_attr;
 
+
 /*
   Allocate and initialize SECURITY_ATTRIBUTES setting up access
   rights for the owner and group `Everybody'.
@@ -219,4 +220,4 @@ void my_security_attr_free(SECURITY_ATTRIBUTES *sa)
   }
 }
 
-#endif /* __WIN__ */
\ No newline at end of file
+#endif /* __WIN__ */
diff --git a/dep/mysqllite/mysys/my_winerr.c b/dep/mysqllite/mysys/my_winerr.c
index 817757a..15f52dd 100644
--- a/dep/mysqllite/mysys/my_winerr.c
+++ b/dep/mysqllite/mysys/my_winerr.c
@@ -23,7 +23,8 @@
 #include <my_global.h>
 #include <my_sys.h>
 
-struct errentry
+
+struct errentry 
 {
   unsigned long oscode;   /* OS return value */
   int sysv_errno;  /* System V error code */
@@ -90,14 +91,15 @@ values in the (contiguous) range of Exec Failure errors. */
 #define MIN_EACCES_RANGE ERROR_WRITE_PROTECT
 #define MAX_EACCES_RANGE ERROR_SHARING_BUFFER_EXCEEDED
 
+
 static int get_errno_from_oserr(unsigned long oserrno)
 {
   int i;
 
   /* check the table for the OS error code */
-  for (i= 0; i < ERRTABLESIZE; ++i)
+  for (i= 0; i < ERRTABLESIZE; ++i) 
   {
-    if (oserrno == errtable[i].oscode)
+    if (oserrno == errtable[i].oscode) 
     {
       return  errtable[i].sysv_errno;
     }
@@ -119,4 +121,4 @@ static int get_errno_from_oserr(unsigned long oserrno)
 void my_osmaperr ( unsigned long oserrno)
 {
     errno= get_errno_from_oserr(oserrno);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/my_winfile.c b/dep/mysqllite/mysys/my_winfile.c
index a4fa531..ad87bf7 100644
--- a/dep/mysqllite/mysys/my_winfile.c
+++ b/dep/mysqllite/mysys/my_winfile.c
@@ -14,12 +14,12 @@
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
 /*
-  The purpose of this file is to provide implementation of file IO routines on
+  The purpose of this file is to provide implementation of file IO routines on 
   Windows that can be thought as drop-in replacement for corresponding C runtime
   functionality.
 
-  Compared to Windows CRT, this one
-  - does not have the same file descriptor
+  Compared to Windows CRT, this one 
+  - does not have the same file descriptor 
   limitation (default is 16384 and can  be increased further, whereas CRT poses
   a hard limit of 2048 file descriptors)
   - the file operations are not serialized
@@ -27,7 +27,7 @@
   - no text mode for files, all IO is "binary"
 
   Naming convention:
-  All routines are prefixed with my_win_, e.g Posix open() is implemented with
+  All routines are prefixed with my_win_, e.g Posix open() is implemented with 
   my_win_open()
 
   Implemented are
@@ -36,7 +36,7 @@
   - Windows CRT equvalients (my_get_osfhandle, open_osfhandle)
 
   Worth to note:
-  - File descriptors used here are located in a range that is not compatible
+  - File descriptors used here are located in a range that is not compatible 
   with CRT on purpose. Attempt to use a file descriptor from Windows CRT library
   range in my_win_* function will be punished with DBUG_ASSERT()
 
@@ -76,6 +76,7 @@ File my_open_osfhandle(HANDLE handle, int oflag)
   DBUG_RETURN(offset);
 }
 
+
 static void invalidate_fd(File fd)
 {
   DBUG_ENTER("invalidate_fd");
@@ -84,6 +85,7 @@ static void invalidate_fd(File fd)
   DBUG_VOID_RETURN;
 }
 
+
 /* Get Windows handle for a file descriptor */
 HANDLE my_get_osfhandle(File fd)
 {
@@ -92,6 +94,7 @@ HANDLE my_get_osfhandle(File fd)
   DBUG_RETURN(my_file_info[fd].fhandle);
 }
 
+
 static int my_get_open_flags(File fd)
 {
   DBUG_ENTER("my_get_open_flags");
@@ -99,6 +102,7 @@ static int my_get_open_flags(File fd)
   DBUG_RETURN(my_file_info[fd].oflag);
 }
 
+
 /*
   Open a file with sharing. Similar to _sopen() from libc, but allows managing
   share delete on win32
@@ -217,7 +221,7 @@ File my_win_sopen(const char *path, int oflag, int shflag, int pmode)
 
   /* decode file attribute flags if _O_CREAT was specified */
   fileattrib= FILE_ATTRIBUTE_NORMAL;     /* default */
-  if (oflag & _O_CREAT)
+  if (oflag & _O_CREAT) 
   {
     _umask((mask= _umask(0)));
 
@@ -226,7 +230,7 @@ File my_win_sopen(const char *path, int oflag, int shflag, int pmode)
   }
 
   /* Set temporary file (delete-on-close) attribute if requested. */
-  if (oflag & _O_TEMPORARY)
+  if (oflag & _O_TEMPORARY) 
   {
     fileattrib|= FILE_FLAG_DELETE_ON_CLOSE;
     fileaccess|= DELETE;
@@ -243,7 +247,7 @@ File my_win_sopen(const char *path, int oflag, int shflag, int pmode)
     fileattrib|= FILE_FLAG_RANDOM_ACCESS;
 
   /* try to open/create the file  */
-  if ((osfh= CreateFile(path, fileaccess, fileshare, &SecurityAttributes,
+  if ((osfh= CreateFile(path, fileaccess, fileshare, &SecurityAttributes, 
     filecreate, fileattrib, NULL)) == INVALID_HANDLE_VALUE)
   {
     /*
@@ -255,7 +259,7 @@ File my_win_sopen(const char *path, int oflag, int shflag, int pmode)
     DBUG_RETURN(-1);                 /* return error to caller */
   }
 
-  if ((fh= my_open_osfhandle(osfh,
+  if ((fh= my_open_osfhandle(osfh, 
     oflag & (_O_APPEND | _O_RDONLY | _O_TEXT))) == -1)
   {
     CloseHandle(osfh);
@@ -264,13 +268,15 @@ File my_win_sopen(const char *path, int oflag, int shflag, int pmode)
   DBUG_RETURN(fh);                   /* return handle */
 }
 
+
 File my_win_open(const char *path, int flags)
 {
   DBUG_ENTER("my_win_open");
-  DBUG_RETURN(my_win_sopen((char *) path, flags | _O_BINARY, _SH_DENYNO,
+  DBUG_RETURN(my_win_sopen((char *) path, flags | _O_BINARY, _SH_DENYNO, 
     _S_IREAD | S_IWRITE));
 }
 
+
 int my_win_close(File fd)
 {
   DBUG_ENTER("my_win_close");
@@ -283,6 +289,7 @@ int my_win_close(File fd)
   DBUG_RETURN(-1);
 }
 
+
 size_t my_win_pread(File Filedes, uchar *Buffer, size_t Count, my_off_t offset)
 {
   DWORD         nBytesRead;
@@ -319,6 +326,7 @@ size_t my_win_pread(File Filedes, uchar *Buffer, size_t Count, my_off_t offset)
   DBUG_RETURN(nBytesRead);
 }
 
+
 size_t my_win_read(File Filedes, uchar *Buffer, size_t Count)
 {
   DWORD         nBytesRead;
@@ -349,7 +357,8 @@ size_t my_win_read(File Filedes, uchar *Buffer, size_t Count)
   DBUG_RETURN(nBytesRead);
 }
 
-size_t my_win_pwrite(File Filedes, const uchar *Buffer, size_t Count,
+
+size_t my_win_pwrite(File Filedes, const uchar *Buffer, size_t Count, 
                      my_off_t offset)
 {
   DWORD         nBytesWritten;
@@ -358,7 +367,7 @@ size_t my_win_pwrite(File Filedes, const uchar *Buffer, size_t Count,
   LARGE_INTEGER li;
 
   DBUG_ENTER("my_win_pwrite");
-  DBUG_PRINT("my",("Filedes: %d, Buffer: %p, Count: %llu, offset: %llu",
+  DBUG_PRINT("my",("Filedes: %d, Buffer: %p, Count: %llu, offset: %llu", 
     Filedes, Buffer, (ulonglong)Count, (ulonglong)offset));
 
   if(!Count)
@@ -383,6 +392,7 @@ size_t my_win_pwrite(File Filedes, const uchar *Buffer, size_t Count,
     DBUG_RETURN(nBytesWritten);
 }
 
+
 my_off_t my_win_lseek(File fd, my_off_t pos, int whence)
 {
   LARGE_INTEGER offset;
@@ -391,7 +401,7 @@ my_off_t my_win_lseek(File fd, my_off_t pos, int whence)
   DBUG_ENTER("my_win_lseek");
 
   /* Check compatibility of Windows and Posix seek constants */
-  compile_time_assert(FILE_BEGIN == SEEK_SET && FILE_CURRENT == SEEK_CUR
+  compile_time_assert(FILE_BEGIN == SEEK_SET && FILE_CURRENT == SEEK_CUR 
     && FILE_END == SEEK_END);
 
   offset.QuadPart= pos;
@@ -403,6 +413,7 @@ my_off_t my_win_lseek(File fd, my_off_t pos, int whence)
   DBUG_RETURN(newpos.QuadPart);
 }
 
+
 #ifndef FILE_WRITE_TO_END_OF_FILE
 #define FILE_WRITE_TO_END_OF_FILE       0xffffffff
 #endif
@@ -414,7 +425,7 @@ size_t my_win_write(File fd, const uchar *Buffer, size_t Count)
   HANDLE hFile;
 
   DBUG_ENTER("my_win_write");
-  DBUG_PRINT("my",("Filedes: %d, Buffer: %p, Count %llu", fd, Buffer,
+  DBUG_PRINT("my",("Filedes: %d, Buffer: %p, Count %llu", fd, Buffer, 
       (ulonglong)Count));
 
   if(!Count)
@@ -428,11 +439,11 @@ size_t my_win_write(File fd, const uchar *Buffer, size_t Count)
   if(my_get_open_flags(fd) & _O_APPEND)
   {
     /*
-       Atomic append to the end of file is is done by special initialization of
+       Atomic append to the end of file is is done by special initialization of 
        the OVERLAPPED structure. See MSDN WriteFile documentation for more info.
     */
     memset(&ov, 0, sizeof(ov));
-    ov.Offset= FILE_WRITE_TO_END_OF_FILE;
+    ov.Offset= FILE_WRITE_TO_END_OF_FILE; 
     ov.OffsetHigh= -1;
     pov= &ov;
   }
@@ -446,6 +457,7 @@ size_t my_win_write(File fd, const uchar *Buffer, size_t Count)
   DBUG_RETURN(nWritten);
 }
 
+
 int my_win_chsize(File fd,  my_off_t newlength)
 {
   HANDLE hFile;
@@ -465,6 +477,7 @@ int my_win_chsize(File fd,  my_off_t newlength)
   DBUG_RETURN(-1);
 }
 
+
 /* Get the file descriptor for stdin,stdout or stderr */
 static File my_get_stdfile_descriptor(FILE *stream)
 {
@@ -487,6 +500,7 @@ static File my_get_stdfile_descriptor(FILE *stream)
   DBUG_RETURN(-1);
 }
 
+
 File my_win_fileno(FILE *file)
 {
   HANDLE hFile= (HANDLE)_get_osfhandle(fileno(file));
@@ -509,15 +523,16 @@ File my_win_fileno(FILE *file)
   DBUG_RETURN(retval);
 }
 
+
 FILE *my_win_fopen(const char *filename, const char *type)
 {
   FILE *file;
   int flags= 0;
   DBUG_ENTER("my_win_open");
 
-  /*
-    If we are not creating, then we need to use my_access to make sure
-    the file exists since Windows doesn't handle files like "com1.sym"
+  /* 
+    If we are not creating, then we need to use my_access to make sure  
+    the file exists since Windows doesn't handle files like "com1.sym" 
     very  well
   */
   if (check_if_legal_filename(filename))
@@ -545,6 +560,7 @@ FILE *my_win_fopen(const char *filename, const char *type)
   DBUG_RETURN(file);
 }
 
+
 FILE * my_win_fdopen(File fd, const char *type)
 {
   FILE *file;
@@ -564,6 +580,7 @@ FILE * my_win_fdopen(File fd, const char *type)
   DBUG_RETURN(file);
 }
 
+
 int my_win_fclose(FILE *file)
 {
   File fd;
@@ -578,10 +595,12 @@ int my_win_fclose(FILE *file)
   DBUG_RETURN(0);
 }
 
+
+
 /*
   Quick and dirty my_fstat() implementation for Windows.
   Use CRT fstat on temporarily allocated file descriptor.
-  Patch file size, because size that fstat returns is not
+  Patch file size, because size that fstat returns is not 
   reliable (may be outdated)
 */
 int my_win_fstat(File fd, struct _stati64 *buf)
@@ -593,7 +612,7 @@ int my_win_fstat(File fd, struct _stati64 *buf)
   DBUG_ENTER("my_win_fstat");
 
   hFile= my_get_osfhandle(fd);
-  if(!DuplicateHandle( GetCurrentProcess(), hFile, GetCurrentProcess(),
+  if(!DuplicateHandle( GetCurrentProcess(), hFile, GetCurrentProcess(), 
     &hDup ,0,FALSE,DUPLICATE_SAME_ACCESS))
   {
     my_osmaperr(GetLastError());
@@ -612,6 +631,8 @@ int my_win_fstat(File fd, struct _stati64 *buf)
   DBUG_RETURN(retval);
 }
 
+
+
 int my_win_stat( const char *path, struct _stati64 *buf)
 {
   DBUG_ENTER("my_win_stat");
@@ -631,6 +652,8 @@ int my_win_stat( const char *path, struct _stati64 *buf)
   DBUG_RETURN(-1);
 }
 
+
+
 int my_win_fsync(File fd)
 {
   DBUG_ENTER("my_win_fsync");
@@ -640,6 +663,8 @@ int my_win_fsync(File fd)
   DBUG_RETURN(-1);
 }
 
+
+
 int my_win_dup(File fd)
 {
   HANDLE hDup;
@@ -653,4 +678,4 @@ int my_win_dup(File fd)
   DBUG_RETURN(-1);
 }
 
-#endif /*_WIN32*/
\ No newline at end of file
+#endif /*_WIN32*/
diff --git a/dep/mysqllite/mysys/my_winthread.c b/dep/mysqllite/mysys/my_winthread.c
index 4eb51aa..ac30cf1 100644
--- a/dep/mysqllite/mysys/my_winthread.c
+++ b/dep/mysqllite/mysys/my_winthread.c
@@ -62,6 +62,7 @@ static unsigned int __stdcall pthread_start(void *p)
   return 0;
 }
 
+
 int pthread_create(pthread_t *thread_id, const pthread_attr_t *attr,
                    pthread_handler func, void *param)
 {
@@ -93,6 +94,7 @@ int pthread_create(pthread_t *thread_id, const pthread_attr_t *attr,
   DBUG_RETURN(-1);
 }
 
+
 void pthread_exit(void *a)
 {
   _endthreadex(0);
@@ -129,6 +131,7 @@ int pthread_join(pthread_t thread, void **value_ptr)
 
 int pthread_cancel(pthread_t thread)
 {
+
   HANDLE handle= 0;
   BOOL ok= FALSE;
 
@@ -149,14 +152,14 @@ int pthread_cancel(pthread_t thread)
  One time initialization. For simplicity, we assume initializer thread
  does not exit within init_routine().
 */
-int my_pthread_once(my_pthread_once_t *once_control,
+int my_pthread_once(my_pthread_once_t *once_control, 
     void (*init_routine)(void))
 {
   LONG state;
 
   /*
     Do "dirty" read to find out if initialization is already done, to
-    save an interlocked operation in common case. Memory barriers are ensured by
+    save an interlocked operation in common case. Memory barriers are ensured by 
     Visual C++ volatile implementation.
   */
   if (*once_control == MY_PTHREAD_ONCE_DONE)
@@ -186,4 +189,4 @@ int my_pthread_once(my_pthread_once_t *once_control,
   }
   return 0;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/my_write.c b/dep/mysqllite/mysys/my_write.c
index 370b574..4b1ccb6 100644
--- a/dep/mysqllite/mysys/my_write.c
+++ b/dep/mysqllite/mysys/my_write.c
@@ -17,7 +17,8 @@
 #include "mysys_err.h"
 #include <errno.h>
 
-    /* Write a chunk of bytes to a file */
+
+	/* Write a chunk of bytes to a file */
 
 size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
 {
@@ -25,13 +26,13 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
   uint errors;
   DBUG_ENTER("my_write");
   DBUG_PRINT("my",("fd: %d  Buffer: %p  Count: %lu  MyFlags: %d",
-           Filedes, Buffer, (ulong) Count, MyFlags));
+		   Filedes, Buffer, (ulong) Count, MyFlags));
   errors= 0; written= 0;
 
   /* The behavior of write(fd, buf, 0) is not portable */
   if (unlikely(!Count))
     DBUG_RETURN(0);
-
+  
   for (;;)
   {
 #ifdef _WIN32
@@ -39,6 +40,11 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
 #else
     writtenbytes= write(Filedes, Buffer, Count);
 #endif
+    DBUG_EXECUTE_IF("simulate_file_write_error",
+                    {
+                      errno= ENOSPC;
+                      writtenbytes= (size_t) -1;
+                    });
     if (writtenbytes == Count)
       break;
     if (writtenbytes != (size_t) -1)
@@ -49,7 +55,7 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
     }
     my_errno= errno;
     DBUG_PRINT("error",("Write only %ld bytes, error: %d",
-            (long) writtenbytes, my_errno));
+			(long) writtenbytes, my_errno));
 #ifndef NO_BACKGROUND
     if (my_thread_var->abort)
       MyFlags&= ~ MY_WAIT_IF_FULL;		/* End if aborted by user */
@@ -85,8 +91,8 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
     {
       if (MyFlags & (MY_WME | MY_FAE | MY_FNABP))
       {
-    my_error(EE_WRITE, MYF(ME_BELL+ME_WAITTANG),
-         my_filename(Filedes),my_errno);
+	my_error(EE_WRITE, MYF(ME_BELL+ME_WAITTANG),
+		 my_filename(Filedes),my_errno);
       }
       DBUG_RETURN(MY_FILE_ERROR);		/* Error on read */
     }
@@ -96,4 +102,4 @@ size_t my_write(File Filedes, const uchar *Buffer, size_t Count, myf MyFlags)
   if (MyFlags & (MY_NABP | MY_FNABP))
     DBUG_RETURN(0);			/* Want only errors */
   DBUG_RETURN(writtenbytes+written);
-} /* my_write */
\ No newline at end of file
+} /* my_write */
diff --git a/dep/mysqllite/mysys/ptr_cmp.c b/dep/mysqllite/mysys/ptr_cmp.c
index c9ec43b..6f9ab13 100644
--- a/dep/mysqllite/mysys/ptr_cmp.c
+++ b/dep/mysqllite/mysys/ptr_cmp.c
@@ -48,7 +48,7 @@ static int native_compare(size_t *length, unsigned char **a, unsigned char **b)
 static int ptr_compare_3(size_t *compare_length, uchar **a, uchar **b);
 #endif	/* __sun */
 
-    /* Get a pointer to a optimal byte-compare function for a given size */
+	/* Get a pointer to a optimal byte-compare function for a given size */
 
 #ifdef __sun
 qsort2_cmp get_ptr_compare (size_t size __attribute__((unused)))
@@ -70,10 +70,11 @@ qsort2_cmp get_ptr_compare (size_t size)
 }
 #endif /* __sun */
 
-    /*
-      Compare to keys to see witch is smaller.
-      Loop unrolled to make it quick !!
-    */
+
+	/*
+	  Compare to keys to see witch is smaller.
+	  Loop unrolled to make it quick !!
+	*/
 
 #define cmp(N) if (first[N] != last[N]) return (int) first[N] - (int) last[N]
 
@@ -93,6 +94,7 @@ static int ptr_compare(size_t *compare_length, uchar **a, uchar **b)
   return (int) first[0] - (int) last[0];
 }
 
+
 static int ptr_compare_0(size_t *compare_length,uchar **a, uchar **b)
 {
   reg3 int length= *compare_length;
@@ -113,6 +115,7 @@ static int ptr_compare_0(size_t *compare_length,uchar **a, uchar **b)
   return (0);
 }
 
+
 static int ptr_compare_1(size_t *compare_length,uchar **a, uchar **b)
 {
   reg3 int length= *compare_length-1;
@@ -216,4 +219,5 @@ my_off_t my_get_ptr(uchar *ptr, size_t pack_length)
   default: DBUG_ASSERT(0); return 0;
   }
  return pos;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/mysys/queues.c b/dep/mysqllite/mysys/queues.c
index 32d0bb0..801c5a6 100644
--- a/dep/mysqllite/mysys/queues.c
+++ b/dep/mysqllite/mysys/queues.c
@@ -26,6 +26,7 @@
 #include "mysys_err.h"
 #include <queues.h>
 
+
 /*
   Init queue
 
@@ -34,7 +35,7 @@
     queue		Queue to initialise
     max_elements	Max elements that will be put in queue
     offset_to_key	Offset to key in element stored in queue
-            Used when sending pointers to compare function
+			Used when sending pointers to compare function
     max_at_top		Set to 1 if you want biggest element on top.
     compare		Compare function for elements, takes 3 arguments.
     first_cmp_arg	First argument to compare function
@@ -48,12 +49,12 @@
 */
 
 int init_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
-           pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
-           void *first_cmp_arg)
+	       pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
+	       void *first_cmp_arg)
 {
   DBUG_ENTER("init_queue");
   if ((queue->root= (uchar **) my_malloc((max_elements+1)*sizeof(void*),
-                     MYF(MY_WME))) == 0)
+					 MYF(MY_WME))) == 0)
     DBUG_RETURN(1);
   queue->elements=0;
   queue->compare=compare;
@@ -64,6 +65,8 @@ int init_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
   DBUG_RETURN(0);
 }
 
+
+
 /*
   Init queue, uses init_queue internally for init work but also accepts
   auto_extent as parameter
@@ -73,7 +76,7 @@ int init_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
     queue		Queue to initialise
     max_elements	Max elements that will be put in queue
     offset_to_key	Offset to key in element stored in queue
-            Used when sending pointers to compare function
+			Used when sending pointers to compare function
     max_at_top		Set to 1 if you want biggest element on top.
     compare		Compare function for elements, takes 3 arguments.
     first_cmp_arg	First argument to compare function
@@ -89,8 +92,8 @@ int init_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
 */
 
 int init_queue_ex(QUEUE *queue, uint max_elements, uint offset_to_key,
-           pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
-           void *first_cmp_arg, uint auto_extent)
+	       pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
+	       void *first_cmp_arg, uint auto_extent)
 {
   int ret;
   DBUG_ENTER("init_queue_ex");
@@ -98,7 +101,7 @@ int init_queue_ex(QUEUE *queue, uint max_elements, uint offset_to_key,
   if ((ret= init_queue(queue, max_elements, offset_to_key, max_at_top, compare,
                        first_cmp_arg)))
     DBUG_RETURN(ret);
-
+  
   queue->auto_extent= auto_extent;
   DBUG_RETURN(0);
 }
@@ -111,7 +114,7 @@ int init_queue_ex(QUEUE *queue, uint max_elements, uint offset_to_key,
     queue		Queue to initialise
     max_elements	Max elements that will be put in queue
     offset_to_key	Offset to key in element stored in queue
-            Used when sending pointers to compare function
+			Used when sending pointers to compare function
     max_at_top		Set to 1 if you want biggest element on top.
     compare		Compare function for elements, takes 3 arguments.
     first_cmp_arg	First argument to compare function
@@ -126,8 +129,8 @@ int init_queue_ex(QUEUE *queue, uint max_elements, uint offset_to_key,
 */
 
 int reinit_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
-         pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
-         void *first_cmp_arg)
+		 pbool max_at_top, int (*compare) (void *, uchar *, uchar *),
+		 void *first_cmp_arg)
 {
   DBUG_ENTER("reinit_queue");
   queue->elements=0;
@@ -139,6 +142,7 @@ int reinit_queue(QUEUE *queue, uint max_elements, uint offset_to_key,
   DBUG_RETURN(0);
 }
 
+
 /*
   Resize queue
 
@@ -163,8 +167,8 @@ int resize_queue(QUEUE *queue, uint max_elements)
   if (queue->max_elements == max_elements)
     DBUG_RETURN(0);
   if ((new_root= (uchar **) my_realloc((void *)queue->root,
-                      (max_elements+1)*sizeof(void*),
-                      MYF(MY_WME))) == 0)
+				      (max_elements+1)*sizeof(void*),
+				      MYF(MY_WME))) == 0)
     DBUG_RETURN(1);
   set_if_smaller(queue->elements, max_elements);
   queue->max_elements= max_elements;
@@ -172,6 +176,7 @@ int resize_queue(QUEUE *queue, uint max_elements)
   DBUG_RETURN(0);
 }
 
+
 /*
   Delete queue
 
@@ -194,7 +199,8 @@ void delete_queue(QUEUE *queue)
   DBUG_VOID_RETURN;
 }
 
-    /* Code for insert, search and delete of elements */
+
+	/* Code for insert, search and delete of elements */
 
 void queue_insert(register QUEUE *queue, uchar *element)
 {
@@ -220,11 +226,12 @@ void queue_insert(register QUEUE *queue, uchar *element)
     0 - OK
     1 - Cannot allocate more memory
     2 - auto_extend is 0, the operation would
-
+  
 */
 
 int queue_insert_safe(register QUEUE *queue, uchar *element)
 {
+
   if (queue->elements == queue->max_elements)
   {
     if (!queue->auto_extent)
@@ -232,13 +239,14 @@ int queue_insert_safe(register QUEUE *queue, uchar *element)
     else if (resize_queue(queue, queue->max_elements + queue->auto_extent))
       return 1;
   }
-
+  
   queue_insert(queue, element);
   return 0;
 }
 
-    /* Remove item from queue */
-    /* Returns pointer to removed element */
+
+	/* Remove item from queue */
+	/* Returns pointer to removed element */
 
 uchar *queue_remove(register QUEUE *queue, uint idx)
 {
@@ -250,7 +258,7 @@ uchar *queue_remove(register QUEUE *queue, uint idx)
   return element;
 }
 
-    /* Fix when element on top has been replaced */
+	/* Fix when element on top has been replaced */
 
 #ifndef queue_replaced
 void queue_replaced(QUEUE *queue)
@@ -276,12 +284,12 @@ void _downheap(register QUEUE *queue, uint idx)
   {
     next_index=idx+idx;
     if (next_index < elements &&
-    (queue->compare(queue->first_cmp_arg,
-            queue->root[next_index]+offset_to_key,
-            queue->root[next_index+1]+offset_to_key) *
-     queue->max_at_top) > 0)
+	(queue->compare(queue->first_cmp_arg,
+			queue->root[next_index]+offset_to_key,
+			queue->root[next_index+1]+offset_to_key) *
+	 queue->max_at_top) > 0)
       next_index++;
-    if (first &&
+    if (first && 
         (((queue->compare(queue->first_cmp_arg,
                           queue->root[next_index]+offset_to_key,
                           element+offset_to_key) * queue->max_at_top) >= 0)))
@@ -314,7 +322,7 @@ void _downheap(register QUEUE *queue, uint idx)
     The old _downheap version is kept for comparisons with the benchmark
     suit or new benchmarks anyone wants to run for comparisons.
   */
-    /* Fix heap when index have changed */
+	/* Fix heap when index have changed */
 void _downheap(register QUEUE *queue, uint idx)
 {
   uchar *element;
@@ -328,10 +336,10 @@ void _downheap(register QUEUE *queue, uint idx)
   {
     next_index=idx+idx;
     if (next_index < elements &&
-    (queue->compare(queue->first_cmp_arg,
-            queue->root[next_index]+offset_to_key,
-            queue->root[next_index+1]+offset_to_key) *
-     queue->max_at_top) > 0)
+	(queue->compare(queue->first_cmp_arg,
+			queue->root[next_index]+offset_to_key,
+			queue->root[next_index+1]+offset_to_key) *
+	 queue->max_at_top) > 0)
       next_index++;
     if ((queue->compare(queue->first_cmp_arg,
                         queue->root[next_index]+offset_to_key,
@@ -343,6 +351,7 @@ void _downheap(register QUEUE *queue, uint idx)
   queue->root[idx]=element;
 }
 
+
 #endif
 
 /*
@@ -495,6 +504,7 @@ bool check_num(uint num_part)
   return TRUE;
 }
 
+
 void perform_insert(QUEUE *queue)
 {
   uint i= 1, no_parts= tot_no_parts;
@@ -502,7 +512,7 @@ void perform_insert(QUEUE *queue)
 
   expected_part= 1;
   expected_num= 1;
-
+ 
   if (max_ind)
     backward_start= 1 << 21;
 
@@ -674,4 +684,4 @@ int main()
   printf("OK\n");
   return 0;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/rijndael.c b/dep/mysqllite/mysys/rijndael.c
index bba7444..e893a88 100644
--- a/dep/mysqllite/mysys/rijndael.c
+++ b/dep/mysqllite/mysys/rijndael.c
@@ -13,6 +13,7 @@
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
+
 /*
   Based on version 3.0 (December 2000)
 
@@ -712,6 +713,7 @@
   0x55555555U, 0x21212121U, 0x0c0c0c0cU, 0x7d7d7d7dU,
 };
 
+
 /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */
 static const uint32 rcon[]=
 {
@@ -729,12 +731,13 @@
 #else
 
 #define GETuint32(pt) (((uint32)(pt)[0] << 24) ^ ((uint32)(pt)[1] << 16)\
-    ^ ((uint32)(pt)[2] <<  8) ^ ((uint32)(pt)[3]))
+	^ ((uint32)(pt)[2] <<  8) ^ ((uint32)(pt)[3]))
 #define PUTuint32(ct, st) { (ct)[0] = (uint8)((st) >> 24); (ct)[1]\
 = (uint8)((st) >> 16); (ct)[2] = (uint8)((st) >>  8); (ct)[3] = (uint8)(st); }
 
 #endif /* defined(_MSC_VER) && defined(__i386__) */
 
+
 /*
   Expand the cipher key into the encryption key schedule.
 
@@ -743,7 +746,7 @@
 */
 
 int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
-            int keyBits)
+			int keyBits)
 {
   int i = 0;
   uint32 temp;
@@ -758,16 +761,16 @@ int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
     {
       temp  = rk[3];
       rk[4] = (rk[0] ^
-           (Te4[(temp >> 16) & 0xff] & 0xff000000) ^
-           (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
-           (Te4[(temp      ) & 0xff] & 0x0000ff00) ^
-           (Te4[(temp >> 24)       ] & 0x000000ff) ^
-           rcon[i]);
+	       (Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+	       (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+	       (Te4[(temp      ) & 0xff] & 0x0000ff00) ^
+	       (Te4[(temp >> 24)       ] & 0x000000ff) ^
+	       rcon[i]);
       rk[5] = rk[1] ^ rk[4];
       rk[6] = rk[2] ^ rk[5];
       rk[7] = rk[3] ^ rk[6];
       if (++i == 10)
-    return 10;
+	return 10;
       rk += 4;
     }
   }
@@ -779,17 +782,17 @@ int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
     {
       temp = rk[ 5];
       rk[ 6] = (rk[ 0] ^
-        (Te4[(temp >> 16) & 0xff] & 0xff000000) ^
-        (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
-        (Te4[(temp	) & 0xff] & 0x0000ff00) ^
-        (Te4[(temp >> 24)	] & 0x000000ff) ^
-        rcon[i]);
+		(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+		(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+		(Te4[(temp	) & 0xff] & 0x0000ff00) ^
+		(Te4[(temp >> 24)	] & 0x000000ff) ^
+		rcon[i]);
       rk[ 7] = rk[ 1] ^ rk[ 6];
       rk[ 8] = rk[ 2] ^ rk[ 7];
       rk[ 9] = rk[ 3] ^ rk[ 8];
       if (++i == 8)
       {
-    return 12;
+	return 12;
       }
       rk[10] = rk[ 4] ^ rk[ 9];
       rk[11] = rk[ 5] ^ rk[10];
@@ -804,24 +807,24 @@ int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
     {
       temp = rk[ 7];
       rk[ 8] = (rk[ 0] ^
-        (Te4[(temp >> 16) & 0xff] & 0xff000000) ^
-        (Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
-        (Te4[(temp	) & 0xff] & 0x0000ff00) ^
-        (Te4[(temp >> 24)	] & 0x000000ff) ^
-        rcon[i]);
+		(Te4[(temp >> 16) & 0xff] & 0xff000000) ^
+		(Te4[(temp >>  8) & 0xff] & 0x00ff0000) ^
+		(Te4[(temp	) & 0xff] & 0x0000ff00) ^
+		(Te4[(temp >> 24)	] & 0x000000ff) ^
+		rcon[i]);
       rk[ 9] = rk[ 1] ^ rk[ 8];
       rk[10] = rk[ 2] ^ rk[ 9];
       rk[11] = rk[ 3] ^ rk[10];
       if (++i == 7)
       {
-    return 14;
+	return 14;
       }
       temp = rk[11];
       rk[12] = (rk[ 4] ^
-        (Te4[(temp >> 24)	] & 0xff000000) ^
-        (Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
-        (Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
-        (Te4[(temp	) & 0xff] & 0x000000ff));
+		(Te4[(temp >> 24)	] & 0xff000000) ^
+		(Te4[(temp >> 16) & 0xff] & 0x00ff0000) ^
+		(Te4[(temp >>  8) & 0xff] & 0x0000ff00) ^
+		(Te4[(temp	) & 0xff] & 0x000000ff));
       rk[13] = rk[ 5] ^ rk[12];
       rk[14] = rk[ 6] ^ rk[13];
       rk[15] = rk[ 7] ^ rk[14];
@@ -831,6 +834,7 @@ int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
   return 0;
 }
 
+
 /*
   Expand the cipher key into the decryption key schedule.
 
@@ -839,7 +843,7 @@ int rijndaelKeySetupEnc(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
 */
 
 int rijndaelKeySetupDec(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
-            int keyBits)
+			int keyBits)
 {
   int nr, i, j;
   uint32 temp;
@@ -863,31 +867,32 @@ int rijndaelKeySetupDec(uint32 rk[/*4*(Nr + 1)*/], const uint8 cipherKey[],
     rk += 4;
 
     rk[0]= (
-        Td0[Te4[(rk[0] >> 24)	  ] & 0xff] ^
-        Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
-        Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
-        Td3[Te4[(rk[0]	  ) & 0xff] & 0xff]);
+	    Td0[Te4[(rk[0] >> 24)	  ] & 0xff] ^
+	    Td1[Te4[(rk[0] >> 16) & 0xff] & 0xff] ^
+	    Td2[Te4[(rk[0] >>  8) & 0xff] & 0xff] ^
+	    Td3[Te4[(rk[0]	  ) & 0xff] & 0xff]);
 
     rk[1]= (Td0[Te4[(rk[1] >> 24)	  ] & 0xff] ^
-        Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
-        Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
-        Td3[Te4[(rk[1]	  ) & 0xff] & 0xff]);
+	    Td1[Te4[(rk[1] >> 16) & 0xff] & 0xff] ^
+	    Td2[Te4[(rk[1] >>  8) & 0xff] & 0xff] ^
+	    Td3[Te4[(rk[1]	  ) & 0xff] & 0xff]);
 
     rk[2]= (Td0[Te4[(rk[2] >> 24)	  ] & 0xff] ^
-        Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
-        Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
-        Td3[Te4[(rk[2]	  ) & 0xff] & 0xff]);
+	    Td1[Te4[(rk[2] >> 16) & 0xff] & 0xff] ^
+	    Td2[Te4[(rk[2] >>  8) & 0xff] & 0xff] ^
+	    Td3[Te4[(rk[2]	  ) & 0xff] & 0xff]);
 
     rk[3]= (Td0[Te4[(rk[3] >> 24)	  ] & 0xff] ^
-        Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
-        Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
-        Td3[Te4[(rk[3]	  ) & 0xff] & 0xff]);
+	    Td1[Te4[(rk[3] >> 16) & 0xff] & 0xff] ^
+	    Td2[Te4[(rk[3] >>  8) & 0xff] & 0xff] ^
+	    Td3[Te4[(rk[3]	  ) & 0xff] & 0xff]);
   }
   return nr;
 }
 
+
 void rijndaelEncrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
-             const uint8 pt[16], uint8 ct[16])
+		     const uint8 pt[16], uint8 ct[16])
 {
   uint32 s0, s1, s2, s3, t0, t1, t2, t3;
 #ifndef FULL_UNROLL
@@ -995,45 +1000,45 @@ void rijndaelEncrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
   {
     /* round 10: */
     s0= (Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>  8) & 0xff]
-     ^ Te3[t3 & 0xff] ^ rk[40]);
+	 ^ Te3[t3 & 0xff] ^ rk[40]);
     s1= (Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>  8) & 0xff]
-     ^ Te3[t0 & 0xff] ^ rk[41]);
+	 ^ Te3[t0 & 0xff] ^ rk[41]);
     s2= (Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>  8) & 0xff]
-     ^ Te3[t1 & 0xff] ^ rk[42]);
+	 ^ Te3[t1 & 0xff] ^ rk[42]);
     s3= (Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>  8) & 0xff]
-     ^ Te3[t2 & 0xff] ^ rk[43]);
+	 ^ Te3[t2 & 0xff] ^ rk[43]);
 
     /* round 11: */
     t0= (Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>  8) & 0xff]
-     ^ Te3[s3 & 0xff] ^ rk[44]);
+	 ^ Te3[s3 & 0xff] ^ rk[44]);
     t1= (Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>  8) & 0xff]
-     ^ Te3[s0 & 0xff] ^ rk[45]);
+	 ^ Te3[s0 & 0xff] ^ rk[45]);
     t2= (Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>  8) & 0xff]
-     ^ Te3[s1 & 0xff] ^ rk[46]);
+	 ^ Te3[s1 & 0xff] ^ rk[46]);
     t3= (Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>  8) & 0xff]
-     ^ Te3[s2 & 0xff] ^ rk[47]);
+	 ^ Te3[s2 & 0xff] ^ rk[47]);
 
     if (Nr > 12)
     {
       /* round 12: */
       s0= (Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >>	8) & 0xff]
-       ^ Te3[t3 & 0xff] ^ rk[48]);
+	   ^ Te3[t3 & 0xff] ^ rk[48]);
       s1= (Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >>	8) & 0xff]
-       ^ Te3[t0 & 0xff] ^ rk[49]);
+	   ^ Te3[t0 & 0xff] ^ rk[49]);
       s2= (Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >>	8) & 0xff]
-       ^ Te3[t1 & 0xff] ^ rk[50]);
+	   ^ Te3[t1 & 0xff] ^ rk[50]);
       s3= (Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >>	8) & 0xff]
-       ^ Te3[t2 & 0xff] ^ rk[51]);
+	   ^ Te3[t2 & 0xff] ^ rk[51]);
 
       /* round 13: */
       t0= (Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >>	8) & 0xff]
-       ^ Te3[s3 & 0xff] ^ rk[52]);
+	   ^ Te3[s3 & 0xff] ^ rk[52]);
       t1= (Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >>	8) & 0xff]
-       ^ Te3[s0 & 0xff] ^ rk[53]);
+	   ^ Te3[s0 & 0xff] ^ rk[53]);
       t2= (Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >>	8) & 0xff]
-       ^ Te3[s1 & 0xff] ^ rk[54]);
+	   ^ Te3[s1 & 0xff] ^ rk[54]);
       t3= (Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >>	8) & 0xff]
-       ^ Te3[s2 & 0xff] ^ rk[55]);
+	   ^ Te3[s2 & 0xff] ^ rk[55]);
     }
   }
   rk += Nr << 2;
@@ -1045,56 +1050,56 @@ void rijndaelEncrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
   for (;;)
   {
     t0= (Te0[(s0 >> 24)  ] ^
-     Te1[(s1 >> 16) & 0xff] ^
-     Te2[(s2 >>	8) & 0xff] ^
-     Te3[(s3	 ) & 0xff] ^
-     rk[4]);
+	 Te1[(s1 >> 16) & 0xff] ^
+	 Te2[(s2 >>	8) & 0xff] ^
+	 Te3[(s3	 ) & 0xff] ^
+	 rk[4]);
 
     t1= (Te0[(s1 >> 24)  ] ^
-     Te1[(s2 >> 16) & 0xff] ^
-     Te2[(s3 >>	8) & 0xff] ^
-     Te3[(s0	 ) & 0xff] ^
-     rk[5]);
+	 Te1[(s2 >> 16) & 0xff] ^
+	 Te2[(s3 >>	8) & 0xff] ^
+	 Te3[(s0	 ) & 0xff] ^
+	 rk[5]);
 
     t2= (Te0[(s2 >> 24)  ] ^
-     Te1[(s3 >> 16) & 0xff] ^
-     Te2[(s0 >>	8) & 0xff] ^
-     Te3[(s1	 ) & 0xff] ^
-     rk[6]);
+	 Te1[(s3 >> 16) & 0xff] ^
+	 Te2[(s0 >>	8) & 0xff] ^
+	 Te3[(s1	 ) & 0xff] ^
+	 rk[6]);
 
     t3= (Te0[(s3 >> 24)  ] ^
-     Te1[(s0 >> 16) & 0xff] ^
-     Te2[(s1 >>	8) & 0xff] ^
-     Te3[(s2	 ) & 0xff] ^
-     rk[7]);
+	 Te1[(s0 >> 16) & 0xff] ^
+	 Te2[(s1 >>	8) & 0xff] ^
+	 Te3[(s2	 ) & 0xff] ^
+	 rk[7]);
 
     rk+= 8;
     if (--r == 0)
       break;
 
     s0= (Te0[(t0 >> 24)  ] ^
-     Te1[(t1 >> 16) & 0xff] ^
-     Te2[(t2 >>	8) & 0xff] ^
-     Te3[(t3	 ) & 0xff] ^
-     rk[0]);
+	 Te1[(t1 >> 16) & 0xff] ^
+	 Te2[(t2 >>	8) & 0xff] ^
+	 Te3[(t3	 ) & 0xff] ^
+	 rk[0]);
 
     s1= (Te0[(t1 >> 24)  ] ^
-     Te1[(t2 >> 16) & 0xff] ^
-     Te2[(t3 >>	8) & 0xff] ^
-     Te3[(t0	 ) & 0xff] ^
-     rk[1]);
+	 Te1[(t2 >> 16) & 0xff] ^
+	 Te2[(t3 >>	8) & 0xff] ^
+	 Te3[(t0	 ) & 0xff] ^
+	 rk[1]);
 
     s2= (Te0[(t2 >> 24)  ] ^
-     Te1[(t3 >> 16) & 0xff] ^
-     Te2[(t0 >>	8) & 0xff] ^
-     Te3[(t1	 ) & 0xff] ^
-     rk[2]);
+	 Te1[(t3 >> 16) & 0xff] ^
+	 Te2[(t0 >>	8) & 0xff] ^
+	 Te3[(t1	 ) & 0xff] ^
+	 rk[2]);
 
     s3= (Te0[(t3 >> 24)  ] ^
-     Te1[(t0 >> 16) & 0xff] ^
-     Te2[(t1 >>	8) & 0xff] ^
-     Te3[(t2	 ) & 0xff] ^
-     rk[3]);
+	 Te1[(t0 >> 16) & 0xff] ^
+	 Te2[(t1 >>	8) & 0xff] ^
+	 Te3[(t2	 ) & 0xff] ^
+	 rk[3]);
   }
 #endif /* FULL_UNROLL */
 
@@ -1128,8 +1133,9 @@ void rijndaelEncrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
   PUTuint32(ct + 12, s3);
 }
 
+
 void rijndaelDecrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
-             const uint8 ct[16], uint8 pt[16])
+		     const uint8 ct[16], uint8 pt[16])
 {
   uint32 s0, s1, s2, s3, t0, t1, t2, t3;
 #ifndef FULL_UNROLL
@@ -1238,45 +1244,45 @@ void rijndaelDecrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
   {
     /* round 10: */
     s0= (Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>  8) & 0xff]
-     ^ Td3[t1 & 0xff] ^ rk[40]);
+	 ^ Td3[t1 & 0xff] ^ rk[40]);
     s1= (Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>  8) & 0xff]
-     ^ Td3[t2 & 0xff] ^ rk[41]);
+	 ^ Td3[t2 & 0xff] ^ rk[41]);
     s2= (Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>  8) & 0xff]
-     ^ Td3[t3 & 0xff] ^ rk[42]);
+	 ^ Td3[t3 & 0xff] ^ rk[42]);
     s3= (Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>  8) & 0xff]
-     ^ Td3[t0 & 0xff] ^ rk[43]);
+	 ^ Td3[t0 & 0xff] ^ rk[43]);
 
     /* round 11: */
     t0= (Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>  8) & 0xff]
-     ^ Td3[s1 & 0xff] ^ rk[44]);
+	 ^ Td3[s1 & 0xff] ^ rk[44]);
     t1= (Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>  8) & 0xff]
-     ^ Td3[s2 & 0xff] ^ rk[45]);
+	 ^ Td3[s2 & 0xff] ^ rk[45]);
     t2= (Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>  8) & 0xff]
-     ^ Td3[s3 & 0xff] ^ rk[46]);
+	 ^ Td3[s3 & 0xff] ^ rk[46]);
     t3= (Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>  8) & 0xff]
-     ^ Td3[s0 & 0xff] ^ rk[47]);
+	 ^ Td3[s0 & 0xff] ^ rk[47]);
 
     if (Nr > 12)
     {
       /* round 12: */
       s0= (Td0[t0 >> 24] ^ Td1[(t3 >> 16) & 0xff] ^ Td2[(t2 >>	8) & 0xff]
-       ^ Td3[t1 & 0xff] ^ rk[48]);
+	   ^ Td3[t1 & 0xff] ^ rk[48]);
       s1= (Td0[t1 >> 24] ^ Td1[(t0 >> 16) & 0xff] ^ Td2[(t3 >>	8) & 0xff]
-       ^ Td3[t2 & 0xff] ^ rk[49]);
+	   ^ Td3[t2 & 0xff] ^ rk[49]);
       s2= (Td0[t2 >> 24] ^ Td1[(t1 >> 16) & 0xff] ^ Td2[(t0 >>	8) & 0xff]
-       ^ Td3[t3 & 0xff] ^ rk[50]);
+	   ^ Td3[t3 & 0xff] ^ rk[50]);
       s3= (Td0[t3 >> 24] ^ Td1[(t2 >> 16) & 0xff] ^ Td2[(t1 >>	8) & 0xff]
-       ^ Td3[t0 & 0xff] ^ rk[51]);
+	   ^ Td3[t0 & 0xff] ^ rk[51]);
 
       /* round 13: */
       t0= (Td0[s0 >> 24] ^ Td1[(s3 >> 16) & 0xff] ^ Td2[(s2 >>	8) & 0xff]
-       ^ Td3[s1 & 0xff] ^ rk[52]);
+	   ^ Td3[s1 & 0xff] ^ rk[52]);
       t1= (Td0[s1 >> 24] ^ Td1[(s0 >> 16) & 0xff] ^ Td2[(s3 >>	8) & 0xff]
-       ^ Td3[s2 & 0xff] ^ rk[53]);
+	   ^ Td3[s2 & 0xff] ^ rk[53]);
       t2= (Td0[s2 >> 24] ^ Td1[(s1 >> 16) & 0xff] ^ Td2[(s0 >>	8) & 0xff]
-       ^ Td3[s3 & 0xff] ^ rk[54]);
+	   ^ Td3[s3 & 0xff] ^ rk[54]);
       t3= (Td0[s3 >> 24] ^ Td1[(s2 >> 16) & 0xff] ^ Td2[(s1 >>	8) & 0xff]
-       ^ Td3[s0 & 0xff] ^ rk[55]);
+	   ^ Td3[s0 & 0xff] ^ rk[55]);
     }
   }
   rk += Nr << 2;
@@ -1287,56 +1293,56 @@ void rijndaelDecrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
   for (;;)
   {
     t0= (Td0[(s0 >> 24)  ] ^
-     Td1[(s3 >> 16) & 0xff] ^
-     Td2[(s2 >>	8) & 0xff] ^
-     Td3[(s1	 ) & 0xff] ^
-     rk[4]);
+	 Td1[(s3 >> 16) & 0xff] ^
+	 Td2[(s2 >>	8) & 0xff] ^
+	 Td3[(s1	 ) & 0xff] ^
+	 rk[4]);
 
     t1= (Td0[(s1 >> 24)  ] ^
-     Td1[(s0 >> 16) & 0xff] ^
-     Td2[(s3 >>	8) & 0xff] ^
-     Td3[(s2	 ) & 0xff] ^
-     rk[5]);
+	 Td1[(s0 >> 16) & 0xff] ^
+	 Td2[(s3 >>	8) & 0xff] ^
+	 Td3[(s2	 ) & 0xff] ^
+	 rk[5]);
 
     t2= (Td0[(s2 >> 24)  ] ^
-     Td1[(s1 >> 16) & 0xff] ^
-     Td2[(s0 >>	8) & 0xff] ^
-     Td3[(s3	 ) & 0xff] ^
-     rk[6]);
+	 Td1[(s1 >> 16) & 0xff] ^
+	 Td2[(s0 >>	8) & 0xff] ^
+	 Td3[(s3	 ) & 0xff] ^
+	 rk[6]);
 
     t3= (Td0[(s3 >> 24)  ] ^
-     Td1[(s2 >> 16) & 0xff] ^
-     Td2[(s1 >>	8) & 0xff] ^
-     Td3[(s0	 ) & 0xff] ^
-     rk[7]);
+	 Td1[(s2 >> 16) & 0xff] ^
+	 Td2[(s1 >>	8) & 0xff] ^
+	 Td3[(s0	 ) & 0xff] ^
+	 rk[7]);
 
     rk+= 8;
     if (--r == 0)
       break;
 
     s0= (Td0[(t0 >> 24)  ] ^
-     Td1[(t3 >> 16) & 0xff] ^
-     Td2[(t2 >>	8) & 0xff] ^
-     Td3[(t1	 ) & 0xff] ^
-     rk[0]);
+	 Td1[(t3 >> 16) & 0xff] ^
+	 Td2[(t2 >>	8) & 0xff] ^
+	 Td3[(t1	 ) & 0xff] ^
+	 rk[0]);
 
     s1= (Td0[(t1 >> 24)  ] ^
-     Td1[(t0 >> 16) & 0xff] ^
-     Td2[(t3 >>	8) & 0xff] ^
-     Td3[(t2	 ) & 0xff] ^
-     rk[1]);
+	 Td1[(t0 >> 16) & 0xff] ^
+	 Td2[(t3 >>	8) & 0xff] ^
+	 Td3[(t2	 ) & 0xff] ^
+	 rk[1]);
 
     s2= (Td0[(t2 >> 24)  ] ^
-     Td1[(t1 >> 16) & 0xff] ^
-     Td2[(t0 >>	8) & 0xff] ^
-     Td3[(t3	 ) & 0xff] ^
-     rk[2]);
+	 Td1[(t1 >> 16) & 0xff] ^
+	 Td2[(t0 >>	8) & 0xff] ^
+	 Td3[(t3	 ) & 0xff] ^
+	 rk[2]);
 
     s3= (Td0[(t3 >> 24)  ] ^
-     Td1[(t2 >> 16) & 0xff] ^
-     Td2[(t1 >>	8) & 0xff] ^
-     Td3[(t0	 ) & 0xff] ^
-     rk[3]);
+	 Td1[(t2 >> 16) & 0xff] ^
+	 Td2[(t1 >>	8) & 0xff] ^
+	 Td3[(t0	 ) & 0xff] ^
+	 rk[3]);
   }
 
 #endif /* FULL_UNROLL */
@@ -1370,4 +1376,4 @@ void rijndaelDecrypt(const uint32 rk[/*4*(Nr + 1)*/], int Nr,
        (Td4[(t0 ) & 0xff] & 0x000000ff) ^
        rk[3]);
   PUTuint32(pt + 12, s3);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/sha1.c b/dep/mysqllite/mysys/sha1.c
index 9881b67..e5b33a9 100644
--- a/dep/mysqllite/mysys/sha1.c
+++ b/dep/mysqllite/mysys/sha1.c
@@ -43,9 +43,9 @@
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
 
-  Acknowledgement
-  Funding for the RFC Editor function is currently provided by the
-  Internet Society.
+  Acknowledgement 
+  Funding for the RFC Editor function is currently provided by the 
+  Internet Society. 
 
  DESCRIPTION
   This file implements the Secure Hashing Algorithm 1 as
@@ -88,12 +88,13 @@
 */
 
 #define SHA1CircularShift(bits,word) \
-        (((word) << (bits)) | ((word) >> (32-(bits))))
+		(((word) << (bits)) | ((word) >> (32-(bits))))
 
 /* Local Function Prototyptes */
 static void SHA1PadMessage(SHA1_CONTEXT*);
 static void SHA1ProcessMessageBlock(SHA1_CONTEXT*);
 
+
 /*
   Initialize SHA1Context
 
@@ -110,6 +111,7 @@
    != SHA_SUCCESS	sha Error Code.
 */
 
+
 const uint32 sha_const_key[5]=
 {
   0x67452301,
@@ -119,6 +121,7 @@
   0xC3D2E1F0
 };
 
+
 int mysql_sha1_reset(SHA1_CONTEXT *context)
 {
 #ifndef DBUG_OFF
@@ -141,6 +144,7 @@ int mysql_sha1_reset(SHA1_CONTEXT *context)
   return SHA_SUCCESS;
 }
 
+
 /*
    Return the 160-bit message digest into the array provided by the caller
 
@@ -151,7 +155,7 @@ int mysql_sha1_reset(SHA1_CONTEXT *context)
 
   DESCRIPTION
     NOTE: The first octet of hash is stored in the 0th element,
-      the last octet of hash in the 19th element.
+	  the last octet of hash in the 19th element.
 
  RETURN
    SHA_SUCCESS		ok
@@ -182,10 +186,11 @@ int mysql_sha1_result(SHA1_CONTEXT *context,
 
   for (i = 0; i < SHA1_HASH_SIZE; i++)
     Message_Digest[i] = (int8)((context->Intermediate_Hash[i>>2] >> 8
-             * ( 3 - ( i & 0x03 ) )));
+			 * ( 3 - ( i & 0x03 ) )));
   return SHA_SUCCESS;
 }
 
+
 /*
   Accepts an array of octets as the next portion of the message.
 
@@ -193,7 +198,7 @@ int mysql_sha1_result(SHA1_CONTEXT *context,
    mysql_sha1_input()
    context [in/out]	The SHA context to update
    message_array	An array of characters representing the next portion
-            of the message.
+			of the message.
   length		The length of the message in message_array
 
  RETURN
@@ -241,6 +246,7 @@ int mysql_sha1_input(SHA1_CONTEXT *context, const uint8 *message_array,
   return SHA_SUCCESS;
 }
 
+
 /*
   Process the next 512 bits of the message stored in the Message_Block array.
 
@@ -262,6 +268,7 @@ int mysql_sha1_input(SHA1_CONTEXT *context, const uint8 *message_array,
   0xCA62C1D6
 };
 
+
 static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context)
 {
   int		t;		   /* Loop counter		  */
@@ -283,6 +290,7 @@ static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context)
     W[t] |= context->Message_Block[idx + 3];
   }
 
+
   for (t = 16; t < 80; t++)
   {
     W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
@@ -317,7 +325,7 @@ static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context)
   for (t = 40; t < 60; t++)
   {
     temp= (SHA1CircularShift(5,A) + ((B & C) | (B & D) | (C & D)) + E + W[t] +
-       K[2]);
+	   K[2]);
     E = D;
     D = C;
     C = SHA1CircularShift(30,B);
@@ -344,6 +352,7 @@ static void SHA1ProcessMessageBlock(SHA1_CONTEXT *context)
   context->Message_Block_Index = 0;
 }
 
+
 /*
   Pad message
 
@@ -378,21 +387,21 @@ static void SHA1PadMessage(SHA1_CONTEXT *context)
   {
     context->Message_Block[i++] = 0x80;
     bzero((char*) &context->Message_Block[i],
-      sizeof(context->Message_Block[0])*(64-i));
+	  sizeof(context->Message_Block[0])*(64-i));
     context->Message_Block_Index=64;
 
     /* This function sets context->Message_Block_Index to zero	*/
     SHA1ProcessMessageBlock(context);
 
     bzero((char*) &context->Message_Block[0],
-      sizeof(context->Message_Block[0])*56);
+	  sizeof(context->Message_Block[0])*56);
     context->Message_Block_Index=56;
   }
   else
   {
     context->Message_Block[i++] = 0x80;
     bzero((char*) &context->Message_Block[i],
-      sizeof(context->Message_Block[0])*(56-i));
+	  sizeof(context->Message_Block[0])*(56-i));
     context->Message_Block_Index=56;
   }
 
@@ -410,4 +419,4 @@ static void SHA1PadMessage(SHA1_CONTEXT *context)
   context->Message_Block[63] = (int8) (context->Length);
 
   SHA1ProcessMessageBlock(context);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/stacktrace.c b/dep/mysqllite/mysys/stacktrace.c
index db17d38..a3ccc31 100644
--- a/dep/mysqllite/mysys/stacktrace.c
+++ b/dep/mysqllite/mysys/stacktrace.c
@@ -52,10 +52,11 @@ void my_init_stacktrace()
 
 static void print_buffer(char *buffer, size_t count)
 {
+  const char s[]= " ";
   for (; count && *buffer; --count)
   {
-    int c= (int) *buffer++;
-    fputc(isprint(c) ? c : ' ', stderr);
+    my_write_stderr(isprint(*buffer) ? buffer : s, 1);
+    ++buffer;
   }
 }
 
@@ -119,10 +120,10 @@ static int safe_print_str(const char *addr, int max_len)
 
   /* Output a new line if something was printed. */
   if (total != (size_t) max_len)
-    fputc('\n', stderr);
+    my_safe_printf_stderr("%s", "\n");
 
   if (nbytes == -1)
-    fprintf(stderr, "Can't read from address %p: %m.\n", addr);
+    my_safe_printf_stderr("Can't read from address %p\n", addr);
 
   close(fd);
 
@@ -144,13 +145,13 @@ void my_safe_print_str(const char* val, int max_len)
 
   if (!PTR_SANE(val))
   {
-    fprintf(stderr, "is an invalid pointer\n");
+    my_safe_printf_stderr("%s", "is an invalid pointer\n");
     return;
   }
 
   for (; max_len && PTR_SANE(val) && *val; --max_len)
-    fputc(*val++, stderr);
-  fputc('\n', stderr);
+    my_write_stderr((val++), 1);
+  my_safe_printf_stderr("%s", "\n");
 }
 
 #if defined(HAVE_PRINTSTACK)
@@ -158,18 +159,19 @@ void my_safe_print_str(const char* val, int max_len)
 /* Use Solaris' symbolic stack trace routine. */
 #include <ucontext.h>
 
-void my_print_stacktrace(uchar* stack_bottom __attribute__((unused)),
+void my_print_stacktrace(uchar* stack_bottom __attribute__((unused)), 
                          ulong thread_stack __attribute__((unused)))
 {
   if (printstack(fileno(stderr)) == -1)
-    fprintf(stderr, "Error when traversing the stack, stack appears corrupt.\n");
+    my_safe_printf_stderr("%s",
+      "Error when traversing the stack, stack appears corrupt.\n");
   else
-    fprintf(stderr,
-            "Please read "
-            "http://dev.mysql.com/doc/refman/5.1/en/resolve-stack-dump.html\n"
-            "and follow instructions on how to resolve the stack trace.\n"
-            "Resolved stack trace is much more helpful in diagnosing the\n"
-            "problem, so please do resolve it\n");
+    my_safe_printf_stderr("%s",
+      "Please read "
+      "http://dev.mysql.com/doc/refman/5.1/en/resolve-stack-dump.html\n"
+      "and follow instructions on how to resolve the stack trace.\n"
+      "Resolved stack trace is much more helpful in diagnosing the\n"
+      "problem, so please do resolve it\n");
 }
 
 #elif HAVE_BACKTRACE && (HAVE_BACKTRACE_SYMBOLS || HAVE_BACKTRACE_SYMBOLS_FD)
@@ -207,9 +209,9 @@ static void my_demangle_symbols(char **addrs, int n)
     }
 
     if (demangled)
-      fprintf(stderr, "%s(%s+%s\n", addrs[i], demangled, end);
+      my_safe_printf_stderr("%s(%s+%s\n", addrs[i], demangled, end);
     else
-      fprintf(stderr, "%s\n", addrs[i]);
+      my_safe_printf_stderr("%s\n", addrs[i]);
   }
 }
 
@@ -220,8 +222,8 @@ void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)
   void *addrs[128];
   char **strings= NULL;
   int n = backtrace(addrs, array_elements(addrs));
-  fprintf(stderr, "stack_bottom = %p thread_stack 0x%lx\n",
-          stack_bottom, thread_stack);
+  my_safe_printf_stderr("stack_bottom = %p thread_stack 0x%lx\n",
+                        stack_bottom, thread_stack);
 #if BACKTRACE_DEMANGLE
   if ((strings= backtrace_symbols(addrs, n)))
   {
@@ -296,25 +298,27 @@ void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)
 #endif
   LINT_INIT(fp);
 
+
 #ifdef __i386__
   __asm __volatile__ ("movl %%ebp,%0"
-              :"=r"(fp)
-              :"r"(fp));
+		      :"=r"(fp)
+		      :"r"(fp));
 #endif
 #ifdef __x86_64__
   __asm __volatile__ ("movq %%rbp,%0"
-              :"=r"(fp)
-              :"r"(fp));
+		      :"=r"(fp)
+		      :"r"(fp));
 #endif
-#if defined(__alpha__) && defined(__GNUC__)
+#if defined(__alpha__) && defined(__GNUC__) 
   __asm __volatile__ ("mov $30,%0"
-              :"=r"(fp)
-              :"r"(fp));
+		      :"=r"(fp)
+		      :"r"(fp));
 #endif
   if (!fp)
   {
-    fprintf(stderr, "frame pointer is NULL, did you compile with\n\
--fomit-frame-pointer? Aborting backtrace!\n");
+    my_safe_printf_stderr("%s",
+      "frame pointer is NULL, did you compile with\n"
+      "-fomit-frame-pointer? Aborting backtrace!\n");
     return;
   }
 
@@ -322,28 +326,32 @@ void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)
   {
     ulong tmp= min(0x10000,thread_stack);
     /* Assume that the stack starts at the previous even 65K */
-    stack_bottom= (uchar*) (((ulong) &fp + tmp) &
-              ~(ulong) 0xFFFF);
-    fprintf(stderr, "Cannot determine thread, fp=%p, backtrace may not be correct.\n", fp);
+    stack_bottom= (uchar*) (((ulong) &fp + tmp) & ~(ulong) 0xFFFF);
+    my_safe_printf_stderr("Cannot determine thread, fp=%p, "
+                          "backtrace may not be correct.\n", fp);
   }
   if (fp > (uchar**) stack_bottom ||
       fp < (uchar**) stack_bottom - thread_stack)
   {
-    fprintf(stderr, "Bogus stack limit or frame pointer,\
- fp=%p, stack_bottom=%p, thread_stack=%ld, aborting backtrace.\n",
-        fp, stack_bottom, thread_stack);
+    my_safe_printf_stderr("Bogus stack limit or frame pointer, "
+                          "fp=%p, stack_bottom=%p, thread_stack=%ld, "
+                          "aborting backtrace.\n",
+                          fp, stack_bottom, thread_stack);
     return;
   }
 
-  fprintf(stderr, "Stack range sanity check OK, backtrace follows:\n");
+  my_safe_printf_stderr("%s",
+    "Stack range sanity check OK, backtrace follows:\n");
 #if defined(__alpha__) && defined(__GNUC__)
-  fprintf(stderr, "Warning: Alpha stacks are difficult -\
- will be taking some wild guesses, stack trace may be incorrect or \
- terminate abruptly\n");
+  my_safe_printf_stderr("%s",
+    "Warning: Alpha stacks are difficult -"
+    "will be taking some wild guesses, stack trace may be incorrect or "
+    "terminate abruptly\n");
+
   /* On Alpha, we need to get pc */
   __asm __volatile__ ("bsr %0, do_next; do_next: "
-              :"=r"(pc)
-              :"r"(pc));
+		      :"=r"(pc)
+		      :"r"(pc));
 #endif  /* __alpha__ */
 
   /* We are 1 frame above signal frame with NPTL and 2 frames above with LT */
@@ -353,8 +361,9 @@ void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)
   {
 #if defined(__i386__) || defined(__x86_64__)
     uchar** new_fp = (uchar**)*fp;
-    fprintf(stderr, "%p\n", frame_count == sigreturn_frame_count ?
-        *(fp + SIGRETURN_FRAME_OFFSET) : *(fp + 1));
+    my_safe_printf_stderr("%p\n",
+                          frame_count == sigreturn_frame_count ?
+                          *(fp + SIGRETURN_FRAME_OFFSET) : *(fp + 1));
 #endif /* defined(__386__)  || defined(__x86_64__) */
 
 #if defined(__alpha__) && defined(__GNUC__)
@@ -368,38 +377,40 @@ void my_print_stacktrace(uchar* stack_bottom, ulong thread_stack)
     {
       pc = find_prev_pc(pc, fp);
       if (pc)
-    fprintf(stderr, "%p\n", pc);
+	my_safe_printf_stderr("%p\n", pc);
       else
       {
-    fprintf(stderr, "Not smart enough to deal with the rest\
- of this stack\n");
-    goto end;
+        my_safe_printf_stderr("%s",
+          "Not smart enough to deal with the rest of this stack\n");
+	goto end;
       }
     }
     else
     {
-      fprintf(stderr, "Not smart enough to deal with the rest of this stack\n");
+      my_safe_printf_stderr("%s",
+        "Not smart enough to deal with the rest of this stack\n");
       goto end;
     }
 #endif /* defined(__alpha__) && defined(__GNUC__) */
     if (new_fp <= fp )
     {
-      fprintf(stderr, "New value of fp=%p failed sanity check,\
- terminating stack trace!\n", new_fp);
+      my_safe_printf_stderr("New value of fp=%p failed sanity check, "
+                            "terminating stack trace!\n", new_fp);
       goto end;
     }
     fp = new_fp;
     ++frame_count;
   }
-
-  fprintf(stderr, "Stack trace seems successful - bottom reached\n");
+  my_safe_printf_stderr("%s",
+                        "Stack trace seems successful - bottom reached\n");
 
 end:
-  fprintf(stderr,
-          "Please read http://dev.mysql.com/doc/refman/5.1/en/resolve-stack-dump.html\n"
-          "and follow instructions on how to resolve the stack trace.\n"
-          "Resolved stack trace is much more helpful in diagnosing the\n"
-          "problem, so please do resolve it\n");
+  my_safe_printf_stderr("%s",
+    "Please read "
+    "http://dev.mysql.com/doc/refman/5.1/en/resolve-stack-dump.html\n"
+    "and follow instructions on how to resolve the stack trace.\n"
+    "Resolved stack trace is much more helpful in diagnosing the\n"
+    "problem, so please do resolve it\n");
 }
 #endif /* TARGET_OS_LINUX */
 #endif /* HAVE_STACKTRACE */
@@ -443,6 +454,7 @@ void my_init_stacktrace()
 {
 }
 
+
 void my_set_exception_pointers(EXCEPTION_POINTERS *ep)
 {
   exception_ptrs = ep;
@@ -451,7 +463,7 @@ void my_set_exception_pointers(EXCEPTION_POINTERS *ep)
 /*
   Appends directory to symbol path.
 */
-static void add_to_symbol_path(char *path, size_t path_buffer_size,
+static void add_to_symbol_path(char *path, size_t path_buffer_size, 
   char *dir, size_t dir_buffer_size)
 {
   strcat_s(dir, dir_buffer_size, ";");
@@ -468,8 +480,8 @@ static void add_to_symbol_path(char *path, size_t path_buffer_size,
   variable _NT_SYMBOL_PATH is set, it's value appended to the symbol search path
 */
 static void get_symbol_path(char *path, size_t size)
-{
-  HANDLE hSnap;
+{ 
+  HANDLE hSnap; 
   char *envvar;
   char *p;
 #ifndef DBUG_OFF
@@ -479,14 +491,14 @@ static void get_symbol_path(char *path, size_t size)
   path[0]= '\0';
 
 #ifndef DBUG_OFF
-  /*
-    Add "debug" subdirectory of the application directory, sometimes PDB will
+  /* 
+    Add "debug" subdirectory of the application directory, sometimes PDB will 
     placed here by installation.
   */
   GetModuleFileName(NULL, pdb_debug_dir, MAX_PATH);
   p= strrchr(pdb_debug_dir, '\\');
   if(p)
-  {
+  { 
     *p= 0;
     strcat_s(pdb_debug_dir, sizeof(pdb_debug_dir), "\\debug;");
     add_to_symbol_path(path, size, pdb_debug_dir, sizeof(pdb_debug_dir));
@@ -525,6 +537,7 @@ static void get_symbol_path(char *path, size_t size)
     CloseHandle(hSnap);
   }
 
+  
   /* Add _NT_SYMBOL_PATH, if present. */
   envvar= getenv("_NT_SYMBOL_PATH");
   if(envvar)
@@ -583,7 +596,7 @@ void my_print_stacktrace(uchar* unused1, ulong unused2)
   package.sym.SizeOfStruct= sizeof(package.sym);
   package.sym.MaxNameLength= sizeof(package.name);
 
-  /*Walk the stack, output useful information*/
+  /*Walk the stack, output useful information*/ 
   for(i= 0; i< STACKWALK_MAX_FRAMES;i++)
   {
     DWORD64 function_offset= 0;
@@ -615,7 +628,7 @@ void my_print_stacktrace(uchar* unused1, ulong unused2)
       &(package.sym));
     have_source= SymGetLineFromAddr64(hProcess, addr, &line_offset, &line);
 
-    fprintf(stderr, "%p    ", addr);
+    my_safe_printf_stderr("%p    ", addr);
     if(have_module)
     {
       char *base_image_name= strrchr(module.ImageName, '\\');
@@ -623,12 +636,13 @@ void my_print_stacktrace(uchar* unused1, ulong unused2)
         base_image_name++;
       else
         base_image_name= module.ImageName;
-      fprintf(stderr, "%s!", base_image_name);
+      my_safe_printf_stderr("%s!", base_image_name);
     }
     if(have_symbol)
-      fprintf(stderr, "%s()", package.sym.Name);
+      my_safe_printf_stderr("%s()", package.sym.Name);
+
     else if(have_module)
-      fprintf(stderr, "???");
+      my_safe_printf_stderr("%s", "???");
 
     if(have_source)
     {
@@ -637,13 +651,14 @@ void my_print_stacktrace(uchar* unused1, ulong unused2)
         base_file_name++;
       else
         base_file_name= line.FileName;
-      fprintf(stderr,"[%s:%u]", base_file_name, line.LineNumber);
+      my_safe_printf_stderr("[%s:%u]",
+                            base_file_name, line.LineNumber);
     }
-    fprintf(stderr, "\n");
+    my_safe_printf_stderr("%s", "\n");
   }
-  fflush(stderr);
 }
 
+
 /*
   Write dump. The dump is created in current directory,
   file name is constructed from executable name plus
@@ -677,33 +692,235 @@ void my_write_core(int unused)
     if(MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),
       hFile, MiniDumpNormal, &info, 0, 0))
     {
-      fprintf(stderr, "Minidump written to %s\n",
-        _fullpath(path, dump_fname, sizeof(path)) ? path : dump_fname);
+      my_safe_printf_stderr("Minidump written to %s\n",
+                            _fullpath(path, dump_fname, sizeof(path)) ?
+                            path : dump_fname);
     }
     else
     {
-      fprintf(stderr,"MiniDumpWriteDump() failed, last error %u\n",
-        GetLastError());
+      my_safe_printf_stderr("MiniDumpWriteDump() failed, last error %u\n",
+                            (uint) GetLastError());
     }
     CloseHandle(hFile);
   }
   else
   {
-    fprintf(stderr, "CreateFile(%s) failed, last error %u\n", dump_fname,
-      GetLastError());
+    my_safe_printf_stderr("CreateFile(%s) failed, last error %u\n",
+                          dump_fname, (uint) GetLastError());
   }
-  fflush(stderr);
 }
 
+
 void my_safe_print_str(const char *val, int len)
 {
   __try
   {
-    fprintf(stderr, "%.*s\n", len, val);
+    my_write_stderr(val, len);
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
-    fprintf(stderr, "is an invalid string pointer\n");
+    my_safe_printf_stderr("%s", "is an invalid string pointer\n");
   }
 }
-#endif /*__WIN__*/
\ No newline at end of file
+#endif /*__WIN__*/
+
+
+#ifdef __WIN__
+size_t my_write_stderr(const void *buf, size_t count)
+{
+  DWORD bytes_written;
+  SetFilePointer(GetStdHandle(STD_ERROR_HANDLE), 0, NULL, FILE_END);
+  WriteFile(GetStdHandle(STD_ERROR_HANDLE), buf, count, &bytes_written, NULL);
+  return bytes_written;
+}
+#else
+size_t my_write_stderr(const void *buf, size_t count)
+{
+  return (size_t) write(STDERR_FILENO, buf, count);
+}
+#endif
+
+
+static const char digits[]= "0123456789abcdef";
+
+char *my_safe_utoa(int base, ulonglong val, char *buf)
+{
+  *buf--= 0;
+  do {
+    *buf--= digits[val % base];
+  } while ((val /= base) != 0);
+  return buf + 1;
+}
+
+
+char *my_safe_itoa(int base, longlong val, char *buf)
+{
+  char *orig_buf= buf;
+  const my_bool is_neg= (val < 0);
+  *buf--= 0;
+
+  if (is_neg)
+    val= -val;
+  if (is_neg && base == 16)
+  {
+    int ix;
+    val-= 1;
+    for (ix= 0; ix < 16; ++ix)
+      buf[-ix]= '0';
+  }
+  
+  do {
+    *buf--= digits[val % base];
+  } while ((val /= base) != 0);
+
+  if (is_neg && base == 10)
+    *buf--= '-';
+
+  if (is_neg && base == 16)
+  {
+    int ix;
+    buf= orig_buf - 1;
+    for (ix= 0; ix < 16; ++ix, --buf)
+    {
+      switch (*buf)
+      {
+      case '0': *buf= 'f'; break;
+      case '1': *buf= 'e'; break;
+      case '2': *buf= 'd'; break;
+      case '3': *buf= 'c'; break;
+      case '4': *buf= 'b'; break;
+      case '5': *buf= 'a'; break;
+      case '6': *buf= '9'; break;
+      case '7': *buf= '8'; break;
+      case '8': *buf= '7'; break;
+      case '9': *buf= '6'; break;
+      case 'a': *buf= '5'; break;
+      case 'b': *buf= '4'; break;
+      case 'c': *buf= '3'; break;
+      case 'd': *buf= '2'; break;
+      case 'e': *buf= '1'; break;
+      case 'f': *buf= '0'; break;
+      }
+    }
+  }
+  return buf+1;
+}
+
+
+static const char *check_longlong(const char *fmt, my_bool *have_longlong)
+{
+  *have_longlong= FALSE;
+  if (*fmt == 'l')
+  {
+    fmt++;
+    if (*fmt != 'l')
+      *have_longlong= (sizeof(long) == sizeof(longlong));
+    else
+    {
+      fmt++;
+      *have_longlong= TRUE;
+    }
+  }
+  return fmt;
+}
+
+static size_t my_safe_vsnprintf(char *to, size_t size,
+                                const char* format, va_list ap)
+{
+  char *start= to;
+  char *end= start + size - 1;
+  for (; *format; ++format)
+  {
+    my_bool have_longlong = FALSE;
+    if (*format != '%')
+    {
+      if (to == end)                            /* end of buffer */
+        break;
+      *to++= *format;                           /* copy ordinary char */
+      continue;
+    }
+    ++format;                                   /* skip '%' */
+
+    format= check_longlong(format, &have_longlong);
+
+    switch (*format)
+    {
+    case 'd':
+    case 'i':
+    case 'u':
+    case 'x':
+    case 'p':
+      {
+        longlong ival= 0;
+        ulonglong uval = 0;
+        if (*format == 'p')
+          have_longlong= (sizeof(void *) == sizeof(longlong));
+        if (have_longlong)
+        {
+          if (*format == 'u')
+            uval= va_arg(ap, ulonglong);
+          else
+            ival= va_arg(ap, longlong);
+        }
+        else
+        {
+          if (*format == 'u')
+            uval= va_arg(ap, unsigned int);
+          else
+            ival= va_arg(ap, int);
+        }
+
+        {
+          char buff[22];
+          const int base= (*format == 'x' || *format == 'p') ? 16 : 10;
+          char *val_as_str= (*format == 'u') ?
+            my_safe_utoa(base, uval, &buff[sizeof(buff)-1]) :
+            my_safe_itoa(base, ival, &buff[sizeof(buff)-1]);
+
+          /* Strip off "ffffffff" if we have 'x' format without 'll' */
+          if (*format == 'x' && !have_longlong && ival < 0)
+            val_as_str+= 8;
+
+          while (*val_as_str && to < end)
+            *to++= *val_as_str++;
+          continue;
+        }
+      }
+    case 's':
+      {
+        const char *val= va_arg(ap, char*);
+        if (!val)
+          val= "(null)";
+        while (*val && to < end)
+          *to++= *val++;
+        continue;
+      }
+    }
+  }
+  *to= 0;
+  return to - start;
+}
+
+
+size_t my_safe_snprintf(char* to, size_t n, const char* fmt, ...)
+{
+  size_t result;
+  va_list args;
+  va_start(args,fmt);
+  result= my_safe_vsnprintf(to, n, fmt, args);
+  va_end(args);
+  return result;
+}
+
+
+size_t my_safe_printf_stderr(const char* fmt, ...)
+{
+  char to[512];
+  size_t result;
+  va_list args;
+  va_start(args,fmt);
+  result= my_safe_vsnprintf(to, sizeof(to), fmt, args);
+  va_end(args);
+  my_write_stderr(to, result);
+  return result;
+}
diff --git a/dep/mysqllite/mysys/string.c b/dep/mysqllite/mysys/string.c
index 842eb8b..870963a 100644
--- a/dep/mysqllite/mysys/string.c
+++ b/dep/mysqllite/mysys/string.c
@@ -23,7 +23,7 @@
 #include <m_string.h>
 
 my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,
-                size_t init_alloc, size_t alloc_increment)
+			    size_t init_alloc, size_t alloc_increment)
 {
   size_t length;
   DBUG_ENTER("init_dynamic_string");
@@ -46,6 +46,7 @@ my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,
   DBUG_RETURN(FALSE);
 }
 
+
 my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str)
 {
   uint length=0;
@@ -70,6 +71,7 @@ my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str)
   DBUG_RETURN(FALSE);
 }
 
+
 my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size)
 {
   DBUG_ENTER("dynstr_realloc");
@@ -78,20 +80,22 @@ my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size)
   if (str->length + additional_size > str->max_length)
   {
     str->max_length=((str->length + additional_size+str->alloc_increment-1)/
-             str->alloc_increment)*str->alloc_increment;
+		     str->alloc_increment)*str->alloc_increment;
     if (!(str->str=(char*) my_realloc(str->str,str->max_length,MYF(MY_WME))))
       DBUG_RETURN(TRUE);
   }
   DBUG_RETURN(FALSE);
 }
 
+
 my_bool dynstr_append(DYNAMIC_STRING *str, const char *append)
 {
   return dynstr_append_mem(str,append,(uint) strlen(append));
 }
 
+
 my_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,
-              size_t length)
+			  size_t length)
 {
   char *new_ptr;
   if (str->length+length >= str->max_length)
@@ -110,6 +114,7 @@ my_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,
   return FALSE;
 }
 
+
 my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n)
 {
   str->length-=n;
@@ -120,7 +125,7 @@ my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n)
 /*
   Concatenates any number of strings, escapes any OS quote in the result then
   surround the whole affair in another set of quotes which is finally appended
-  to specified DYNAMIC_STRING.  This function is especially useful when
+  to specified DYNAMIC_STRING.  This function is especially useful when 
   building strings to be executed with the system() function.
 
   @param str Dynamic String which will have addtional strings appended.
@@ -169,8 +174,9 @@ my_bool dynstr_append_os_quoted(DYNAMIC_STRING *str, const char *append, ...)
   return ret;
 }
 
+
 void dynstr_free(DYNAMIC_STRING *str)
 {
   my_free(str->str);
   str->str= NULL;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/mysys/thr_alarm.c b/dep/mysqllite/mysys/thr_alarm.c
index 0c51353..42dd69f 100644
--- a/dep/mysqllite/mysys/thr_alarm.c
+++ b/dep/mysqllite/mysys/thr_alarm.c
@@ -61,7 +61,7 @@
 static sig_handler thread_alarm(int sig __attribute__((unused)));
 
 static int compare_ulong(void *not_used __attribute__((unused)),
-             uchar *a_ptr,uchar* b_ptr)
+			 uchar *a_ptr,uchar* b_ptr)
 {
   ulong a=*((ulong*) a_ptr),b= *((ulong*) b_ptr);
   return (a < b) ? -1  : (a == b) ? 0 : 1;
@@ -74,7 +74,7 @@ void init_thr_alarm(uint max_alarms)
   alarm_aborted=0;
   next_alarm_expire_time= ~ (time_t) 0;
   init_queue(&alarm_queue,max_alarms+1,offsetof(ALARM,expire_time),0,
-         compare_ulong,NullS);
+	     compare_ulong,NullS);
   sigfillset(&full_signal_set);			/* Neaded to block signals */
   mysql_mutex_init(key_LOCK_alarm, &LOCK_alarm, MY_MUTEX_INIT_FAST);
   mysql_cond_init(key_COND_alarm, &COND_alarm, NULL);
@@ -116,6 +116,7 @@ void init_thr_alarm(uint max_alarms)
   DBUG_VOID_RETURN;
 }
 
+
 void resize_thr_alarm(uint max_alarms)
 {
   mysql_mutex_lock(&LOCK_alarm);
@@ -128,6 +129,7 @@ void resize_thr_alarm(uint max_alarms)
   mysql_mutex_unlock(&LOCK_alarm);
 }
 
+
 /*
   Request alarm after sec seconds.
 
@@ -234,6 +236,7 @@ my_bool thr_alarm(thr_alarm_t *alrm, uint sec, ALARM *alarm_data)
   DBUG_RETURN(0);
 }
 
+
 /*
   Remove alarm from list of alarms
 */
@@ -259,7 +262,7 @@ void thr_end_alarm(thr_alarm_t *alarmed)
     {
       queue_remove(&alarm_queue,i),MYF(0);
       if (alarm_data->malloced)
-    my_free(alarm_data);
+	my_free(alarm_data);
       found++;
 #ifdef DBUG_OFF
       break;
@@ -271,9 +274,9 @@ void thr_end_alarm(thr_alarm_t *alarmed)
   {
     if (*alarmed)
       fprintf(stderr,"Warning: Didn't find alarm 0x%lx in queue of %d alarms\n",
-          (long) *alarmed, alarm_queue.elements);
+	      (long) *alarmed, alarm_queue.elements);
     DBUG_PRINT("warning",("Didn't find alarm 0x%lx in queue\n",
-              (long) *alarmed));
+			  (long) *alarmed));
   }
   mysql_mutex_unlock(&LOCK_alarm);
 #ifndef USE_ONE_SIGNAL_HAND
@@ -331,6 +334,7 @@ sig_handler process_alarm(int sig __attribute__((unused)))
   return;
 }
 
+
 static sig_handler process_alarm_part2(int sig __attribute__((unused)))
 {
   ALARM *alarm_data;
@@ -347,22 +351,22 @@ static sig_handler process_alarm_part2(int sig __attribute__((unused)))
       uint i;
       for (i=0 ; i < alarm_queue.elements ;)
       {
-    alarm_data=(ALARM*) queue_element(&alarm_queue,i);
-    alarm_data->alarmed=1;			/* Info to thread */
-    if (pthread_equal(alarm_data->thread,alarm_thread) ||
-        pthread_kill(alarm_data->thread, thr_client_alarm))
-    {
+	alarm_data=(ALARM*) queue_element(&alarm_queue,i);
+	alarm_data->alarmed=1;			/* Info to thread */
+	if (pthread_equal(alarm_data->thread,alarm_thread) ||
+	    pthread_kill(alarm_data->thread, thr_client_alarm))
+	{
 #ifdef MAIN
-      printf("Warning: pthread_kill couldn't find thread!!!\n");
+	  printf("Warning: pthread_kill couldn't find thread!!!\n");
 #endif
-      queue_remove(&alarm_queue,i);		/* No thread. Remove alarm */
-    }
-    else
-      i++;					/* Signal next thread */
+	  queue_remove(&alarm_queue,i);		/* No thread. Remove alarm */
+	}
+	else
+	  i++;					/* Signal next thread */
       }
 #ifndef USE_ALARM_THREAD
       if (alarm_queue.elements)
-    alarm(1);				/* Signal soon again */
+	alarm(1);				/* Signal soon again */
 #endif
     }
     else
@@ -371,31 +375,31 @@ static sig_handler process_alarm_part2(int sig __attribute__((unused)))
       ulong next=now+10-(now%10);
       while ((alarm_data=(ALARM*) queue_top(&alarm_queue))->expire_time <= now)
       {
-    alarm_data->alarmed=1;			/* Info to thread */
-    DBUG_PRINT("info",("sending signal to waiting thread"));
-    if (pthread_equal(alarm_data->thread,alarm_thread) ||
-        pthread_kill(alarm_data->thread, thr_client_alarm))
-    {
+	alarm_data->alarmed=1;			/* Info to thread */
+	DBUG_PRINT("info",("sending signal to waiting thread"));
+	if (pthread_equal(alarm_data->thread,alarm_thread) ||
+	    pthread_kill(alarm_data->thread, thr_client_alarm))
+	{
 #ifdef MAIN
-      printf("Warning: pthread_kill couldn't find thread!!!\n");
-#endif
-      queue_remove(&alarm_queue,0);		/* No thread. Remove alarm */
-      if (!alarm_queue.elements)
-        break;
-    }
-    else
-    {
-      alarm_data->expire_time=next;
-      queue_replaced(&alarm_queue);
-    }
+	  printf("Warning: pthread_kill couldn't find thread!!!\n");
+#endif
+	  queue_remove(&alarm_queue,0);		/* No thread. Remove alarm */
+	  if (!alarm_queue.elements)
+	    break;
+	}
+	else
+	{
+	  alarm_data->expire_time=next;
+	  queue_replaced(&alarm_queue);
+	}
       }
 #ifndef USE_ALARM_THREAD
       if (alarm_queue.elements)
       {
 #ifdef __bsdi__
-    alarm(0);				/* Remove old alarm */
+	alarm(0);				/* Remove old alarm */
 #endif
-    alarm((uint) (alarm_data->expire_time-now));
+	alarm((uint) (alarm_data->expire_time-now));
         next_alarm_expire_time= alarm_data->expire_time;
       }
 #endif
@@ -411,15 +415,16 @@ static sig_handler process_alarm_part2(int sig __attribute__((unused)))
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Schedule all alarms now and optionally free all structures
 
   SYNPOSIS
     end_thr_alarm()
       free_structures		Set to 1 if we should free memory used for
-                the alarm queue.
-                When we call this we should KNOW that there
-                is no active alarms
+				the alarm queue.
+				When we call this we should KNOW that there
+				is no active alarms
   IMPLEMENTATION
     Set alarm_abort to -1 which will change the behavior of alarms as follows:
     - All old alarms will be rescheduled at once
@@ -437,9 +442,9 @@ void end_thr_alarm(my_bool free_structures)
     if (alarm_queue.elements || (alarm_thread_running && free_structures))
     {
       if (pthread_equal(pthread_self(),alarm_thread))
-    alarm(1);				/* Shut down everything soon */
+	alarm(1);				/* Shut down everything soon */
       else
-    reschedule_alarms();
+	reschedule_alarms();
     }
     if (free_structures)
     {
@@ -452,8 +457,8 @@ void end_thr_alarm(my_bool free_structures)
       while (alarm_thread_running)
       {
         int error= mysql_cond_timedwait(&COND_alarm, &LOCK_alarm, &abstime);
-    if (error == ETIME || error == ETIMEDOUT)
-      break;				/* Don't wait forever */
+	if (error == ETIME || error == ETIMEDOUT)
+	  break;				/* Don't wait forever */
       }
       delete_queue(&alarm_queue);
       alarm_aborted= 1;
@@ -470,6 +475,7 @@ void end_thr_alarm(my_bool free_structures)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Remove another thread from the alarm
 */
@@ -494,6 +500,7 @@ void thr_alarm_kill(my_thread_id thread_id)
   mysql_mutex_unlock(&LOCK_alarm);
 }
 
+
 void thr_alarm_info(ALARM_INFO *info)
 {
   mysql_mutex_lock(&LOCK_alarm);
@@ -515,6 +522,7 @@ void thr_alarm_info(ALARM_INFO *info)
   ARGSUSED
 */
 
+
 static sig_handler thread_alarm(int sig __attribute__((unused)))
 {
 #ifdef MAIN
@@ -525,6 +533,7 @@ static sig_handler thread_alarm(int sig __attribute__((unused)))
 #endif
 }
 
+
 #ifdef HAVE_TIMESPEC_TS_SEC
 #define tv_sec ts_sec
 #define tv_nsec ts_nsec
@@ -549,22 +558,22 @@ static void *alarm_handler(void *arg __attribute__((unused)))
     {
       ulong sleep_time,now= my_time(0);
       if (alarm_aborted)
-    sleep_time=now+1;
+	sleep_time=now+1;
       else
-    sleep_time= ((ALARM*) queue_top(&alarm_queue))->expire_time;
+	sleep_time= ((ALARM*) queue_top(&alarm_queue))->expire_time;
       if (sleep_time > now)
       {
-    abstime.tv_sec=sleep_time;
-    abstime.tv_nsec=0;
+	abstime.tv_sec=sleep_time;
+	abstime.tv_nsec=0;
         next_alarm_expire_time= sleep_time;
         if ((error= mysql_cond_timedwait(&COND_alarm, &LOCK_alarm, &abstime)) &&
-        error != ETIME && error != ETIMEDOUT)
-    {
+	    error != ETIME && error != ETIMEDOUT)
+	{
 #ifdef MAIN
-      printf("Got error: %d from ptread_cond_timedwait (errno: %d)\n",
-         error,errno);
+	  printf("Got error: %d from ptread_cond_timedwait (errno: %d)\n",
+		 error,errno);
 #endif
-    }
+	}
       }
     }
     else if (alarm_aborted == -1)
@@ -607,6 +616,7 @@ sig_handler process_alarm(int sig __attribute__((unused)))
   /* Can't do this yet */
 }
 
+
 my_bool thr_alarm(thr_alarm_t *alrm, uint sec, ALARM *alarm)
 {
   (*alrm)= &alarm->alarmed;
@@ -616,11 +626,12 @@ my_bool thr_alarm(thr_alarm_t *alrm, uint sec, ALARM *alarm)
     return 1;
   }
   if (!(alarm->alarmed.crono=SetTimer((HWND) NULL,0, sec*1000,
-                      (TIMERPROC) NULL)))
+				      (TIMERPROC) NULL)))
     return 1;
   return 0;
 }
 
+
 my_bool thr_got_alarm(thr_alarm_t *alrm_ptr)
 {
   thr_alarm_t alrm= *alrm_ptr;
@@ -637,6 +648,7 @@ my_bool thr_got_alarm(thr_alarm_t *alrm_ptr)
   return !alrm->crono || alarm_aborted;
 }
 
+
 void thr_end_alarm(thr_alarm_t *alrm_ptr)
 {
   thr_alarm_t alrm= *alrm_ptr;
@@ -720,54 +732,54 @@ static void *test_thread(void *arg)
     {
       for (retry=0 ; !thr_got_alarm(&got_alarm) && retry < 10 ; retry++)
       {
-    printf("Thread: %s  Waiting %d sec\n",my_thread_name(),wait_time);
-    select(0,(fd_set_ptr) &fd,0,0,0);
+	printf("Thread: %s  Waiting %d sec\n",my_thread_name(),wait_time);
+	select(0,(fd_set_ptr) &fd,0,0,0);
       }
       if (!thr_got_alarm(&got_alarm))
       {
-    printf("Thread: %s  didn't get an alarm. Aborting!\n",
-           my_thread_name());
-    break;
+	printf("Thread: %s  didn't get an alarm. Aborting!\n",
+	       my_thread_name());
+	break;
       }
       if (wait_time == 7)
       {						/* Simulate alarm-miss */
-    fd_set readFDs;
-    uint max_connection=fileno(stdin);
-    FD_ZERO(&readFDs);
-    FD_SET(max_connection,&readFDs);
-    retry=0;
-    for (;;)
-    {
-      printf("Thread: %s  Simulating alarm miss\n",my_thread_name());
-      fflush(stdout);
-      if (select(max_connection+1, (fd_set_ptr) &readFDs,0,0,0) < 0)
-      {
-        if (errno == EINTR)
-          break;				/* Got new interrupt */
-        printf("Got errno: %d from select.  Retrying..\n",errno);
-        if (retry++ >= 3)
-        {
-          printf("Warning:  Interrupt of select() doesn't set errno!\n");
-          break;
-        }
-      }
-      else					/* This shouldn't happen */
-      {
-        if (!FD_ISSET(max_connection,&readFDs))
-        {
-          printf("Select interrupted, but errno not set\n");
-          fflush(stdout);
-          if (retry++ >= 3)
-        break;
-          continue;
-        }
-        (void) getchar();			/* Somebody was playing */
-      }
-    }
+	fd_set readFDs;
+	uint max_connection=fileno(stdin);
+	FD_ZERO(&readFDs);
+	FD_SET(max_connection,&readFDs);
+	retry=0;
+	for (;;)
+	{
+	  printf("Thread: %s  Simulating alarm miss\n",my_thread_name());
+	  fflush(stdout);
+	  if (select(max_connection+1, (fd_set_ptr) &readFDs,0,0,0) < 0)
+	  {
+	    if (errno == EINTR)
+	      break;				/* Got new interrupt */
+	    printf("Got errno: %d from select.  Retrying..\n",errno);
+	    if (retry++ >= 3)
+	    {
+	      printf("Warning:  Interrupt of select() doesn't set errno!\n");
+	      break;
+	    }
+	  }
+	  else					/* This shouldn't happen */
+	  {
+	    if (!FD_ISSET(max_connection,&readFDs))
+	    {
+	      printf("Select interrupted, but errno not set\n");
+	      fflush(stdout);
+	      if (retry++ >= 3)
+		break;
+	      continue;
+	    }
+	    (void) getchar();			/* Somebody was playing */
+	  }
+	}
       }
     }
     printf("Thread: %s  Slept for %d (%d) sec\n",my_thread_name(),
-       (int) (my_time(0)-start_time), wait_time); fflush(stdout);
+	   (int) (my_time(0)-start_time), wait_time); fflush(stdout);
     thr_end_alarm(&got_alarm);
     fflush(stdout);
   }
@@ -792,6 +804,7 @@ static sig_handler print_signal_warning(int sig)
 }
 #endif /* USE_ONE_SIGNAL_HAND */
 
+
 static void *signal_hand(void *arg __attribute__((unused)))
 {
   sigset_t set;
@@ -829,7 +842,7 @@ static void *signal_hand(void *arg __attribute__((unused)))
     {
       fprintf(stderr,"Got error %d from sigwait\n",error);
       if (err_count++ > 5)
-    exit(1);				/* Too many errors in test */
+	exit(1);				/* Too many errors in test */
       continue;
     }
 #ifdef USE_ONE_SIGNAL_HAND
@@ -859,6 +872,7 @@ static void *signal_hand(void *arg __attribute__((unused)))
   }
 }
 
+
 int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
 {
   pthread_t tid;
@@ -925,8 +939,8 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   mysql_mutex_lock(&LOCK_thread_count);
   thr_alarm_info(&alarm_info);
   printf("Main_thread:  Alarms: %u  max_alarms: %u  next_alarm_time: %lu\n",
-     alarm_info.active_alarms, alarm_info.max_used_alarms,
-     alarm_info.next_alarm_time);
+	 alarm_info.active_alarms, alarm_info.max_used_alarms,
+	 alarm_info.next_alarm_time);
   while (thread_count)
   {
     mysql_cond_wait(&COND_thread_count, &LOCK_thread_count);
@@ -940,8 +954,8 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   thr_alarm_info(&alarm_info);
   end_thr_alarm(1);
   printf("Main_thread:  Alarms: %u  max_alarms: %u  next_alarm_time: %lu\n",
-     alarm_info.active_alarms, alarm_info.max_used_alarms,
-     alarm_info.next_alarm_time);
+	 alarm_info.active_alarms, alarm_info.max_used_alarms,
+	 alarm_info.next_alarm_time);
   printf("Test succeeded\n");
   return 0;
 }
@@ -955,4 +969,4 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
 }
 
 #endif /* !defined(DONT_USE_ALARM_THREAD) */
-#endif /* MAIN */
\ No newline at end of file
+#endif /* MAIN */
diff --git a/dep/mysqllite/mysys/thr_lock.c b/dep/mysqllite/mysys/thr_lock.c
index 27c35db..bc2a29b 100644
--- a/dep/mysqllite/mysys/thr_lock.c
+++ b/dep/mysqllite/mysys/thr_lock.c
@@ -30,13 +30,13 @@ Any thread can have any number of lock instances (read and write:s) on
 TL_READ_NO_INSERT	# Read without concurrent inserts
 TL_WRITE_ALLOW_WRITE	# Write lock that allows other writers
 TL_WRITE_CONCURRENT_INSERT
-            # Insert that can be mixed when selects
+			# Insert that can be mixed when selects
 TL_WRITE_DELAYED	# Used by delayed insert
-            # Allows lower locks to take over
+			# Allows lower locks to take over
 TL_WRITE_LOW_PRIORITY	# Low priority write
 TL_WRITE		# High priority write
 TL_WRITE_ONLY		# High priority write
-            # Abort all new lock request with an error
+			# Abort all new lock request with an error
 
 Locks are prioritized according to:
 
@@ -50,18 +50,18 @@ Any thread can have any number of lock instances (read and write:s) on
 (If the pointer is zero (default), the function is not called)
 
 check_status:
-     Before giving a lock of type TL_WRITE_CONCURRENT_INSERT,
+	 Before giving a lock of type TL_WRITE_CONCURRENT_INSERT,
          we check if this function exists and returns 0.
-     If not, then the lock is upgraded to TL_WRITE_LOCK
-     In MyISAM this is a simple check if the insert can be done
-     at the end of the datafile.
+	 If not, then the lock is upgraded to TL_WRITE_LOCK
+	 In MyISAM this is a simple check if the insert can be done
+	 at the end of the datafile.
 update_status:
-    Before a write lock is released, this function is called.
-    In MyISAM this functions updates the count and length of the datafile
+	Before a write lock is released, this function is called.
+	In MyISAM this functions updates the count and length of the datafile
 get_status:
-    When one gets a lock this functions is called.
-    In MyISAM this stores the number of rows and size of the datafile
-    for concurrent reads.
+	When one gets a lock this functions is called.
+	In MyISAM this stores the number of rows and size of the datafile
+	for concurrent reads.
 
 The lock algorithm allows one to have one TL_WRITE_CONCURRENT_INSERT or
 one TL_WRITE_DELAYED lock at the same time as multiple read locks.
@@ -86,6 +86,7 @@ Any thread can have any number of lock instances (read and write:s) on
 #define MAX_THREADS 100
 #define MAX_LOCKS   100
 
+
 LIST *thr_lock_thread_list;			/* List of threads in use */
 ulong max_write_lock_count= ~(ulong) 0L;
 
@@ -120,12 +121,13 @@ my_bool init_thr_lock()
   return rhs == lhs;
 }
 
+
 #ifdef EXTRA_DEBUG
 #define MAX_FOUND_ERRORS	10		/* Report 10 first errors */
 static uint found_errors=0;
 
 static int check_lock(struct st_lock_list *list, const char* lock_type,
-              const char *where, my_bool same_owner, my_bool no_cond)
+		      const char *where, my_bool same_owner, my_bool no_cond)
 {
   THR_LOCK_DATA *data,**prev;
   uint count=0;
@@ -141,50 +143,51 @@ static int check_lock(struct st_lock_list *list, const char* lock_type,
     for (data=list->data; data && count++ < MAX_LOCKS ; data=data->next)
     {
       if (data->type != last_lock_type)
-    last_lock_type=TL_IGNORE;
+	last_lock_type=TL_IGNORE;
       if (data->prev != prev)
       {
-    fprintf(stderr,
-        "Warning: prev link %d didn't point at previous lock at %s: %s\n",
-        count, lock_type, where);
-    return 1;
+	fprintf(stderr,
+		"Warning: prev link %d didn't point at previous lock at %s: %s\n",
+		count, lock_type, where);
+	return 1;
       }
       if (same_owner &&
           !thr_lock_owner_equal(data->owner, first_owner) &&
-      last_lock_type != TL_WRITE_ALLOW_WRITE)
+	  last_lock_type != TL_WRITE_ALLOW_WRITE)
       {
-    fprintf(stderr,
-        "Warning: Found locks from different threads in %s: %s\n",
-        lock_type,where);
-    return 1;
+	fprintf(stderr,
+		"Warning: Found locks from different threads in %s: %s\n",
+		lock_type,where);
+	return 1;
       }
       if (no_cond && data->cond)
       {
-    fprintf(stderr,
-        "Warning: Found active lock with not reset cond %s: %s\n",
-        lock_type,where);
-    return 1;
+	fprintf(stderr,
+		"Warning: Found active lock with not reset cond %s: %s\n",
+		lock_type,where);
+	return 1;
       }
       prev= &data->next;
     }
     if (data)
     {
       fprintf(stderr,"Warning: found too many locks at %s: %s\n",
-          lock_type,where);
+	      lock_type,where);
       return 1;
     }
   }
   if (prev != list->last)
   {
     fprintf(stderr,"Warning: last didn't point at last lock at %s: %s\n",
-        lock_type, where);
+	    lock_type, where);
     return 1;
   }
   return 0;
 }
 
+
 static void check_locks(THR_LOCK *lock, const char *where,
-            my_bool allow_no_locks)
+			my_bool allow_no_locks)
 {
   uint old_found_errors=found_errors;
   DBUG_ENTER("check_locks");
@@ -192,9 +195,9 @@ static void check_locks(THR_LOCK *lock, const char *where,
   if (found_errors < MAX_FOUND_ERRORS)
   {
     if (check_lock(&lock->write,"write",where,1,1) |
-    check_lock(&lock->write_wait,"write_wait",where,0,0) |
-    check_lock(&lock->read,"read",where,0,1) |
-    check_lock(&lock->read_wait,"read_wait",where,0,0))
+	check_lock(&lock->write_wait,"write_wait",where,0,0) |
+	check_lock(&lock->read,"read",where,0,1) |
+	check_lock(&lock->read_wait,"read_wait",where,0,0))
       found_errors++;
 
     if (found_errors < MAX_FOUND_ERRORS)
@@ -203,98 +206,99 @@ static void check_locks(THR_LOCK *lock, const char *where,
       THR_LOCK_DATA *data;
       for (data=lock->read.data ; data ; data=data->next)
       {
-    if ((int) data->type == (int) TL_READ_NO_INSERT)
-      count++;
+	if ((int) data->type == (int) TL_READ_NO_INSERT)
+	  count++;
         /* Protect against infinite loop. */
         DBUG_ASSERT(count <= lock->read_no_write_count);
       }
       if (count != lock->read_no_write_count)
       {
-    found_errors++;
-    fprintf(stderr,
-        "Warning at '%s': Locks read_no_write_count was %u when it should have been %u\n", where, lock->read_no_write_count,count);
-      }
+	found_errors++;
+	fprintf(stderr,
+		"Warning at '%s': Locks read_no_write_count was %u when it should have been %u\n", where, lock->read_no_write_count,count);
+      }      
 
       if (!lock->write.data)
       {
-    if (!allow_no_locks && !lock->read.data &&
-        (lock->write_wait.data || lock->read_wait.data))
-    {
-      found_errors++;
-      fprintf(stderr,
-          "Warning at '%s': No locks in use but locks are in wait queue\n",
-          where);
-    }
-    if (!lock->write_wait.data)
-    {
-      if (!allow_no_locks && lock->read_wait.data)
-      {
-        found_errors++;
-        fprintf(stderr,
-            "Warning at '%s': No write locks and waiting read locks\n",
-            where);
-      }
-    }
-    else
-    {
-      if (!allow_no_locks &&
-          (((lock->write_wait.data->type == TL_WRITE_CONCURRENT_INSERT ||
-         lock->write_wait.data->type == TL_WRITE_ALLOW_WRITE) &&
-        !lock->read_no_write_count) ||
-           (lock->write_wait.data->type == TL_WRITE_DELAYED &&
-        !lock->read.data)))
-      {
-        found_errors++;
-        fprintf(stderr,
-            "Warning at '%s': Write lock %d waiting while no exclusive read locks\n",where,(int) lock->write_wait.data->type);
-      }
-    }
+	if (!allow_no_locks && !lock->read.data &&
+	    (lock->write_wait.data || lock->read_wait.data))
+	{
+	  found_errors++;
+	  fprintf(stderr,
+		  "Warning at '%s': No locks in use but locks are in wait queue\n",
+		  where);
+	}
+	if (!lock->write_wait.data)
+	{
+	  if (!allow_no_locks && lock->read_wait.data)
+	  {
+	    found_errors++;
+	    fprintf(stderr,
+		    "Warning at '%s': No write locks and waiting read locks\n",
+		    where);
+	  }
+	}
+	else
+	{
+	  if (!allow_no_locks &&
+	      (((lock->write_wait.data->type == TL_WRITE_CONCURRENT_INSERT ||
+		 lock->write_wait.data->type == TL_WRITE_ALLOW_WRITE) &&
+		!lock->read_no_write_count) ||
+	       (lock->write_wait.data->type == TL_WRITE_DELAYED &&
+		!lock->read.data)))
+	  {
+	    found_errors++;
+	    fprintf(stderr,
+		    "Warning at '%s': Write lock %d waiting while no exclusive read locks\n",where,(int) lock->write_wait.data->type);
+	  }
+	}	      
       }
       else
       {						/* Have write lock */
-    if (lock->write_wait.data)
-    {
-      if (!allow_no_locks &&
-          lock->write.data->type == TL_WRITE_ALLOW_WRITE &&
-          lock->write_wait.data->type == TL_WRITE_ALLOW_WRITE)
-      {
-        found_errors++;
-        fprintf(stderr,
-            "Warning at '%s': Found WRITE_ALLOW_WRITE lock waiting for WRITE_ALLOW_WRITE lock\n",
-            where);
-      }
-    }
-    if (lock->read.data)
-    {
+	if (lock->write_wait.data)
+	{
+	  if (!allow_no_locks && 
+	      lock->write.data->type == TL_WRITE_ALLOW_WRITE &&
+	      lock->write_wait.data->type == TL_WRITE_ALLOW_WRITE)
+	  {
+	    found_errors++;
+	    fprintf(stderr,
+		    "Warning at '%s': Found WRITE_ALLOW_WRITE lock waiting for WRITE_ALLOW_WRITE lock\n",
+		    where);
+	  }
+	}
+	if (lock->read.data)
+	{
           if (!thr_lock_owner_equal(lock->write.data->owner,
                                     lock->read.data->owner) &&
-          ((lock->write.data->type > TL_WRITE_DELAYED &&
-        lock->write.data->type != TL_WRITE_ONLY) ||
-           ((lock->write.data->type == TL_WRITE_CONCURRENT_INSERT ||
-         lock->write.data->type == TL_WRITE_ALLOW_WRITE) &&
-        lock->read_no_write_count)))
-      {
-        found_errors++;
-        fprintf(stderr,
-            "Warning at '%s': Found lock of type %d that is write and read locked\n",
-            where, lock->write.data->type);
-        DBUG_PRINT("warning",("At '%s': Found lock of type %d that is write and read locked\n",
-            where, lock->write.data->type));
-      }
-    }
-    if (lock->read_wait.data)
-    {
-      if (!allow_no_locks && lock->write.data->type <= TL_WRITE_DELAYED &&
-          lock->read_wait.data->type <= TL_READ_HIGH_PRIORITY)
-      {
-        found_errors++;
-        fprintf(stderr,
-            "Warning at '%s': Found read lock of type %d waiting for write lock of type %d\n",
-            where,
-            (int) lock->read_wait.data->type,
-            (int) lock->write.data->type);
-      }
-    }
+	      ((lock->write.data->type > TL_WRITE_DELAYED &&
+		lock->write.data->type != TL_WRITE_ONLY) ||
+	       ((lock->write.data->type == TL_WRITE_CONCURRENT_INSERT ||
+		 lock->write.data->type == TL_WRITE_ALLOW_WRITE) &&
+		lock->read_no_write_count)))
+	  {
+	    found_errors++;
+	    fprintf(stderr,
+		    "Warning at '%s': Found lock of type %d that is write and read locked\n",
+		    where, lock->write.data->type);
+	    DBUG_PRINT("warning",("At '%s': Found lock of type %d that is write and read locked\n",
+		    where, lock->write.data->type));
+
+	  }
+	}
+	if (lock->read_wait.data)
+	{
+	  if (!allow_no_locks && lock->write.data->type <= TL_WRITE_DELAYED &&
+	      lock->read_wait.data->type <= TL_READ_HIGH_PRIORITY)
+	  {
+	    found_errors++;
+	    fprintf(stderr,
+		    "Warning at '%s': Found read lock of type %d waiting for write lock of type %d\n",
+		    where,
+		    (int) lock->read_wait.data->type,
+		    (int) lock->write.data->type);
+	  }
+	}
       }
     }
     if (found_errors != old_found_errors)
@@ -309,7 +313,8 @@ static void check_locks(THR_LOCK *lock, const char *where,
 #define check_locks(A,B,C)
 #endif
 
-    /* Initialize a lock */
+
+	/* Initialize a lock */
 
 void thr_lock_init(THR_LOCK *lock)
 {
@@ -328,6 +333,7 @@ void thr_lock_init(THR_LOCK *lock)
   DBUG_VOID_RETURN;
 }
 
+
 void thr_lock_delete(THR_LOCK *lock)
 {
   DBUG_ENTER("thr_lock_delete");
@@ -338,6 +344,7 @@ void thr_lock_delete(THR_LOCK *lock)
   DBUG_VOID_RETURN;
 }
 
+
 void thr_lock_info_init(THR_LOCK_INFO *info)
 {
   struct st_my_thread_var *tmp= my_thread_var;
@@ -345,7 +352,7 @@ void thr_lock_info_init(THR_LOCK_INFO *info)
   info->thread_id= tmp->id;
 }
 
-    /* Initialize a lock instance */
+	/* Initialize a lock instance */
 
 void thr_lock_data_init(THR_LOCK *lock,THR_LOCK_DATA *data, void *param)
 {
@@ -356,6 +363,7 @@ void thr_lock_data_init(THR_LOCK *lock,THR_LOCK_DATA *data, void *param)
   data->cond=0;
 }
 
+
 static inline my_bool
 has_old_lock(THR_LOCK_DATA *data, THR_LOCK_INFO *owner)
 {
@@ -368,7 +376,7 @@ void thr_lock_data_init(THR_LOCK *lock,THR_LOCK_DATA *data, void *param)
 }
 
 static inline my_bool have_specific_lock(THR_LOCK_DATA *data,
-                     enum thr_lock_type type)
+					 enum thr_lock_type type)
 {
   for ( ; data ; data=data->next)
   {
@@ -378,8 +386,10 @@ static inline my_bool have_specific_lock(THR_LOCK_DATA *data,
   return 0;
 }
 
+
 static void wake_up_waiters(THR_LOCK *lock);
 
+
 static enum enum_thr_lock_result
 wait_for_lock(struct st_lock_list *wait, THR_LOCK_DATA *data,
               my_bool in_wait_list, ulong lock_wait_timeout)
@@ -490,9 +500,9 @@ static inline my_bool have_specific_lock(THR_LOCK_DATA *data,
     if (data->cond)                             /* aborted or timed out */
     {
       if (((*data->prev)=data->next))		/* remove from wait-list */
-    data->next->prev= data->prev;
+	data->next->prev= data->prev;
       else
-    wait->last=data->prev;
+	wait->last=data->prev;
       data->type= TL_UNLOCK;                    /* No lock */
       check_locks(data->lock, "killed or timed out wait_for_lock", 1);
       wake_up_waiters(data->lock);
@@ -523,6 +533,7 @@ static inline my_bool have_specific_lock(THR_LOCK_DATA *data,
   DBUG_RETURN(result);
 }
 
+
 enum enum_thr_lock_result
 thr_lock(THR_LOCK_DATA *data, THR_LOCK_INFO *owner,
          enum thr_lock_type lock_type, ulong lock_wait_timeout)
@@ -541,7 +552,7 @@ enum enum_thr_lock_result
                      (long) data, data->owner->thread_id,
                      (long) lock, (int) lock_type));
   check_locks(lock,(uint) lock_type <= (uint) TL_READ_NO_INSERT ?
-          "enter read_lock" : "enter write_lock",0);
+	      "enter read_lock" : "enter write_lock",0);
   if ((int) lock_type <= (int) TL_READ_NO_INSERT)
   {
     /* Request for READ lock */
@@ -563,6 +574,7 @@ enum enum_thr_lock_result
            ||\ = READ_HIGH_PRIORITY
            |\  = READ_WITH_SHARED_LOCKS
            \   = READ
+          
 
         + = Request can be satisified.
         - = Request cannot be satisified.
@@ -574,43 +586,43 @@ enum enum_thr_lock_result
       */
 
       DBUG_PRINT("lock",("write locked 1 by thread: 0x%lx",
-             lock->write.data->owner->thread_id));
+			 lock->write.data->owner->thread_id));
       if (thr_lock_owner_equal(data->owner, lock->write.data->owner) ||
-      (lock->write.data->type <= TL_WRITE_DELAYED &&
-       (((int) lock_type <= (int) TL_READ_HIGH_PRIORITY) ||
-        (lock->write.data->type != TL_WRITE_CONCURRENT_INSERT))))
+	  (lock->write.data->type <= TL_WRITE_DELAYED &&
+	   (((int) lock_type <= (int) TL_READ_HIGH_PRIORITY) ||
+	    (lock->write.data->type != TL_WRITE_CONCURRENT_INSERT))))
       {						/* Already got a write lock */
-    (*lock->read.last)=data;		/* Add to running FIFO */
-    data->prev=lock->read.last;
-    lock->read.last= &data->next;
-    if (lock_type == TL_READ_NO_INSERT)
-      lock->read_no_write_count++;
-    check_locks(lock,"read lock with old write lock",0);
-    if (lock->get_status)
-      (*lock->get_status)(data->status_param, 0);
-    statistic_increment(locks_immediate,&THR_LOCK_lock);
-    goto end;
+	(*lock->read.last)=data;		/* Add to running FIFO */
+	data->prev=lock->read.last;
+	lock->read.last= &data->next;
+	if (lock_type == TL_READ_NO_INSERT)
+	  lock->read_no_write_count++;
+	check_locks(lock,"read lock with old write lock",0);
+	if (lock->get_status)
+	  (*lock->get_status)(data->status_param, 0);
+	statistic_increment(locks_immediate,&THR_LOCK_lock);
+	goto end;
       }
       if (lock->write.data->type == TL_WRITE_ONLY)
       {
-    /* We are not allowed to get a READ lock in this case */
-    data->type=TL_UNLOCK;
+	/* We are not allowed to get a READ lock in this case */
+	data->type=TL_UNLOCK;
         result= THR_LOCK_ABORTED;               /* Can't wait for this one */
-    goto end;
+	goto end;
       }
     }
     else if (!lock->write_wait.data ||
-         lock->write_wait.data->type <= TL_WRITE_LOW_PRIORITY ||
-         lock_type == TL_READ_HIGH_PRIORITY ||
-         has_old_lock(lock->read.data, data->owner)) /* Has old read lock */
+	     lock->write_wait.data->type <= TL_WRITE_LOW_PRIORITY ||
+	     lock_type == TL_READ_HIGH_PRIORITY ||
+	     has_old_lock(lock->read.data, data->owner)) /* Has old read lock */
     {						/* No important write-locks */
       (*lock->read.last)=data;			/* Add to running FIFO */
       data->prev=lock->read.last;
       lock->read.last= &data->next;
       if (lock->get_status)
-    (*lock->get_status)(data->status_param, 0);
+	(*lock->get_status)(data->status_param, 0);
       if (lock_type == TL_READ_NO_INSERT)
-    lock->read_no_write_count++;
+	lock->read_no_write_count++;
       check_locks(lock,"read lock with no write locks",0);
       statistic_increment(locks_immediate,&THR_LOCK_lock);
       goto end;
@@ -628,23 +640,23 @@ enum enum_thr_lock_result
     {
       if (lock->write.data && lock->write.data->type == TL_WRITE_ONLY)
       {
-    data->type=TL_UNLOCK;
+	data->type=TL_UNLOCK;
         result= THR_LOCK_ABORTED;               /* Can't wait for this one */
-    goto end;
+	goto end;
       }
       if (lock->write.data || lock->read.data)
       {
-    /* Add delayed write lock to write_wait queue, and return at once */
-    (*lock->write_wait.last)=data;
-    data->prev=lock->write_wait.last;
-    lock->write_wait.last= &data->next;
-    data->cond=get_cond();
+	/* Add delayed write lock to write_wait queue, and return at once */
+	(*lock->write_wait.last)=data;
+	data->prev=lock->write_wait.last;
+	lock->write_wait.last= &data->next;
+	data->cond=get_cond();
         /*
           We don't have to do get_status here as we will do it when we change
           the delayed lock to a real write lock
         */
-    statistic_increment(locks_immediate,&THR_LOCK_lock);
-    goto end;
+	statistic_increment(locks_immediate,&THR_LOCK_lock);
+	goto end;
       }
     }
     else if (lock_type == TL_WRITE_CONCURRENT_INSERT && ! lock->check_status)
@@ -705,7 +717,7 @@ enum enum_thr_lock_result
            lock->write.data->type == TL_WRITE_ALLOW_WRITE) ||
           has_old_lock(lock->write.data, data->owner))
       {
-    /*
+	/*
           We have already got a write lock or all locks are
           TL_WRITE_ALLOW_WRITE
         */
@@ -713,17 +725,17 @@ enum enum_thr_lock_result
                             (ulong) lock->write_wait.data,
                             lock->write.data->type));
 
-    (*lock->write.last)=data;	/* Add to running fifo */
-    data->prev=lock->write.last;
-    lock->write.last= &data->next;
-    check_locks(lock,"second write lock",0);
-    if (data->lock->get_status)
-      (*data->lock->get_status)(data->status_param, 0);
-    statistic_increment(locks_immediate,&THR_LOCK_lock);
-    goto end;
+	(*lock->write.last)=data;	/* Add to running fifo */
+	data->prev=lock->write.last;
+	lock->write.last= &data->next;
+	check_locks(lock,"second write lock",0);
+	if (data->lock->get_status)
+	  (*data->lock->get_status)(data->status_param, 0);
+	statistic_increment(locks_immediate,&THR_LOCK_lock);
+	goto end;
       }
       DBUG_PRINT("lock",("write locked 2 by thread: 0x%lx",
-             lock->write.data->owner->thread_id));
+			 lock->write.data->owner->thread_id));
     }
     else
     {
@@ -732,7 +744,7 @@ enum enum_thr_lock_result
       if (!lock->write_wait.data)
       {						/* no scheduled write locks */
         my_bool concurrent_insert= 0;
-    if (lock_type == TL_WRITE_CONCURRENT_INSERT)
+	if (lock_type == TL_WRITE_CONCURRENT_INSERT)
         {
           concurrent_insert= 1;
           if ((*lock->check_status)(data->status_param))
@@ -742,24 +754,24 @@ enum enum_thr_lock_result
           }
         }
 
-    if (!lock->read.data ||
-        (lock_type <= TL_WRITE_DELAYED &&
-         ((lock_type != TL_WRITE_CONCURRENT_INSERT &&
-           lock_type != TL_WRITE_ALLOW_WRITE) ||
-          !lock->read_no_write_count)))
-    {
-      (*lock->write.last)=data;		/* Add as current write lock */
-      data->prev=lock->write.last;
-      lock->write.last= &data->next;
-      if (data->lock->get_status)
-        (*data->lock->get_status)(data->status_param, concurrent_insert);
-      check_locks(lock,"only write lock",0);
-      statistic_increment(locks_immediate,&THR_LOCK_lock);
-      goto end;
-    }
+	if (!lock->read.data ||
+	    (lock_type <= TL_WRITE_DELAYED &&
+	     ((lock_type != TL_WRITE_CONCURRENT_INSERT &&
+	       lock_type != TL_WRITE_ALLOW_WRITE) ||
+	      !lock->read_no_write_count)))
+	{
+	  (*lock->write.last)=data;		/* Add as current write lock */
+	  data->prev=lock->write.last;
+	  lock->write.last= &data->next;
+	  if (data->lock->get_status)
+	    (*data->lock->get_status)(data->status_param, concurrent_insert);
+	  check_locks(lock,"only write lock",0);
+	  statistic_increment(locks_immediate,&THR_LOCK_lock);
+	  goto end;
+	}
       }
       DBUG_PRINT("lock",("write locked 3 by thread: 0x%lx  type: %d",
-             lock->read.data->owner->thread_id, data->type));
+			 lock->read.data->owner->thread_id, data->type));
     }
     wait_queue= &lock->write_wait;
   }
@@ -770,8 +782,9 @@ enum enum_thr_lock_result
   DBUG_RETURN(result);
 }
 
+
 static inline void free_all_read_locks(THR_LOCK *lock,
-                       my_bool using_concurrent_insert)
+				       my_bool using_concurrent_insert)
 {
   THR_LOCK_DATA *data=lock->read_wait.data;
 
@@ -792,24 +805,24 @@ static inline void free_all_read_locks(THR_LOCK *lock,
     {
       if (using_concurrent_insert)
       {
-    /*
-      We can't free this lock;
-      Link lock away from read chain back into read_wait chain
-    */
-    if (((*data->prev)=data->next))
-      data->next->prev=data->prev;
-    else
-      lock->read.last=data->prev;
-    *lock->read_wait.last= data;
-    data->prev= lock->read_wait.last;
-    lock->read_wait.last= &data->next;
-    continue;
+	/*
+	  We can't free this lock; 
+	  Link lock away from read chain back into read_wait chain
+	*/
+	if (((*data->prev)=data->next))
+	  data->next->prev=data->prev;
+	else
+	  lock->read.last=data->prev;
+	*lock->read_wait.last= data;
+	data->prev= lock->read_wait.last;
+	lock->read_wait.last= &data->next;
+	continue;
       }
       lock->read_no_write_count++;
-    }
+    }      
     /* purecov: begin inspected */
     DBUG_PRINT("lock",("giving read lock to thread: 0x%lx",
-               data->owner->thread_id));
+		       data->owner->thread_id));
     /* purecov: end */
     data->cond=0;				/* Mark thread free */
     mysql_cond_signal(cond);
@@ -820,7 +833,7 @@ static inline void free_all_read_locks(THR_LOCK *lock,
   check_locks(lock,"after giving read locks",0);
 }
 
-    /* Unlock lock and free next thread on same lock */
+	/* Unlock lock and free next thread on same lock */
 
 void thr_unlock(THR_LOCK_DATA *data)
 {
@@ -839,7 +852,7 @@ void thr_unlock(THR_LOCK_DATA *data)
   else if (lock_type == TL_WRITE_DELAYED && data->cond)
   {
     /*
-      This only happens in extreme circumstances when a
+      This only happens in extreme circumstances when a 
       write delayed lock that is waiting for a lock
     */
     lock->write_wait.last=data->prev;		/* Put it on wait queue */
@@ -865,6 +878,7 @@ void thr_unlock(THR_LOCK_DATA *data)
   DBUG_VOID_RETURN;
 }
 
+
 /**
   @brief  Wake up all threads which pending requests for the lock
           can be satisfied.
@@ -887,99 +901,99 @@ static void wake_up_waiters(THR_LOCK *lock)
     {
       /* Release write-locks with TL_WRITE or TL_WRITE_ONLY priority first */
       if (data &&
-      (data->type != TL_WRITE_LOW_PRIORITY || !lock->read_wait.data ||
-       lock->read_wait.data->type < TL_READ_HIGH_PRIORITY))
-      {
-    if (lock->write_lock_count++ > max_write_lock_count)
-    {
-      /* Too many write locks in a row;  Release all waiting read locks */
-      lock->write_lock_count=0;
-      if (lock->read_wait.data)
+	  (data->type != TL_WRITE_LOW_PRIORITY || !lock->read_wait.data ||
+	   lock->read_wait.data->type < TL_READ_HIGH_PRIORITY))
       {
-        DBUG_PRINT("info",("Freeing all read_locks because of max_write_lock_count"));
-        free_all_read_locks(lock,0);
-        goto end;
-      }
-    }
-    for (;;)
-    {
-      if (((*data->prev)=data->next))	/* remove from wait-list */
-        data->next->prev= data->prev;
-      else
-        lock->write_wait.last=data->prev;
-      (*lock->write.last)=data;		/* Put in execute list */
-      data->prev=lock->write.last;
-      data->next=0;
-      lock->write.last= &data->next;
-      if (data->type == TL_WRITE_CONCURRENT_INSERT &&
-          (*lock->check_status)(data->status_param))
-        data->type=TL_WRITE;			/* Upgrade lock */
+	if (lock->write_lock_count++ > max_write_lock_count)
+	{
+	  /* Too many write locks in a row;  Release all waiting read locks */
+	  lock->write_lock_count=0;
+	  if (lock->read_wait.data)
+	  {
+	    DBUG_PRINT("info",("Freeing all read_locks because of max_write_lock_count"));
+	    free_all_read_locks(lock,0);
+	    goto end;
+	  }
+	}
+	for (;;)
+	{
+	  if (((*data->prev)=data->next))	/* remove from wait-list */
+	    data->next->prev= data->prev;
+	  else
+	    lock->write_wait.last=data->prev;
+	  (*lock->write.last)=data;		/* Put in execute list */
+	  data->prev=lock->write.last;
+	  data->next=0;
+	  lock->write.last= &data->next;
+	  if (data->type == TL_WRITE_CONCURRENT_INSERT &&
+	      (*lock->check_status)(data->status_param))
+	    data->type=TL_WRITE;			/* Upgrade lock */
           /* purecov: begin inspected */
-      DBUG_PRINT("lock",("giving write lock of type %d to thread: 0x%lx",
-                 data->type, data->owner->thread_id));
+	  DBUG_PRINT("lock",("giving write lock of type %d to thread: 0x%lx",
+			     data->type, data->owner->thread_id));
           /* purecov: end */
-      {
+	  {
             mysql_cond_t *cond= data->cond;
-        data->cond=0;				/* Mark thread free */
+	    data->cond=0;				/* Mark thread free */
             mysql_cond_signal(cond);                    /* Start waiting thread */
-      }
-      if (data->type != TL_WRITE_ALLOW_WRITE ||
-          !lock->write_wait.data ||
-          lock->write_wait.data->type != TL_WRITE_ALLOW_WRITE)
-        break;
-      data=lock->write_wait.data;		/* Free this too */
-    }
-    if (data->type >= TL_WRITE_LOW_PRIORITY)
+	  }
+	  if (data->type != TL_WRITE_ALLOW_WRITE ||
+	      !lock->write_wait.data ||
+	      lock->write_wait.data->type != TL_WRITE_ALLOW_WRITE)
+	    break;
+	  data=lock->write_wait.data;		/* Free this too */
+	}
+	if (data->type >= TL_WRITE_LOW_PRIORITY)
           goto end;
-    /* Release possible read locks together with the write lock */
+	/* Release possible read locks together with the write lock */
       }
       if (lock->read_wait.data)
-    free_all_read_locks(lock,
-                data &&
-                (data->type == TL_WRITE_CONCURRENT_INSERT ||
-                 data->type == TL_WRITE_ALLOW_WRITE));
+	free_all_read_locks(lock,
+			    data &&
+			    (data->type == TL_WRITE_CONCURRENT_INSERT ||
+			     data->type == TL_WRITE_ALLOW_WRITE));
       else
       {
-    DBUG_PRINT("lock",("No waiting read locks to free"));
+	DBUG_PRINT("lock",("No waiting read locks to free"));
       }
     }
     else if (data &&
-         (lock_type=data->type) <= TL_WRITE_DELAYED &&
-         ((lock_type != TL_WRITE_CONCURRENT_INSERT &&
-           lock_type != TL_WRITE_ALLOW_WRITE) ||
-          !lock->read_no_write_count))
+	     (lock_type=data->type) <= TL_WRITE_DELAYED &&
+	     ((lock_type != TL_WRITE_CONCURRENT_INSERT &&
+	       lock_type != TL_WRITE_ALLOW_WRITE) ||
+	      !lock->read_no_write_count))
     {
       /*
-    For DELAYED, ALLOW_READ, WRITE_ALLOW_WRITE or CONCURRENT_INSERT locks
-    start WRITE locks together with the READ locks
+	For DELAYED, ALLOW_READ, WRITE_ALLOW_WRITE or CONCURRENT_INSERT locks
+	start WRITE locks together with the READ locks
       */
       if (lock_type == TL_WRITE_CONCURRENT_INSERT &&
-      (*lock->check_status)(data->status_param))
+	  (*lock->check_status)(data->status_param))
       {
-    data->type=TL_WRITE;			/* Upgrade lock */
-    if (lock->read_wait.data)
-      free_all_read_locks(lock,0);
-    goto end;
+	data->type=TL_WRITE;			/* Upgrade lock */
+	if (lock->read_wait.data)
+	  free_all_read_locks(lock,0);
+	goto end;
       }
       do {
         mysql_cond_t *cond= data->cond;
-    if (((*data->prev)=data->next))		/* remove from wait-list */
-      data->next->prev= data->prev;
-    else
-      lock->write_wait.last=data->prev;
-    (*lock->write.last)=data;		/* Put in execute list */
-    data->prev=lock->write.last;
-    lock->write.last= &data->next;
-    data->next=0;				/* Only one write lock */
-    data->cond=0;				/* Mark thread free */
+	if (((*data->prev)=data->next))		/* remove from wait-list */
+	  data->next->prev= data->prev;
+	else
+	  lock->write_wait.last=data->prev;
+	(*lock->write.last)=data;		/* Put in execute list */
+	data->prev=lock->write.last;
+	lock->write.last= &data->next;
+	data->next=0;				/* Only one write lock */
+	data->cond=0;				/* Mark thread free */
         mysql_cond_signal(cond);                /* Start waiting thread */
       } while (lock_type == TL_WRITE_ALLOW_WRITE &&
-           (data=lock->write_wait.data) &&
-           data->type == TL_WRITE_ALLOW_WRITE);
+	       (data=lock->write_wait.data) &&
+	       data->type == TL_WRITE_ALLOW_WRITE);
       if (lock->read_wait.data)
-    free_all_read_locks(lock,
-                (lock_type == TL_WRITE_CONCURRENT_INSERT ||
-                 lock_type == TL_WRITE_ALLOW_WRITE));
+	free_all_read_locks(lock,
+			    (lock_type == TL_WRITE_CONCURRENT_INSERT ||
+			     lock_type == TL_WRITE_ALLOW_WRITE));
     }
     else if (!data && lock->read_wait.data)
       free_all_read_locks(lock,0);
@@ -989,12 +1003,14 @@ static void wake_up_waiters(THR_LOCK *lock)
   DBUG_VOID_RETURN;
 }
 
+
 /*
 ** Get all locks in a specific order to avoid dead-locks
 ** Sort acording to lock position and put write_locks before read_locks if
 ** lock on same lock.
 */
 
+
 #define LOCK_CMP(A,B) ((uchar*) (A->lock) - (uint) ((A)->type) < (uchar*) (B->lock)- (uint) ((B)->type))
 
 static void sort_locks(THR_LOCK_DATA **data,uint count)
@@ -1010,13 +1026,14 @@ static void sort_locks(THR_LOCK_DATA **data,uint count)
     {
       prev=pos;
       do {
-    prev[0]=prev[-1];
+	prev[0]=prev[-1];
       } while (--prev != data && LOCK_CMP(tmp,prev[-1]));
       prev[0]=tmp;
     }
   }
 }
 
+
 enum enum_thr_lock_result
 thr_multi_lock(THR_LOCK_DATA **data, uint count, THR_LOCK_INFO *owner,
                ulong lock_wait_timeout)
@@ -1039,13 +1056,14 @@ enum enum_thr_lock_result
     DEBUG_SYNC_C("thr_multi_lock_after_thr_lock");
 #ifdef MAIN
     printf("Thread: %s  Got lock: 0x%lx  type: %d\n",my_thread_name(),
-       (long) pos[0]->lock, pos[0]->type); fflush(stdout);
+	   (long) pos[0]->lock, pos[0]->type); fflush(stdout);
 #endif
   }
   thr_lock_merge_status(data, count);
   DBUG_RETURN(THR_LOCK_SUCCESS);
 }
 
+
 /**
   Ensure that all locks for a given table have the same
   status_param.
@@ -1086,36 +1104,36 @@ enum enum_thr_lock_result
     {
       pos--;
       if (last_lock->lock == (*pos)->lock &&
-      last_lock->lock->copy_status)
-      {
-    if (last_lock->type <= TL_READ_NO_INSERT)
-    {
-      THR_LOCK_DATA **read_lock;
-      /*
-        If we are locking the same table with read locks we must ensure
-        that all tables share the status of the last write lock or
-        the same read lock.
-      */
-      for (;
-           (*pos)->type <= TL_READ_NO_INSERT &&
-         pos != data &&
-         pos[-1]->lock == (*pos)->lock ;
-           pos--) ;
-
-      read_lock = pos+1;
-      do
+	  last_lock->lock->copy_status)
       {
-        (last_lock->lock->copy_status)((*read_lock)->status_param,
-                       (*pos)->status_param);
-      } while (*(read_lock++) != last_lock);
-      last_lock= (*pos);			/* Point at last write lock */
-    }
-    else
-      (*last_lock->lock->copy_status)((*pos)->status_param,
-                      last_lock->status_param);
+	if (last_lock->type <= TL_READ_NO_INSERT)
+	{
+	  THR_LOCK_DATA **read_lock;
+	  /*
+	    If we are locking the same table with read locks we must ensure
+	    that all tables share the status of the last write lock or
+	    the same read lock.
+	  */
+	  for (;
+	       (*pos)->type <= TL_READ_NO_INSERT &&
+		 pos != data &&
+		 pos[-1]->lock == (*pos)->lock ;
+	       pos--) ;
+
+	  read_lock = pos+1;
+	  do
+	  {
+	    (last_lock->lock->copy_status)((*read_lock)->status_param,
+					   (*pos)->status_param);
+	  } while (*(read_lock++) != last_lock);
+	  last_lock= (*pos);			/* Point at last write lock */
+	}
+	else
+	  (*last_lock->lock->copy_status)((*pos)->status_param,
+					  last_lock->status_param);
       }
       else
-    last_lock=(*pos);
+	last_lock=(*pos);
     } while (pos != data);
   }
 #endif
@@ -1133,7 +1151,7 @@ void thr_multi_unlock(THR_LOCK_DATA **data,uint count)
   {
 #ifdef MAIN
     printf("Thread: %s  Rel lock: 0x%lx  type: %d\n",
-       my_thread_name(), (long) pos[0]->lock, pos[0]->type);
+	   my_thread_name(), (long) pos[0]->lock, pos[0]->type);
     fflush(stdout);
 #endif
     if ((*pos)->type != TL_UNLOCK)
@@ -1181,6 +1199,7 @@ void thr_abort_locks(THR_LOCK *lock, my_bool upgrade_lock)
   DBUG_VOID_RETURN;
 }
 
+
 /*
   Abort all locks for specific table/thread combination
 
@@ -1206,9 +1225,9 @@ my_bool thr_abort_locks_for_thread(THR_LOCK *lock, my_thread_id thread_id)
       data->cond= 0;				/* Removed from list */
 
       if (((*data->prev)= data->next))
-    data->next->prev= data->prev;
+	data->next->prev= data->prev;
       else
-    lock->read_wait.last= data->prev;
+	lock->read_wait.last= data->prev;
     }
   }
   for (data= lock->write_wait.data; data ; data= data->next)
@@ -1222,9 +1241,9 @@ my_bool thr_abort_locks_for_thread(THR_LOCK *lock, my_thread_id thread_id)
       data->cond= 0;
 
       if (((*data->prev)= data->next))
-    data->next->prev= data->prev;
+	data->next->prev= data->prev;
       else
-    lock->write_wait.last= data->prev;
+	lock->write_wait.last= data->prev;
     }
   }
   wake_up_waiters(lock);
@@ -1232,6 +1251,7 @@ my_bool thr_abort_locks_for_thread(THR_LOCK *lock, my_thread_id thread_id)
   DBUG_RETURN(found);
 }
 
+
 /*
   Downgrade a WRITE_* to a lower WRITE level
   SYNOPSIS
@@ -1303,7 +1323,7 @@ my_bool thr_upgrade_write_delay_lock(THR_LOCK_DATA *data,
     if (!lock->read.data)			/* No read locks */
     {						/* We have the lock */
       if (data->lock->get_status)
-    (*data->lock->get_status)(data->status_param, 0);
+	(*data->lock->get_status)(data->status_param, 0);
       mysql_mutex_unlock(&lock->mutex);
       DBUG_RETURN(0);
     }
@@ -1328,6 +1348,7 @@ my_bool thr_upgrade_write_delay_lock(THR_LOCK_DATA *data,
   DBUG_RETURN(wait_for_lock(&lock->write_wait,data,1, lock_wait_timeout));
 }
 
+
 /* downgrade a WRITE lock to a WRITE_DELAY lock if there is pending locks */
 
 my_bool thr_reschedule_write_lock(THR_LOCK_DATA *data,
@@ -1367,6 +1388,7 @@ my_bool thr_reschedule_write_lock(THR_LOCK_DATA *data,
                                            lock_wait_timeout));
 }
 
+
 #include <my_sys.h>
 
 static void thr_print_lock(const char* name,struct st_lock_list *list)
@@ -1383,7 +1405,7 @@ static void thr_print_lock(const char* name,struct st_lock_list *list)
       printf("0x%lx (%lu:%d); ", (ulong) data, data->owner->thread_id,
              (int) data->type);
       if (data->prev != prev)
-    printf("\nWarning: prev didn't point at previous lock\n");
+	printf("\nWarning: prev didn't point at previous lock\n");
       prev= &data->next;
     }
     puts("");
@@ -1406,7 +1428,7 @@ void thr_print_locks(void)
     mysql_mutex_lock(&lock->mutex);
     printf("lock: 0x%lx:",(ulong) lock);
     if ((lock->write_wait.data || lock->read_wait.data) &&
-    (! lock->read.data && ! lock->write.data))
+	(! lock->read.data && ! lock->write.data))
       printf(" WARNING: ");
     if (lock->write.data)
       printf(" write");
@@ -1428,6 +1450,7 @@ void thr_print_locks(void)
   mysql_mutex_unlock(&THR_LOCK_lock);
 }
 
+
 /*****************************************************************************
 ** Test of thread locks
 ****************************************************************************/
@@ -1459,26 +1482,27 @@ struct st_test {
 struct st_test test_15[] = {{0,TL_WRITE_ALLOW_WRITE},{1,TL_WRITE_ALLOW_WRITE}};
 
 struct st_test *tests[] = {test_0,test_1,test_2,test_3,test_4,test_5,test_6,
-               test_7,test_8,test_9,test_10,test_11,test_12,
-               test_13,test_14,test_15};
+			   test_7,test_8,test_9,test_10,test_11,test_12,
+			   test_13,test_14,test_15};
 int lock_counts[]= {sizeof(test_0)/sizeof(struct st_test),
-            sizeof(test_1)/sizeof(struct st_test),
-            sizeof(test_2)/sizeof(struct st_test),
-            sizeof(test_3)/sizeof(struct st_test),
-            sizeof(test_4)/sizeof(struct st_test),
-            sizeof(test_5)/sizeof(struct st_test),
-            sizeof(test_6)/sizeof(struct st_test),
-            sizeof(test_7)/sizeof(struct st_test),
-            sizeof(test_8)/sizeof(struct st_test),
-            sizeof(test_9)/sizeof(struct st_test),
-            sizeof(test_10)/sizeof(struct st_test),
-            sizeof(test_11)/sizeof(struct st_test),
-            sizeof(test_12)/sizeof(struct st_test),
-            sizeof(test_13)/sizeof(struct st_test),
-            sizeof(test_14)/sizeof(struct st_test),
-            sizeof(test_15)/sizeof(struct st_test)
+		    sizeof(test_1)/sizeof(struct st_test),
+		    sizeof(test_2)/sizeof(struct st_test),
+		    sizeof(test_3)/sizeof(struct st_test),
+		    sizeof(test_4)/sizeof(struct st_test),
+		    sizeof(test_5)/sizeof(struct st_test),
+		    sizeof(test_6)/sizeof(struct st_test),
+		    sizeof(test_7)/sizeof(struct st_test),
+		    sizeof(test_8)/sizeof(struct st_test),
+		    sizeof(test_9)/sizeof(struct st_test),
+		    sizeof(test_10)/sizeof(struct st_test),
+		    sizeof(test_11)/sizeof(struct st_test),
+		    sizeof(test_12)/sizeof(struct st_test),
+		    sizeof(test_13)/sizeof(struct st_test),
+		    sizeof(test_14)/sizeof(struct st_test),
+		    sizeof(test_15)/sizeof(struct st_test)
 };
 
+
 static mysql_cond_t COND_thread_count;
 static mysql_mutex_t LOCK_thread_count;
 static uint thread_count;
@@ -1499,7 +1523,7 @@ static void test_update_status(void* param __attribute__((unused)))
 }
 
 static void test_copy_status(void* to __attribute__((unused)) ,
-                 void *from __attribute__((unused)))
+			     void *from __attribute__((unused)))
 {
 }
 
@@ -1508,6 +1532,7 @@ static my_bool test_check_status(void* param __attribute__((unused)))
   return 0;
 }
 
+
 static void *test_thread(void *arg)
 {
   int i,j,param=*((int*) arg);
@@ -1518,6 +1543,7 @@ static void *test_thread(void *arg)
 
   printf("Thread %s (%d) started\n",my_thread_name(),param); fflush(stdout);
 
+
   thr_lock_info_init(&lock_info);
   for (i=0; i < lock_counts[param] ; i++)
     thr_lock_data_init(locks+tests[param][i].lock_nr,data+i,NULL);
@@ -1533,14 +1559,14 @@ static void *test_thread(void *arg)
     {
       int tmp=rand() & 7;			/* Do something from 0-2 sec */
       if (tmp == 0)
-    sleep(1);
+	sleep(1);
       else if (tmp == 1)
-    sleep(2);
+	sleep(2);
       else
       {
-    ulong k;
-    for (k=0 ; k < (ulong) (tmp-2)*100000L ; k++)
-      sum+=k;
+	ulong k;
+	for (k=0 ; k < (ulong) (tmp-2)*100000L ; k++)
+	  sum+=k;
       }
     }
     mysql_mutex_unlock(&LOCK_thread_count);
@@ -1557,6 +1583,7 @@ static void *test_thread(void *arg)
   return 0;
 }
 
+
 int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
 {
   pthread_t tid;
@@ -1571,13 +1598,13 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   if ((error= mysql_cond_init(0, &COND_thread_count, NULL)))
   {
     fprintf(stderr, "Got error: %d from mysql_cond_init (errno: %d)",
-        error,errno);
+	    error,errno);
     exit(1);
   }
   if ((error= mysql_mutex_init(0, &LOCK_thread_count, MY_MUTEX_INIT_FAST)))
   {
     fprintf(stderr, "Got error: %d from mysql_cond_init (errno: %d)",
-        error,errno);
+	    error,errno);
     exit(1);
   }
 
@@ -1592,21 +1619,21 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   if ((error=pthread_attr_init(&thr_attr)))
   {
     fprintf(stderr,"Got error: %d from pthread_attr_init (errno: %d)",
-        error,errno);
+	    error,errno);
     exit(1);
   }
   if ((error=pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED)))
   {
     fprintf(stderr,
-        "Got error: %d from pthread_attr_setdetachstate (errno: %d)",
-        error,errno);
+	    "Got error: %d from pthread_attr_setdetachstate (errno: %d)",
+	    error,errno);
     exit(1);
   }
 #ifndef pthread_attr_setstacksize		/* void return value */
   if ((error=pthread_attr_setstacksize(&thr_attr,65536L)))
   {
     fprintf(stderr,"Got error: %d from pthread_attr_setstacksize (errno: %d)",
-        error,errno);
+	    error,errno);
     exit(1);
   }
 #endif
@@ -1658,4 +1685,4 @@ int main(int argc __attribute__((unused)),char **argv __attribute__((unused)))
   return 0;
 }
 
-#endif /* MAIN */
\ No newline at end of file
+#endif /* MAIN */
diff --git a/dep/mysqllite/mysys/thr_mutex.c b/dep/mysqllite/mysys/thr_mutex.c
index 8878c7a..4d05139 100644
--- a/dep/mysqllite/mysys/thr_mutex.c
+++ b/dep/mysqllite/mysys/thr_mutex.c
@@ -51,10 +51,11 @@ void safe_mutex_global_init(void)
   pthread_mutex_init(&THR_LOCK_mutex,MY_MUTEX_INIT_FAST);
 }
 
+
 int safe_mutex_init(safe_mutex_t *mp,
-            const pthread_mutexattr_t *attr __attribute__((unused)),
-            const char *file,
-            uint line)
+		    const pthread_mutexattr_t *attr __attribute__((unused)),
+		    const char *file,
+		    uint line)
 {
   bzero((char*) mp,sizeof(*mp));
   pthread_mutex_init(&mp->global,MY_MUTEX_INIT_ERRCHK);
@@ -92,14 +93,15 @@ int safe_mutex_init(safe_mutex_t *mp,
   return 0;
 }
 
+
 int safe_mutex_lock(safe_mutex_t *mp, my_bool try_lock, const char *file, uint line)
 {
   int error;
   if (!mp->file)
   {
     fprintf(stderr,
-        "safe_mutex: Trying to lock unitialized mutex at %s, line %d\n",
-        file, line);
+	    "safe_mutex: Trying to lock unitialized mutex at %s, line %d\n",
+	    file, line);
     fflush(stderr);
     abort();
   }
@@ -152,7 +154,7 @@ int safe_mutex_lock(safe_mutex_t *mp, my_bool try_lock, const char *file, uint l
   if (error || (error=pthread_mutex_lock(&mp->global)))
   {
     fprintf(stderr,"Got error %d when trying to lock mutex at %s, line %d\n",
-        error, file, line);
+	    error, file, line);
     fflush(stderr);
     abort();
   }
@@ -170,6 +172,7 @@ int safe_mutex_lock(safe_mutex_t *mp, my_bool try_lock, const char *file, uint l
   return error;
 }
 
+
 int safe_mutex_unlock(safe_mutex_t *mp,const char *file, uint line)
 {
   int error;
@@ -177,14 +180,14 @@ int safe_mutex_unlock(safe_mutex_t *mp,const char *file, uint line)
   if (mp->count == 0)
   {
     fprintf(stderr,"safe_mutex: Trying to unlock mutex that wasn't locked at %s, line %d\n            Last used at %s, line: %d\n",
-        file,line,mp->file ? mp->file : "",mp->line);
+	    file,line,mp->file ? mp->file : "",mp->line);
     fflush(stderr);
     abort();
   }
   if (!pthread_equal(pthread_self(),mp->thread))
   {
     fprintf(stderr,"safe_mutex: Trying to unlock mutex at %s, line %d  that was locked by another thread at: %s, line: %d\n",
-        file,line,mp->file,mp->line);
+	    file,line,mp->file,mp->line);
     fflush(stderr);
     abort();
   }
@@ -206,8 +209,9 @@ int safe_mutex_unlock(safe_mutex_t *mp,const char *file, uint line)
   return error;
 }
 
+
 int safe_cond_wait(pthread_cond_t *cond, safe_mutex_t *mp, const char *file,
-           uint line)
+		   uint line)
 {
   int error;
   pthread_mutex_lock(&mp->global);
@@ -220,7 +224,7 @@ int safe_cond_wait(pthread_cond_t *cond, safe_mutex_t *mp, const char *file,
   if (!pthread_equal(pthread_self(),mp->thread))
   {
     fprintf(stderr,"safe_mutex: Trying to cond_wait on a mutex at %s, line %d  that was locked by another thread at: %s, line: %d\n",
-        file,line,mp->file,mp->line);
+	    file,line,mp->file,mp->line);
     fflush(stderr);
     abort();
   }
@@ -228,7 +232,7 @@ int safe_cond_wait(pthread_cond_t *cond, safe_mutex_t *mp, const char *file,
   if (mp->count-- != 1)
   {
     fprintf(stderr,"safe_mutex:  Count was %d on locked mutex at %s, line %d\n",
-        mp->count+1, file, line);
+	    mp->count+1, file, line);
     fflush(stderr);
     abort();
   }
@@ -245,8 +249,8 @@ int safe_cond_wait(pthread_cond_t *cond, safe_mutex_t *mp, const char *file,
   if (mp->count++)
   {
     fprintf(stderr,
-        "safe_mutex:  Count was %d in thread 0x%lx when locking mutex at %s, line %d\n",
-        mp->count-1, my_thread_dbug_id(), file, line);
+	    "safe_mutex:  Count was %d in thread 0x%lx when locking mutex at %s, line %d\n",
+	    mp->count-1, my_thread_dbug_id(), file, line);
     fflush(stderr);
     abort();
   }
@@ -256,6 +260,7 @@ int safe_cond_wait(pthread_cond_t *cond, safe_mutex_t *mp, const char *file,
   return error;
 }
 
+
 int safe_cond_timedwait(pthread_cond_t *cond, safe_mutex_t *mp,
                         const struct timespec *abstime,
                         const char *file, uint line)
@@ -282,8 +287,8 @@ int safe_cond_timedwait(pthread_cond_t *cond, safe_mutex_t *mp,
   if (mp->count++)
   {
     fprintf(stderr,
-        "safe_mutex:  Count was %d in thread 0x%lx when locking mutex at %s, line %d (error: %d (%d))\n",
-        mp->count-1, my_thread_dbug_id(), file, line, error, error);
+	    "safe_mutex:  Count was %d in thread 0x%lx when locking mutex at %s, line %d (error: %d (%d))\n",
+	    mp->count-1, my_thread_dbug_id(), file, line, error, error);
     fflush(stderr);
     abort();
   }
@@ -293,25 +298,26 @@ int safe_cond_timedwait(pthread_cond_t *cond, safe_mutex_t *mp,
   return error;
 }
 
+
 int safe_mutex_destroy(safe_mutex_t *mp, const char *file, uint line)
 {
   int error=0;
   if (!mp->file)
   {
     fprintf(stderr,
-        "safe_mutex: Trying to destroy unitialized mutex at %s, line %d\n",
-        file, line);
+	    "safe_mutex: Trying to destroy unitialized mutex at %s, line %d\n",
+	    file, line);
     fflush(stderr);
     abort();
   }
   if (mp->count != 0)
   {
     fprintf(stderr,"safe_mutex: Trying to destroy a mutex that was locked at %s, line %d at %s, line %d\n",
-        mp->file,mp->line, file, line);
+	    mp->file,mp->line, file, line);
     fflush(stderr);
     abort();
   }
-#ifdef __WIN__
+#ifdef __WIN__ 
   pthread_mutex_destroy(&mp->global);
   pthread_mutex_destroy(&mp->mutex);
 #else
@@ -348,6 +354,7 @@ int safe_mutex_destroy(safe_mutex_t *mp, const char *file, uint line)
   return error;
 }
 
+
 /*
   Free global resources and check that all mutex has been destroyed
 
@@ -381,7 +388,7 @@ void safe_mutex_end(FILE *file __attribute__((unused)))
     for (ptr= safe_mutex_root ; ptr ; ptr= ptr->next)
     {
       fprintf(file, "\tMutex initiated at line %4u in '%s'\n",
-          ptr->init_line, ptr->init_file);
+	      ptr->init_line, ptr->init_file);
       (void) fflush(file);
     }
   }
@@ -421,8 +428,8 @@ ulong mutex_delay(ulong delayloops)
   for (i = 0; i < delayloops * 50; i++)
     j += i;
 
-  return(j);
-}
+  return(j); 
+}	
 
 #define MY_PTHREAD_FASTMUTEX_SPINS 8
 #define MY_PTHREAD_FASTMUTEX_DELAY 4
@@ -433,11 +440,11 @@ int my_pthread_fastmutex_init(my_pthread_fastmutex_t *mp,
                               const pthread_mutexattr_t *attr)
 {
   if ((cpu_count > 1) && (attr == MY_MUTEX_INIT_FAST))
-    mp->spins= MY_PTHREAD_FASTMUTEX_SPINS;
+    mp->spins= MY_PTHREAD_FASTMUTEX_SPINS; 
   else
     mp->spins= 0;
   mp->rng_state= 1;
-  return pthread_mutex_init(&mp->mutex, attr);
+  return pthread_mutex_init(&mp->mutex, attr); 
 }
 
 /**
@@ -485,11 +492,12 @@ int my_pthread_fastmutex_lock(my_pthread_fastmutex_t *mp)
   return pthread_mutex_lock(&mp->mutex);
 }
 
+
 void fastmutex_global_init(void)
 {
 #ifdef _SC_NPROCESSORS_CONF
   cpu_count= sysconf(_SC_NPROCESSORS_CONF);
 #endif
 }
-
-#endif /* defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX) */
\ No newline at end of file
+  
+#endif /* defined(MY_PTHREAD_FASTMUTEX) && !defined(SAFE_MUTEX) */ 
diff --git a/dep/mysqllite/mysys/thr_rwlock.c b/dep/mysqllite/mysys/thr_rwlock.c
index b6a78bd..10ed9a7 100644
--- a/dep/mysqllite/mysys/thr_rwlock.c
+++ b/dep/mysqllite/mysys/thr_rwlock.c
@@ -60,19 +60,21 @@ static void check_srwlock_availability(void)
     "TryAcquireSRWLockShared");
 
   /*
-    We currently require TryAcquireSRWLockExclusive. This API is missing on
+    We currently require TryAcquireSRWLockExclusive. This API is missing on 
     Vista, this means SRWLock are only used starting with Win7.
 
-    If "trylock" usage for rwlocks is eliminated from server codebase (it is used
-    in a single place currently, in query cache), then SRWLock can be enabled on
-    Vista too. In this case  condition below needs to be changed to  e.g check
+    If "trylock" usage for rwlocks is eliminated from server codebase (it is used 
+    in a single place currently, in query cache), then SRWLock can be enabled on 
+    Vista too. In this case  condition below needs to be changed to  e.g check 
     for my_InitializeSRWLock.
   */
 
   if (my_TryAcquireSRWLockExclusive)
     have_srwlock= TRUE;
+
 }
 
+
 static int srw_init(my_rw_lock_t *rwp)
 {
   my_InitializeSRWLock(&rwp->srwlock);
@@ -80,19 +82,23 @@ static int srw_init(my_rw_lock_t *rwp)
   return 0;
 }
 
+
 static int srw_rdlock(my_rw_lock_t *rwp)
 {
   my_AcquireSRWLockShared(&rwp->srwlock);
   return 0;
 }
 
+
 static int srw_tryrdlock(my_rw_lock_t *rwp)
 {
+
   if (!my_TryAcquireSRWLockShared(&rwp->srwlock))
     return EBUSY;
   return 0;
 }
 
+
 static int srw_wrlock(my_rw_lock_t *rwp)
 {
   my_AcquireSRWLockExclusive(&rwp->srwlock);
@@ -100,6 +106,7 @@ static int srw_wrlock(my_rw_lock_t *rwp)
   return 0;
 }
 
+
 static int srw_trywrlock(my_rw_lock_t *rwp)
 {
   if (!my_TryAcquireSRWLockExclusive(&rwp->srwlock))
@@ -108,6 +115,7 @@ static int srw_trywrlock(my_rw_lock_t *rwp)
   return 0;
 }
 
+
 static int srw_unlock(my_rw_lock_t *rwp)
 {
   if (rwp->have_exclusive_srwlock)
@@ -172,8 +180,8 @@ int my_rw_init(my_rw_lock_t *rwp)
     Once initialization is used here rather than in my_init(), in order to
     - avoid  my_init() pitfalls- (undefined order in which initialization should
     run)
-    - be potentially useful C++ (static constructors)
-    - just to simplify  the API.
+    - be potentially useful C++ (static constructors) 
+    - just to simplify  the API. 
     Also, the overhead is of my_pthread_once is very small.
   */
   static my_pthread_once_t once_control= MY_PTHREAD_ONCE_INIT;
@@ -198,6 +206,7 @@ int my_rw_init(my_rw_lock_t *rwp)
   return(0);
 }
 
+
 int my_rw_destroy(my_rw_lock_t *rwp)
 {
 #ifdef _WIN32
@@ -211,6 +220,7 @@ int my_rw_destroy(my_rw_lock_t *rwp)
   return(0);
 }
 
+
 int my_rw_rdlock(my_rw_lock_t *rwp)
 {
 #ifdef _WIN32
@@ -250,6 +260,7 @@ int my_rw_tryrdlock(my_rw_lock_t *rwp)
   return(res);
 }
 
+
 int my_rw_wrlock(my_rw_lock_t *rwp)
 {
 #ifdef _WIN32
@@ -273,6 +284,7 @@ int my_rw_wrlock(my_rw_lock_t *rwp)
   return(0);
 }
 
+
 int my_rw_trywrlock(my_rw_lock_t *rwp)
 {
   int res;
@@ -284,7 +296,7 @@ int my_rw_trywrlock(my_rw_lock_t *rwp)
 
   pthread_mutex_lock(&rwp->lock);
   if (rwp->state)
-    res= EBUSY;					/* Can't get lock */
+    res= EBUSY;					/* Can't get lock */    
   else
   {
     res=0;
@@ -297,6 +309,7 @@ int my_rw_trywrlock(my_rw_lock_t *rwp)
   return(res);
 }
 
+
 int my_rw_unlock(my_rw_lock_t *rwp)
 {
 #ifdef _WIN32
@@ -305,7 +318,7 @@ int my_rw_unlock(my_rw_lock_t *rwp)
 #endif
 
   DBUG_PRINT("rw_unlock",
-         ("state: %d waiters: %d", rwp->state, rwp->waiters));
+	     ("state: %d waiters: %d", rwp->state, rwp->waiters));
   pthread_mutex_lock(&rwp->lock);
 
   DBUG_ASSERT(rwp->state != 0);
@@ -336,6 +349,7 @@ int my_rw_unlock(my_rw_lock_t *rwp)
 
 #endif /* defined(NEED_MY_RW_LOCK) */
 
+
 int rw_pr_init(rw_pr_lock_t *rwlock)
 {
   pthread_mutex_init(&rwlock->lock, NULL);
@@ -349,6 +363,7 @@ int rw_pr_init(rw_pr_lock_t *rwlock)
   return 0;
 }
 
+
 int rw_pr_destroy(rw_pr_lock_t *rwlock)
 {
   pthread_cond_destroy(&rwlock->no_active_readers);
@@ -356,6 +371,7 @@ int rw_pr_destroy(rw_pr_lock_t *rwlock)
   return 0;
 }
 
+
 int rw_pr_rdlock(rw_pr_lock_t *rwlock)
 {
   pthread_mutex_lock(&rwlock->lock);
@@ -370,6 +386,7 @@ int rw_pr_rdlock(rw_pr_lock_t *rwlock)
   return 0;
 }
 
+
 int rw_pr_wrlock(rw_pr_lock_t *rwlock)
 {
   pthread_mutex_lock(&rwlock->lock);
@@ -405,6 +422,7 @@ int rw_pr_wrlock(rw_pr_lock_t *rwlock)
   return 0;
 }
 
+
 int rw_pr_unlock(rw_pr_lock_t *rwlock)
 {
   if (rwlock->active_writer)
@@ -449,4 +467,6 @@ int rw_pr_unlock(rw_pr_lock_t *rwlock)
     pthread_mutex_unlock(&rwlock->lock);
   }
   return 0;
-}
\ No newline at end of file
+}
+
+
diff --git a/dep/mysqllite/mysys/tree.c b/dep/mysqllite/mysys/tree.c
index f101261..c5bf368 100644
--- a/dep/mysqllite/mysys/tree.c
+++ b/dep/mysqllite/mysys/tree.c
@@ -67,16 +67,17 @@
 
 static void delete_tree_element(TREE *,TREE_ELEMENT *);
 static int tree_walk_left_root_right(TREE *,TREE_ELEMENT *,
-                     tree_walk_action,void *);
+				     tree_walk_action,void *);
 static int tree_walk_right_root_left(TREE *,TREE_ELEMENT *,
-                     tree_walk_action,void *);
+				     tree_walk_action,void *);
 static void left_rotate(TREE_ELEMENT **parent,TREE_ELEMENT *leaf);
 static void right_rotate(TREE_ELEMENT **parent, TREE_ELEMENT *leaf);
 static void rb_insert(TREE *tree,TREE_ELEMENT ***parent,
-              TREE_ELEMENT *leaf);
+		      TREE_ELEMENT *leaf);
 static void rb_delete_fixup(TREE *tree,TREE_ELEMENT ***parent);
 
-    /* The actuall code for handling binary trees */
+
+	/* The actuall code for handling binary trees */
 
 #ifndef DBUG_OFF
 static int test_rb_tree(TREE_ELEMENT *element);
@@ -84,7 +85,7 @@ static void rb_insert(TREE *tree,TREE_ELEMENT ***parent,
 
 void init_tree(TREE *tree, ulong default_alloc_size, ulong memory_limit,
                int size, qsort_cmp2 compare, my_bool with_delete,
-           tree_element_free free_element, void *custom_arg)
+	       tree_element_free free_element, void *custom_arg)
 {
   DBUG_ENTER("init_tree");
   DBUG_PRINT("enter",("tree: 0x%lx  size: %d", (long) tree, size));
@@ -147,7 +148,7 @@ static void free_tree(TREE *tree, myf free_flags)
       {
         if (tree->memory_limit)
           (*tree->free)(NULL, free_init, tree->custom_arg);
-    delete_tree_element(tree,tree->root);
+	delete_tree_element(tree,tree->root);
         if (tree->memory_limit)
           (*tree->free)(NULL, free_end, tree->custom_arg);
       }
@@ -172,6 +173,7 @@ void reset_tree(TREE* tree)
   free_tree(tree, MYF(MY_MARK_BLOCKS_FREE));
 }
 
+
 static void delete_tree_element(TREE *tree, TREE_ELEMENT *element)
 {
   if (element != &tree->null_element)
@@ -185,6 +187,7 @@ static void delete_tree_element(TREE *tree, TREE_ELEMENT *element)
   }
 }
 
+
 /*
   insert, search and delete of elements
 
@@ -193,7 +196,7 @@ static void delete_tree_element(TREE *tree, TREE_ELEMENT *element)
     parent[0] = & parent[-1][0]->right
 */
 
-TREE_ELEMENT *tree_insert(TREE *tree, void *key, uint key_size,
+TREE_ELEMENT *tree_insert(TREE *tree, void *key, uint key_size, 
                           void* custom_arg)
 {
   int cmp;
@@ -204,7 +207,7 @@ TREE_ELEMENT *tree_insert(TREE *tree, void *key, uint key_size,
   for (;;)
   {
     if (element == &tree->null_element ||
-    (cmp = (*tree->compare)(custom_arg, ELEMENT_KEY(tree,element),
+	(cmp = (*tree->compare)(custom_arg, ELEMENT_KEY(tree,element),
                                 key)) == 0)
       break;
     if (cmp < 0)
@@ -240,12 +243,12 @@ TREE_ELEMENT *tree_insert(TREE *tree, void *key, uint key_size,
     if (!tree->offset_to_key)
     {
       if (key_size == sizeof(void*))		 /* no length, save pointer */
-    *((void**) (element+1))=key;
+	*((void**) (element+1))=key;
       else
       {
-    *((void**) (element+1))= (void*) ((void **) (element+1)+1);
-    memcpy((uchar*) *((void **) (element+1)),key,
-           (size_t) (key_size-sizeof(void*)));
+	*((void**) (element+1))= (void*) ((void **) (element+1)+1);
+	memcpy((uchar*) *((void **) (element+1)),key,
+	       (size_t) (key_size-sizeof(void*)));
       }
     }
     else
@@ -328,6 +331,7 @@ int tree_delete(TREE *tree, void *key, uint key_size, void *custom_arg)
   return 0;
 }
 
+
 void *tree_search(TREE *tree, void *key, void *custom_arg)
 {
   int cmp;
@@ -347,7 +351,7 @@ void *tree_search(TREE *tree, void *key, void *custom_arg)
   }
 }
 
-void *tree_search_key(TREE *tree, const void *key,
+void *tree_search_key(TREE *tree, const void *key, 
                       TREE_ELEMENT **parents, TREE_ELEMENT ***last_pos,
                       enum ha_rkey_function flag, void *custom_arg)
 {
@@ -356,7 +360,7 @@ void *tree_search_key(TREE *tree, const void *key,
   TREE_ELEMENT **last_left_step_parent= NULL, **last_right_step_parent= NULL;
   TREE_ELEMENT **last_equal_element= NULL;
 
-/*
+/* 
   TODO: support for HA_READ_KEY_OR_PREV, HA_READ_PREFIX flags if needed.
 */
 
@@ -364,26 +368,26 @@ void *tree_search_key(TREE *tree, const void *key,
   while (element != &tree->null_element)
   {
     *++parents= element;
-    if ((cmp= (*tree->compare)(custom_arg, ELEMENT_KEY(tree, element),
-                   key)) == 0)
+    if ((cmp= (*tree->compare)(custom_arg, ELEMENT_KEY(tree, element), 
+			       key)) == 0)
     {
       switch (flag) {
       case HA_READ_KEY_EXACT:
       case HA_READ_KEY_OR_NEXT:
       case HA_READ_BEFORE_KEY:
-    last_equal_element= parents;
-    cmp= 1;
-    break;
+	last_equal_element= parents;
+	cmp= 1;
+	break;
       case HA_READ_AFTER_KEY:
-    cmp= -1;
-    break;
+	cmp= -1;
+	break;
       case HA_READ_PREFIX_LAST:
       case HA_READ_PREFIX_LAST_OR_PREV:
-    last_equal_element= parents;
-    cmp= -1;
-    break;
+	last_equal_element= parents;
+	cmp= -1;
+	break;
       default:
-    return NULL;
+	return NULL;
       }
     }
     if (cmp < 0) /* element < key */
@@ -420,14 +424,14 @@ void *tree_search_key(TREE *tree, const void *key,
   return *last_pos ? ELEMENT_KEY(tree, **last_pos) : NULL;
 }
 
-/*
-  Search first (the most left) or last (the most right) tree element
+/* 
+  Search first (the most left) or last (the most right) tree element 
 */
-void *tree_search_edge(TREE *tree, TREE_ELEMENT **parents,
-               TREE_ELEMENT ***last_pos, int child_offs)
+void *tree_search_edge(TREE *tree, TREE_ELEMENT **parents, 
+		       TREE_ELEMENT ***last_pos, int child_offs)
 {
   TREE_ELEMENT *element= tree->root;
-
+  
   *parents= &tree->null_element;
   while (element != &tree->null_element)
   {
@@ -435,15 +439,15 @@ void *tree_search_edge(TREE *tree, TREE_ELEMENT **parents,
     element= ELEMENT_CHILD(element, child_offs);
   }
   *last_pos= parents;
-  return **last_pos != &tree->null_element ?
+  return **last_pos != &tree->null_element ? 
     ELEMENT_KEY(tree, **last_pos) : NULL;
 }
 
-void *tree_search_next(TREE *tree, TREE_ELEMENT ***last_pos, int l_offs,
+void *tree_search_next(TREE *tree, TREE_ELEMENT ***last_pos, int l_offs, 
                        int r_offs)
 {
   TREE_ELEMENT *x= **last_pos;
-
+  
   if (ELEMENT_CHILD(x, r_offs) != &tree->null_element)
   {
     x= ELEMENT_CHILD(x, r_offs);
@@ -471,8 +475,8 @@ void *tree_search_next(TREE *tree, TREE_ELEMENT ***last_pos, int l_offs,
   Expected that tree is fully balanced
   (each path from root to leaf has the same length)
 */
-ha_rows tree_record_pos(TREE *tree, const void *key,
-            enum ha_rkey_function flag, void *custom_arg)
+ha_rows tree_record_pos(TREE *tree, const void *key, 
+			enum ha_rkey_function flag, void *custom_arg)
 {
   int cmp;
   TREE_ELEMENT *element= tree->root;
@@ -481,8 +485,8 @@ ha_rows tree_record_pos(TREE *tree, const void *key,
 
   while (element != &tree->null_element)
   {
-    if ((cmp= (*tree->compare)(custom_arg, ELEMENT_KEY(tree, element),
-                   key)) == 0)
+    if ((cmp= (*tree->compare)(custom_arg, ELEMENT_KEY(tree, element), 
+			       key)) == 0)
     {
       switch (flag) {
       case HA_READ_KEY_EXACT:
@@ -535,10 +539,10 @@ static int tree_walk_left_root_right(TREE *tree, TREE_ELEMENT *element, tree_wal
   if (element->left)				/* Not null_element */
   {
     if ((error=tree_walk_left_root_right(tree,element->left,action,
-                      argument)) == 0 &&
-    (error=(*action)(ELEMENT_KEY(tree,element),
-              (element_count) element->count,
-              argument)) == 0)
+					  argument)) == 0 &&
+	(error=(*action)(ELEMENT_KEY(tree,element),
+			  (element_count) element->count,
+			  argument)) == 0)
       error=tree_walk_left_root_right(tree,element->right,action,argument);
     return error;
   }
@@ -551,17 +555,18 @@ static int tree_walk_right_root_left(TREE *tree, TREE_ELEMENT *element, tree_wal
   if (element->right)				/* Not null_element */
   {
     if ((error=tree_walk_right_root_left(tree,element->right,action,
-                      argument)) == 0 &&
-    (error=(*action)(ELEMENT_KEY(tree,element),
-              (element_count) element->count,
-              argument)) == 0)
+					  argument)) == 0 &&
+	(error=(*action)(ELEMENT_KEY(tree,element),
+			  (element_count) element->count,
+			  argument)) == 0)
      error=tree_walk_right_root_left(tree,element->left,action,argument);
     return error;
   }
   return 0;
 }
 
-    /* Functions to fix up the tree after insert and delete */
+
+	/* Functions to fix up the tree after insert and delete */
 
 static void left_rotate(TREE_ELEMENT **parent, TREE_ELEMENT *leaf)
 {
@@ -595,23 +600,23 @@ static void rb_insert(TREE *tree, TREE_ELEMENT ***parent, TREE_ELEMENT *leaf)
       y= par2->right;
       if (y->colour == RED)
       {
-    par->colour=BLACK;
-    y->colour=BLACK;
-    leaf=par2;
-    parent-=2;
-    leaf->colour=RED;		/* And the loop continues */
+	par->colour=BLACK;
+	y->colour=BLACK;
+	leaf=par2;
+	parent-=2;
+	leaf->colour=RED;		/* And the loop continues */
       }
       else
       {
-    if (leaf == par->right)
-    {
-      left_rotate(parent[-1],par);
-      par=leaf;			/* leaf is now parent to old leaf */
-    }
-    par->colour=BLACK;
-    par2->colour=RED;
-    right_rotate(parent[-2],par2);
-    break;
+	if (leaf == par->right)
+	{
+	  left_rotate(parent[-1],par);
+	  par=leaf;			/* leaf is now parent to old leaf */
+	}
+	par->colour=BLACK;
+	par2->colour=RED;
+	right_rotate(parent[-2],par2);
+	break;
       }
     }
     else
@@ -619,23 +624,23 @@ static void rb_insert(TREE *tree, TREE_ELEMENT ***parent, TREE_ELEMENT *leaf)
       y= par2->left;
       if (y->colour == RED)
       {
-    par->colour=BLACK;
-    y->colour=BLACK;
-    leaf=par2;
-    parent-=2;
-    leaf->colour=RED;		/* And the loop continues */
+	par->colour=BLACK;
+	y->colour=BLACK;
+	leaf=par2;
+	parent-=2;
+	leaf->colour=RED;		/* And the loop continues */
       }
       else
       {
-    if (leaf == par->left)
-    {
-      right_rotate(parent[-1],par);
-      par=leaf;
-    }
-    par->colour=BLACK;
-    par2->colour=RED;
-    left_rotate(parent[-2],par2);
-    break;
+	if (leaf == par->left)
+	{
+	  right_rotate(parent[-1],par);
+	  par=leaf;
+	}
+	par->colour=BLACK;
+	par2->colour=RED;
+	left_rotate(parent[-2],par2);
+	break;
       }
     }
   }
@@ -654,34 +659,34 @@ static void rb_delete_fixup(TREE *tree, TREE_ELEMENT ***parent)
       w=par->right;
       if (w->colour == RED)
       {
-    w->colour=BLACK;
-    par->colour=RED;
-    left_rotate(parent[-1],par);
-    parent[0]= &w->left;
-    *++parent= &par->left;
-    w=par->right;
+	w->colour=BLACK;
+	par->colour=RED;
+	left_rotate(parent[-1],par);
+	parent[0]= &w->left;
+	*++parent= &par->left;
+	w=par->right;
       }
       if (w->left->colour == BLACK && w->right->colour == BLACK)
       {
-    w->colour=RED;
-    x=par;
-    parent--;
+	w->colour=RED;
+	x=par;
+	parent--;
       }
       else
       {
-    if (w->right->colour == BLACK)
-    {
-      w->left->colour=BLACK;
-      w->colour=RED;
-      right_rotate(&par->right,w);
-      w=par->right;
-    }
-    w->colour=par->colour;
-    par->colour=BLACK;
-    w->right->colour=BLACK;
-    left_rotate(parent[-1],par);
-    x=tree->root;
-    break;
+	if (w->right->colour == BLACK)
+	{
+	  w->left->colour=BLACK;
+	  w->colour=RED;
+	  right_rotate(&par->right,w);
+	  w=par->right;
+	}
+	w->colour=par->colour;
+	par->colour=BLACK;
+	w->right->colour=BLACK;
+	left_rotate(parent[-1],par);
+	x=tree->root;
+	break;
       }
     }
     else
@@ -689,34 +694,34 @@ static void rb_delete_fixup(TREE *tree, TREE_ELEMENT ***parent)
       w=par->left;
       if (w->colour == RED)
       {
-    w->colour=BLACK;
-    par->colour=RED;
-    right_rotate(parent[-1],par);
-    parent[0]= &w->right;
-    *++parent= &par->right;
-    w=par->left;
+	w->colour=BLACK;
+	par->colour=RED;
+	right_rotate(parent[-1],par);
+	parent[0]= &w->right;
+	*++parent= &par->right;
+	w=par->left;
       }
       if (w->right->colour == BLACK && w->left->colour == BLACK)
       {
-    w->colour=RED;
-    x=par;
-    parent--;
+	w->colour=RED;
+	x=par;
+	parent--;
       }
       else
       {
-    if (w->left->colour == BLACK)
-    {
-      w->right->colour=BLACK;
-      w->colour=RED;
-      left_rotate(&par->left,w);
-      w=par->left;
-    }
-    w->colour=par->colour;
-    par->colour=BLACK;
-    w->left->colour=BLACK;
-    right_rotate(parent[-1],par);
-    x=tree->root;
-    break;
+	if (w->left->colour == BLACK)
+	{
+	  w->right->colour=BLACK;
+	  w->colour=RED;
+	  left_rotate(&par->left,w);
+	  w=par->left;
+	}
+	w->colour=par->colour;
+	par->colour=BLACK;
+	w->left->colour=BLACK;
+	right_rotate(parent[-1],par);
+	x=tree->root;
+	break;
       }
     }
   }
@@ -725,7 +730,7 @@ static void rb_delete_fixup(TREE *tree, TREE_ELEMENT ***parent)
 
 #ifndef DBUG_OFF
 
-    /* Test that the proporties for a red-black tree holds */
+	/* Test that the proporties for a red-black tree holds */
 
 static int test_rb_tree(TREE_ELEMENT *element)
 {
@@ -749,4 +754,4 @@ static int test_rb_tree(TREE_ELEMENT *element)
   }
   return -1;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/mysys/typelib.c b/dep/mysqllite/mysys/typelib.c
index 50563a1..c0d37e2 100644
--- a/dep/mysqllite/mysys/typelib.c
+++ b/dep/mysqllite/mysys/typelib.c
@@ -19,6 +19,7 @@
 #include <m_string.h>
 #include <m_ctype.h>
 
+
 #define is_field_separator(X) ((X) == ',' || (X) == '=')
 
 int find_type_or_exit(const char *x, TYPELIB *typelib, const char *option)
@@ -42,6 +43,7 @@ int find_type_or_exit(const char *x, TYPELIB *typelib, const char *option)
   return res;
 }
 
+
 /**
   Search after a string in a list of strings. Endspace in x is not compared.
 
@@ -62,6 +64,7 @@ int find_type_or_exit(const char *x, TYPELIB *typelib, const char *option)
     >0  Offset+1 in typelib for matched string
 */
 
+
 int find_type(const char *x, const TYPELIB *typelib, uint flags)
 {
   int find,pos;
@@ -81,16 +84,16 @@ int find_type(const char *x, const TYPELIB *typelib, uint flags)
   find=0;
   for (pos=0 ; (j=typelib->type_names[pos]) ; pos++)
   {
-    for (i=x ;
-        *i && (!(flags & FIND_TYPE_COMMA_TERM) || !is_field_separator(*i)) &&
-        my_toupper(&my_charset_latin1,*i) ==
-            my_toupper(&my_charset_latin1,*j) ; i++, j++) ;
+    for (i=x ; 
+    	*i && (!(flags & FIND_TYPE_COMMA_TERM) || !is_field_separator(*i)) &&
+        my_toupper(&my_charset_latin1,*i) == 
+    		my_toupper(&my_charset_latin1,*j) ; i++, j++) ;
     if (! *j)
     {
       while (*i == ' ')
-    i++;					/* skip_end_space */
+	i++;					/* skip_end_space */
       if (! *i || ((flags & FIND_TYPE_COMMA_TERM) && is_field_separator(*i)))
-    DBUG_RETURN(pos+1);
+	DBUG_RETURN(pos+1);
     }
     if ((!*i &&
          (!(flags & FIND_TYPE_COMMA_TERM) || !is_field_separator(*i))) &&
@@ -117,15 +120,16 @@ int find_type(const char *x, const TYPELIB *typelib, uint flags)
   DBUG_RETURN(findpos+1);
 } /* find_type */
 
+
 /**
   Get name of type nr
-
+ 
   @note
   first type is 1, 0 = empty field
 */
 
 void make_type(register char * to, register uint nr,
-           register TYPELIB *typelib)
+	       register TYPELIB *typelib)
 {
   DBUG_ENTER("make_type");
   if (!nr)
@@ -135,6 +139,7 @@ void make_type(register char * to, register uint nr,
   DBUG_VOID_RETURN;
 } /* make_type */
 
+
 /**
   Get type
 
@@ -149,13 +154,14 @@ const char *get_type(TYPELIB *typelib, uint nr)
   return "?";
 }
 
+
 /**
   Create an integer value to represent the supplied comma-seperated
   string where each string in the TYPELIB denotes a bit position.
 
   @param x      string to decompose
   @param lib    TYPELIB (struct of pointer to values + count)
-  @param err    index (not char position) of string element which was not
+  @param err    index (not char position) of string element which was not 
                 found or 0 if there was no error
 
   @retval
@@ -193,6 +199,7 @@ my_ulonglong find_typeset(char *x, TYPELIB *lib, int *err)
   DBUG_RETURN(result);
 } /* find_set */
 
+
 /**
   Create a copy of a specified TYPELIB structure.
 
@@ -242,6 +249,7 @@ TYPELIB *copy_typelib(MEM_ROOT *root, TYPELIB *from)
   return to;
 }
 
+
 static const char *on_off_default_names[]= { "off","on","default", 0};
 static TYPELIB on_off_default_typelib= {array_elements(on_off_default_names)-1,
                                         "", on_off_default_names, 0};
@@ -290,14 +298,14 @@ static uint parse_name(const TYPELIB *lib, const char **strpos, const char *end)
   @details
   Parse a set of flag assignments, that is, parse a string in form:
 
-    param_name1=value1,param_name2=value2,...
-
+    param_name1=value1,param_name2=value2,... 
+  
   where the names are specified in the TYPELIB, and each value can be
-  either 'on','off', or 'default'. Setting the same name twice is not
+  either 'on','off', or 'default'. Setting the same name twice is not 
   allowed.
-
-  Besides param=val assignments, we support the "default" keyword (keyword
-  #default_name in the typelib). It can be used one time, if specified it
+  
+  Besides param=val assignments, we support the "default" keyword (keyword 
+  #default_name in the typelib). It can be used one time, if specified it 
   causes us to build the new set over the default_set rather than cur_set
   value.
 
@@ -320,7 +328,7 @@ my_ulonglong find_set_from_flags(const TYPELIB *lib, uint default_name,
   *err_pos= 0;                  /* No error yet */
   if (str != end)
   {
-    const char *start= str;
+    const char *start= str;    
     for (;;)
     {
       const char *pos= start;
@@ -344,7 +352,7 @@ my_ulonglong find_set_from_flags(const TYPELIB *lib, uint default_name,
             pos >= end || *pos++ != '=' ||
             !(value= parse_name(&on_off_default_typelib, &pos, end)))
           goto err;
-
+        
         if (value == 1) /* this is '=off' */
           flags_to_clear|= bit;
         else if (value == 2) /* this is '=on' */
@@ -375,4 +383,5 @@ my_ulonglong find_set_from_flags(const TYPELIB *lib, uint default_name,
   res|= flags_to_set;
   res&= ~flags_to_clear;
   return res;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/sql-common/client.c b/dep/mysqllite/sql-common/client.c
index cfcf721..ef1e3c1 100644
--- a/dep/mysqllite/sql-common/client.c
+++ b/dep/mysqllite/sql-common/client.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -25,13 +25,13 @@
   - Support for reading local file with LOAD DATA LOCAL
   - SHARED memory handling
   - Prepared statements
-
+  
   - Things that only works for the server
   - Alarm handling on connect
-
+  
   In all other cases, the code should be idential for the client and
   server.
-*/
+*/ 
 
 #include <my_global.h>
 
@@ -114,6 +114,7 @@
 #define native_password_plugin_name "mysql_native_password"
 #define old_password_plugin_name    "mysql_old_password"
 
+
 uint		mysql_port=0;
 char		*mysql_unix_port= 0;
 const char	*unknown_sqlstate= "HY000";
@@ -148,7 +149,7 @@
 *****************************************************************************/
 
 int my_connect(my_socket fd, const struct sockaddr *name, uint namelen,
-           uint timeout)
+	       uint timeout)
 {
 #if defined(__WIN__)
   DBUG_ENTER("my_connect");
@@ -187,6 +188,7 @@ int my_connect(my_socket fd, const struct sockaddr *name, uint namelen,
 #endif
 }
 
+
 /*
   Wait up to timeout seconds for a connection to be established.
 
@@ -260,11 +262,11 @@ static int wait_for_data(my_socket fd, uint timeout)
     If select() returns 0 (after waiting howevermany seconds), our socket
     never became writable (host is probably unreachable.)  Otherwise, if
     select() returns 1, then one of two conditions exist:
-
+   
     1. An error occured.  We use getsockopt() to check for this.
     2. The connection was set up sucessfully: getsockopt() will
     return 0 as an error.
-
+   
     Thanks goes to Andrew Gierth <andrew@erlenstar.demon.co.uk>
     who posted this method of timing out a connect() in
     comp.unix.programmer on August 15th, 1997.
@@ -273,9 +275,9 @@ static int wait_for_data(my_socket fd, uint timeout)
   FD_ZERO(&sfds);
   FD_SET(fd, &sfds);
   /*
-    select could be interrupted by a signal, and if it is,
+    select could be interrupted by a signal, and if it is, 
     the timeout should be adjusted and the select restarted
-    to work around OSes that don't restart select and
+    to work around OSes that don't restart select and 
     implementations of select that don't adjust tv upon
     failure to reflect the time remaining
    */
@@ -395,6 +397,8 @@ void set_mysql_extended_error(MYSQL *mysql, int errcode,
   DBUG_VOID_RETURN;
 }
 
+
+
 /*
   Create a named pipe connection
 */
@@ -402,7 +406,7 @@ void set_mysql_extended_error(MYSQL *mysql, int errcode,
 #ifdef __WIN__
 
 HANDLE create_named_pipe(MYSQL *mysql, uint connect_timeout, char **arg_host,
-             char **arg_unix_socket)
+			 char **arg_unix_socket)
 {
   HANDLE hPipe=INVALID_HANDLE_VALUE;
   char pipe_name[1024];
@@ -416,20 +420,21 @@ HANDLE create_named_pipe(MYSQL *mysql, uint connect_timeout, char **arg_host,
   if (!host || !strcmp(host,LOCAL_HOST))
     host=LOCAL_HOST_NAMEDPIPE;
 
+  
   pipe_name[sizeof(pipe_name)-1]= 0;		/* Safety if too long string */
   strxnmov(pipe_name, sizeof(pipe_name)-1, "\\\\", host, "\\pipe\\",
-       unix_socket, NullS);
+	   unix_socket, NullS);
   DBUG_PRINT("info",("Server name: '%s'.  Named Pipe: %s", host, unix_socket));
 
   for (i=0 ; i < 100 ; i++)			/* Don't retry forever */
   {
     if ((hPipe = CreateFile(pipe_name,
-                GENERIC_READ | GENERIC_WRITE,
-                0,
-                NULL,
-                OPEN_EXISTING,
-                FILE_FLAG_OVERLAPPED,
-                NULL )) != INVALID_HANDLE_VALUE)
+			    GENERIC_READ | GENERIC_WRITE,
+			    0,
+			    NULL,
+			    OPEN_EXISTING,
+			    FILE_FLAG_OVERLAPPED,
+			    NULL )) != INVALID_HANDLE_VALUE)
       break;
     if (GetLastError() != ERROR_PIPE_BUSY)
     {
@@ -468,6 +473,7 @@ HANDLE create_named_pipe(MYSQL *mysql, uint connect_timeout, char **arg_host,
 }
 #endif
 
+
 /*
   Create new shared memory connection, return handler of connection
 
@@ -570,7 +576,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
     goto err;
   }
   if (!(handle_connect_map= MapViewOfFile(handle_connect_file_map,
-                      FILE_MAP_WRITE,0,0,sizeof(DWORD))))
+					  FILE_MAP_WRITE,0,0,sizeof(DWORD))))
   {
     error_allow = CR_SHARED_MEMORY_CONNECT_MAP_ERROR;
     goto err;
@@ -605,7 +611,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
     number_of_connection is number of connection between server and client
   */
   suffix_pos = strxmov(tmp, prefix , shared_memory_base_name, "_", connect_number_char,
-               "_", NullS);
+		       "_", NullS);
   strmov(suffix_pos, "DATA");
   if ((handle_file_map = OpenFileMapping(FILE_MAP_WRITE,FALSE,tmp)) == NULL)
   {
@@ -613,7 +619,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
     goto err2;
   }
   if ((handle_map = MapViewOfFile(handle_file_map,FILE_MAP_WRITE,0,0,
-                  smem_buffer_length)) == NULL)
+				  smem_buffer_length)) == NULL)
   {
     error_allow = CR_SHARED_MEMORY_MAP_ERROR;
     goto err2;
@@ -716,7 +722,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
 
   @retval  packet_error    An error occurred during reading.
                            Error message is set.
-  @retval
+  @retval  
 */
 
 ulong
@@ -731,7 +737,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
   if (len == packet_error || len == 0)
   {
     DBUG_PRINT("error",("Wrong connection or packet. fd: %s  len: %lu",
-            vio_description(net->vio),len));
+			vio_description(net->vio),len));
 #ifdef MYSQL_SERVER
     if (net->vio && vio_was_interrupted(net->vio))
       return (packet_error);
@@ -751,8 +757,8 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
       len-=2;
       if (protocol_41(mysql) && pos[0] == '#')
       {
-    strmake(net->sqlstate, pos+1, SQLSTATE_LENGTH);
-    pos+= SQLSTATE_LENGTH+1;
+	strmake(net->sqlstate, pos+1, SQLSTATE_LENGTH);
+	pos+= SQLSTATE_LENGTH+1;
       }
       else
       {
@@ -765,7 +771,7 @@ HANDLE create_shared_memory(MYSQL *mysql,NET *net, uint connect_timeout)
       }
 
       (void) strmake(net->last_error,(char*) pos,
-             min((uint) len,(uint) sizeof(net->last_error)-1));
+		     min((uint) len,(uint) sizeof(net->last_error)-1));
     }
     else
       set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
@@ -800,8 +806,8 @@ void free_rows(MYSQL_DATA *cur)
 
 my_bool
 cli_advanced_command(MYSQL *mysql, enum enum_server_command command,
-             const uchar *header, ulong header_length,
-             const uchar *arg, ulong arg_length, my_bool skip_check,
+		     const uchar *header, ulong header_length,
+		     const uchar *arg, ulong arg_length, my_bool skip_check,
                      MYSQL_STMT *stmt)
 {
   NET *net= &mysql->net;
@@ -833,10 +839,10 @@ void free_rows(MYSQL_DATA *cur)
   net_clear(&mysql->net, (command != COM_QUIT));
 
   if (net_write_command(net,(uchar) command, header, header_length,
-            arg, arg_length))
+			arg, arg_length))
   {
     DBUG_PRINT("error",("Can't send command to server. Error: %d",
-            socket_errno));
+			socket_errno));
     if (net->last_errno == ER_NET_PACKET_TOO_LARGE)
     {
       set_mysql_error(mysql, CR_NET_PACKET_TOO_LARGE, unknown_sqlstate);
@@ -846,7 +852,7 @@ void free_rows(MYSQL_DATA *cur)
     if (mysql_reconnect(mysql) || stmt_skip)
       goto end;
     if (net_write_command(net,(uchar) command, header, header_length,
-              arg, arg_length))
+			  arg, arg_length))
     {
       set_mysql_error(mysql, CR_SERVER_GONE_ERROR, unknown_sqlstate);
       goto end;
@@ -855,7 +861,7 @@ void free_rows(MYSQL_DATA *cur)
   result=0;
   if (!skip_check)
     result= ((mysql->packet_length=cli_safe_read(mysql)) == packet_error ?
-         1 : 0);
+	     1 : 0);
 end:
   DBUG_PRINT("exit",("result: %d", result));
   DBUG_RETURN(result);
@@ -874,6 +880,7 @@ void free_old_query(MYSQL *mysql)
   DBUG_VOID_RETURN;
 }
 
+
 /**
   Finish reading of a partial result set from the server.
   Get the EOF packet, and update mysql->status
@@ -919,10 +926,11 @@ my_bool flush_one_result(MYSQL *mysql)
   return FALSE;
 }
 
+
 /**
   Read a packet from network. If it's an OK packet, flush it.
 
-  @return  TRUE if error, FALSE otherwise. In case of
+  @return  TRUE if error, FALSE otherwise. In case of 
            success, is_ok_packet is set to TRUE or FALSE,
            based on what we got from network.
 */
@@ -957,6 +965,7 @@ my_bool opt_flush_ok_packet(MYSQL *mysql, my_bool *is_ok_packet)
   return FALSE;
 }
 
+
 /*
   Flush result set sent from server
 */
@@ -1000,6 +1009,7 @@ static void cli_flush_use_result(MYSQL *mysql, my_bool flush_all_results)
   DBUG_VOID_RETURN;
 }
 
+
 #ifdef __WIN__
 static my_bool is_NT(void)
 {
@@ -1008,6 +1018,7 @@ static my_bool is_NT(void)
 }
 #endif
 
+
 #ifdef CHECK_LICENSE
 /**
   Check server side variable 'license'.
@@ -1040,7 +1051,7 @@ static int check_license(MYSQL *mysql)
   if (!(res= mysql_use_result(mysql)))
     return 1;
   row= mysql_fetch_row(res);
-  /*
+  /* 
     If no rows in result set, or column value is NULL (none of these
     two is ever true for server variables now), or column value
     mismatch, set wrong license error.
@@ -1057,6 +1068,7 @@ static int check_license(MYSQL *mysql)
 }
 #endif /* CHECK_LICENSE */
 
+
 /**************************************************************************
   Shut down connection
 **************************************************************************/
@@ -1081,6 +1093,7 @@ void end_server(MYSQL *mysql)
   DBUG_VOID_RETURN;
 }
 
+
 void STDCALL
 mysql_free_result(MYSQL_RES *result)
 {
@@ -1123,28 +1136,30 @@ void end_server(MYSQL *mysql)
   "connect-timeout", "local-infile", "disable-local-infile",
   "ssl-cipher", "max-allowed-packet", "protocol", "shared-memory-base-name",
   "multi-results", "multi-statements", "multi-queries", "secure-auth",
-  "report-data-truncation", "plugin-dir", "default-auth",
+  "report-data-truncation", "plugin-dir", "default-auth", 
+  "enable-cleartext-plugin",
   NullS
 };
 enum option_id {
-  OPT_port=1, OPT_socket, OPT_compress, OPT_password, OPT_pipe, OPT_timeout, OPT_user,
-  OPT_init_command, OPT_host, OPT_database, OPT_debug, OPT_return_found_rows,
-  OPT_ssl_key, OPT_ssl_cert, OPT_ssl_ca, OPT_ssl_capath,
-  OPT_character_sets_dir, OPT_default_character_set, OPT_interactive_timeout,
-  OPT_connect_timeout, OPT_local_infile, OPT_disable_local_infile,
-  OPT_ssl_cipher, OPT_max_allowed_packet, OPT_protocol, OPT_shared_memory_base_name,
-  OPT_multi_results, OPT_multi_statements, OPT_multi_queries, OPT_secure_auth,
-  OPT_report_data_truncation, OPT_plugin_dir, OPT_default_auth,
+  OPT_port=1, OPT_socket, OPT_compress, OPT_password, OPT_pipe, OPT_timeout, OPT_user, 
+  OPT_init_command, OPT_host, OPT_database, OPT_debug, OPT_return_found_rows, 
+  OPT_ssl_key, OPT_ssl_cert, OPT_ssl_ca, OPT_ssl_capath, 
+  OPT_character_sets_dir, OPT_default_character_set, OPT_interactive_timeout, 
+  OPT_connect_timeout, OPT_local_infile, OPT_disable_local_infile, 
+  OPT_ssl_cipher, OPT_max_allowed_packet, OPT_protocol, OPT_shared_memory_base_name, 
+  OPT_multi_results, OPT_multi_statements, OPT_multi_queries, OPT_secure_auth, 
+  OPT_report_data_truncation, OPT_plugin_dir, OPT_default_auth, 
+  OPT_enable_cleartext_plugin,
   OPT_keep_this_one_last
 };
 
 static TYPELIB option_types={array_elements(default_options)-1,
-                 "options",default_options, NULL};
+			     "options",default_options, NULL};
 
 const char *sql_protocol_names_lib[] =
 { "TCP", "SOCKET", "PIPE", "MEMORY", NullS };
 TYPELIB sql_protocol_typelib = {array_elements(sql_protocol_names_lib)-1,"",
-                sql_protocol_names_lib, NULL};
+				sql_protocol_names_lib, NULL};
 
 static int add_init_command(struct st_mysql_options *options, const char *cmd)
 {
@@ -1153,7 +1168,7 @@ static int add_init_command(struct st_mysql_options *options, const char *cmd)
   if (!options->init_commands)
   {
     options->init_commands= (DYNAMIC_ARRAY*)my_malloc(sizeof(DYNAMIC_ARRAY),
-                              MYF(MY_WME));
+						      MYF(MY_WME));
     init_dynamic_array(options->init_commands,sizeof(char*),0,5);
   }
 
@@ -1167,17 +1182,30 @@ static int add_init_command(struct st_mysql_options *options, const char *cmd)
   return 0;
 }
 
-#define EXTENSION_SET_STRING(OPTS, X, STR)                       \
-    if ((OPTS)->extension)                                       \
-      my_free((OPTS)->extension->X);     \
-    else                                                         \
+#define ALLOCATE_EXTENSIONS(OPTS)                                \
       (OPTS)->extension= (struct st_mysql_options_extention *)   \
         my_malloc(sizeof(struct st_mysql_options_extention),     \
-                  MYF(MY_WME | MY_ZEROFILL));                    \
-    (OPTS)->extension->X= my_strdup((STR), MYF(MY_WME));
+                  MYF(MY_WME | MY_ZEROFILL))                     \
+
+#define ENSURE_EXTENSIONS_PRESENT(OPTS)                          \
+    do {                                                         \
+      if (!(OPTS)->extension)                                    \
+        ALLOCATE_EXTENSIONS(OPTS);                               \
+    } while (0)
+
+
+#define EXTENSION_SET_STRING(OPTS, X, STR)                       \
+    do {                                                         \
+      if ((OPTS)->extension)                                     \
+        my_free((OPTS)->extension->X);                           \
+      else                                                       \
+        ALLOCATE_EXTENSIONS(OPTS);                               \
+      (OPTS)->extension->X= ((STR) != NULL) ?                    \
+        my_strdup((STR), MYF(MY_WME)) : NULL;                    \
+    } while (0)
 
 void mysql_read_default_options(struct st_mysql_options *options,
-                const char *filename,const char *group)
+				const char *filename,const char *group)
 {
   int argc;
   char *argv_buff[1],**argv;
@@ -1202,93 +1230,93 @@ void mysql_read_default_options(struct st_mysql_options *options,
       /* DBUG_PRINT("info",("option: %s",option[0])); */
       if (option[0][0] == '-' && option[0][1] == '-')
       {
-    char *end=strcend(*option,'=');
-    char *opt_arg=0;
-    if (*end)
-    {
-      opt_arg=end+1;
-      *end=0;				/* Remove '=' */
-    }
-    /* Change all '_' in variable name to '-' */
-    for (end= *option ; *(end= strcend(end,'_')) ; )
-      *end= '-';
-    switch (find_type(*option + 2, &option_types, FIND_TYPE_BASIC)) {
-    case OPT_port:
-      if (opt_arg)
-        options->port=atoi(opt_arg);
-      break;
-    case OPT_socket:
-      if (opt_arg)
-      {
-        my_free(options->unix_socket);
-        options->unix_socket=my_strdup(opt_arg,MYF(MY_WME));
-      }
-      break;
-    case OPT_compress:
-      options->compress=1;
-      options->client_flag|= CLIENT_COMPRESS;
-      break;
+	char *end=strcend(*option,'=');
+	char *opt_arg=0;
+	if (*end)
+	{
+	  opt_arg=end+1;
+	  *end=0;				/* Remove '=' */
+	}
+	/* Change all '_' in variable name to '-' */
+	for (end= *option ; *(end= strcend(end,'_')) ; )
+	  *end= '-';
+	switch (find_type(*option + 2, &option_types, FIND_TYPE_BASIC)) {
+	case OPT_port:
+	  if (opt_arg)
+	    options->port=atoi(opt_arg);
+	  break;
+	case OPT_socket:
+	  if (opt_arg)
+	  {
+	    my_free(options->unix_socket);
+	    options->unix_socket=my_strdup(opt_arg,MYF(MY_WME));
+	  }
+	  break;
+	case OPT_compress:
+	  options->compress=1;
+	  options->client_flag|= CLIENT_COMPRESS;
+	  break;
         case OPT_password:
-      if (opt_arg)
-      {
-        my_free(options->password);
-        options->password=my_strdup(opt_arg,MYF(MY_WME));
-      }
-      break;
+	  if (opt_arg)
+	  {
+	    my_free(options->password);
+	    options->password=my_strdup(opt_arg,MYF(MY_WME));
+	  }
+	  break;
         case OPT_pipe:
           options->protocol = MYSQL_PROTOCOL_PIPE;
-    case OPT_connect_timeout:
-    case OPT_timeout:
-      if (opt_arg)
-        options->connect_timeout=atoi(opt_arg);
-      break;
-    case OPT_user:
-      if (opt_arg)
-      {
-        my_free(options->user);
-        options->user=my_strdup(opt_arg,MYF(MY_WME));
-      }
-      break;
-    case OPT_init_command:
-      add_init_command(options,opt_arg);
-      break;
-    case OPT_host:
-      if (opt_arg)
-      {
-        my_free(options->host);
-        options->host=my_strdup(opt_arg,MYF(MY_WME));
-      }
-      break;
-    case OPT_database:
-      if (opt_arg)
-      {
-        my_free(options->db);
-        options->db=my_strdup(opt_arg,MYF(MY_WME));
-      }
-      break;
-    case OPT_debug:
+	case OPT_connect_timeout:
+	case OPT_timeout:
+	  if (opt_arg)
+	    options->connect_timeout=atoi(opt_arg);
+	  break;
+	case OPT_user:
+	  if (opt_arg)
+	  {
+	    my_free(options->user);
+	    options->user=my_strdup(opt_arg,MYF(MY_WME));
+	  }
+	  break;
+	case OPT_init_command:
+	  add_init_command(options,opt_arg);
+	  break;
+	case OPT_host:
+	  if (opt_arg)
+	  {
+	    my_free(options->host);
+	    options->host=my_strdup(opt_arg,MYF(MY_WME));
+	  }
+	  break;
+	case OPT_database:
+	  if (opt_arg)
+	  {
+	    my_free(options->db);
+	    options->db=my_strdup(opt_arg,MYF(MY_WME));
+	  }
+	  break;
+	case OPT_debug:
 #ifdef MYSQL_CLIENT
-      mysql_debug(opt_arg ? opt_arg : "d:t:o,/tmp/client.trace");
-      break;
+	  mysql_debug(opt_arg ? opt_arg : "d:t:o,/tmp/client.trace");
+	  break;
 #endif
-    case OPT_return_found_rows:
-      options->client_flag|=CLIENT_FOUND_ROWS;
-      break;
+	case OPT_return_found_rows:
+	  options->client_flag|=CLIENT_FOUND_ROWS;
+	  break;
 #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
-    case OPT_ssl_key:
-      my_free(options->ssl_key);
+	case OPT_ssl_key:
+	  my_free(options->ssl_key);
           options->ssl_key = my_strdup(opt_arg, MYF(MY_WME));
           break;
-    case OPT_ssl_cert:
-      my_free(options->ssl_cert);
+	case OPT_ssl_cert:
+	  my_free(options->ssl_cert);
           options->ssl_cert = my_strdup(opt_arg, MYF(MY_WME));
           break;
-    case OPT_ssl_ca:
-      my_free(options->ssl_ca);
+	case OPT_ssl_ca:
+	  my_free(options->ssl_ca);
           options->ssl_ca = my_strdup(opt_arg, MYF(MY_WME));
           break;
-    case OPT_ssl_capath:
-      my_free(options->ssl_capath);
+	case OPT_ssl_capath:
+	  my_free(options->ssl_capath);
           options->ssl_capath = my_strdup(opt_arg, MYF(MY_WME));
           break;
         case OPT_ssl_cipher:
@@ -1296,37 +1324,37 @@ void mysql_read_default_options(struct st_mysql_options *options,
           options->ssl_cipher= my_strdup(opt_arg, MYF(MY_WME));
           break;
 #else
-    case OPT_ssl_key:
-    case OPT_ssl_cert:
-    case OPT_ssl_ca:
-    case OPT_ssl_capath:
+	case OPT_ssl_key:
+	case OPT_ssl_cert:
+	case OPT_ssl_ca:
+	case OPT_ssl_capath:
         case OPT_ssl_cipher:
-      break;
+	  break;
 #endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */
-    case OPT_character_sets_dir:
-      my_free(options->charset_dir);
+	case OPT_character_sets_dir:
+	  my_free(options->charset_dir);
           options->charset_dir = my_strdup(opt_arg, MYF(MY_WME));
-      break;
-    case OPT_default_character_set:
-      my_free(options->charset_name);
+	  break;
+	case OPT_default_character_set:
+	  my_free(options->charset_name);
           options->charset_name = my_strdup(opt_arg, MYF(MY_WME));
-      break;
-    case OPT_interactive_timeout:
-      options->client_flag|= CLIENT_INTERACTIVE;
-      break;
-    case OPT_local_infile:
-      if (!opt_arg || atoi(opt_arg) != 0)
-        options->client_flag|= CLIENT_LOCAL_FILES;
-      else
-        options->client_flag&= ~CLIENT_LOCAL_FILES;
-      break;
-    case OPT_disable_local_infile:
-      options->client_flag&= ~CLIENT_LOCAL_FILES;
+	  break;
+	case OPT_interactive_timeout:
+	  options->client_flag|= CLIENT_INTERACTIVE;
+	  break;
+	case OPT_local_infile:
+	  if (!opt_arg || atoi(opt_arg) != 0)
+	    options->client_flag|= CLIENT_LOCAL_FILES;
+	  else
+	    options->client_flag&= ~CLIENT_LOCAL_FILES;
+	  break;
+	case OPT_disable_local_infile:
+	  options->client_flag&= ~CLIENT_LOCAL_FILES;
           break;
-    case OPT_max_allowed_packet:
+	case OPT_max_allowed_packet:
           if (opt_arg)
-        options->max_allowed_packet= atoi(opt_arg);
-      break;
+	    options->max_allowed_packet= atoi(opt_arg);
+	  break;
         case OPT_protocol:
           if ((options->protocol= find_type(opt_arg, &sql_protocol_typelib,
                                             FIND_TYPE_BASIC)) <= 0)
@@ -1342,13 +1370,13 @@ void mysql_read_default_options(struct st_mysql_options *options,
           options->shared_memory_base_name=my_strdup(opt_arg,MYF(MY_WME));
 #endif
           break;
-    case OPT_multi_results:
-      options->client_flag|= CLIENT_MULTI_RESULTS;
-      break;
-    case OPT_multi_statements:
-    case OPT_multi_queries:
-      options->client_flag|= CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS;
-      break;
+	case OPT_multi_results:
+	  options->client_flag|= CLIENT_MULTI_RESULTS;
+	  break;
+	case OPT_multi_statements:
+	case OPT_multi_queries:
+	  options->client_flag|= CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS;
+	  break;
         case OPT_secure_auth:
           options->secure_auth= TRUE;
           break;
@@ -1373,9 +1401,16 @@ void mysql_read_default_options(struct st_mysql_options *options,
         case OPT_default_auth:
           EXTENSION_SET_STRING(options, default_auth, opt_arg);
           break;
-    default:
-      DBUG_PRINT("warning",("unknown option: %s",option[0]));
-    }
+
+        case OPT_enable_cleartext_plugin:
+          ENSURE_EXTENSIONS_PRESENT(options);
+          options->extension->enable_cleartext_plugin= 
+            (!opt_arg || atoi(opt_arg) != 0) ? TRUE : FALSE;
+          break;
+
+	default:
+	  DBUG_PRINT("warning",("unknown option: %s",option[0]));
+	}
       }
     }
   }
@@ -1383,6 +1418,7 @@ void mysql_read_default_options(struct st_mysql_options *options,
   DBUG_VOID_RETURN;
 }
 
+
 /**************************************************************************
   Get column lengths of the current row
   If one uses mysql_use_result, res->lengths contains the length information,
@@ -1390,8 +1426,8 @@ void mysql_read_default_options(struct st_mysql_options *options,
 **************************************************************************/
 
 static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
-                  unsigned int field_count)
-{
+			      unsigned int field_count)
+{ 
   ulong *prev_length;
   char *start=0;
   MYSQL_ROW end;
@@ -1416,8 +1452,8 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
 ***************************************************************************/
 
 MYSQL_FIELD *
-unpack_fields(MYSQL_DATA *data,MEM_ROOT *alloc,uint fields,
-          my_bool default_value, uint server_capabilities)
+unpack_fields(MYSQL *mysql, MYSQL_DATA *data,MEM_ROOT *alloc,uint fields,
+	      my_bool default_value, uint server_capabilities)
 {
   MYSQL_ROWS	*row;
   MYSQL_FIELD	*field,*result;
@@ -1425,10 +1461,11 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
   DBUG_ENTER("unpack_fields");
 
   field= result= (MYSQL_FIELD*) alloc_root(alloc,
-                       (uint) sizeof(*field)*fields);
+					   (uint) sizeof(*field)*fields);
   if (!result)
   {
     free_rows(data);				/* Free old data */
+    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
     DBUG_RETURN(0);
   }
   bzero((char*) field, (uint) sizeof(MYSQL_FIELD)*fields);
@@ -1456,6 +1493,14 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
       field->org_name_length=	lengths[5];
 
       /* Unpack fixed length parts */
+      if (lengths[6] != 12)
+      {
+        /* malformed packet. signal an error. */
+        free_rows(data);			/* Free old data */
+        set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
+        DBUG_RETURN(0);
+      }
+
       pos= (uchar*) row->data[6];
       field->charsetnr= uint2korr(pos);
       field->length=	(uint) uint4korr(pos+2);
@@ -1468,7 +1513,7 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
       if (default_value && row->data[7])
       {
         field->def=strmake_root(alloc,(char*) row->data[7], lengths[7]);
-    field->def_length= lengths[7];
+	field->def_length= lengths[7];
       }
       else
         field->def=0;
@@ -1509,7 +1554,7 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
       if (default_value && row->data[5])
       {
         field->def=strdup_root(alloc,(char*) row->data[5]);
-    field->def_length= lengths[5];
+	field->def_length= lengths[5];
       }
       else
         field->def=0;
@@ -1524,7 +1569,7 @@ static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
 /* Read all rows (fields or data) from server */
 
 MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
-              unsigned int fields)
+			  unsigned int fields)
 {
   uint	field;
   ulong pkt_len;
@@ -1539,7 +1584,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   if ((pkt_len= cli_safe_read(mysql)) == packet_error)
     DBUG_RETURN(0);
   if (!(result=(MYSQL_DATA*) my_malloc(sizeof(MYSQL_DATA),
-                       MYF(MY_WME | MY_ZEROFILL))))
+				       MYF(MY_WME | MY_ZEROFILL))))
   {
     set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
     DBUG_RETURN(0);
@@ -1562,10 +1607,10 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   {
     result->rows++;
     if (!(cur= (MYSQL_ROWS*) alloc_root(&result->alloc,
-                    sizeof(MYSQL_ROWS))) ||
-    !(cur->data= ((MYSQL_ROW)
-              alloc_root(&result->alloc,
-                 (fields+1)*sizeof(char *)+pkt_len))))
+					sizeof(MYSQL_ROWS))) ||
+	!(cur->data= ((MYSQL_ROW)
+		      alloc_root(&result->alloc,
+				 (fields+1)*sizeof(char *)+pkt_len))))
     {
       free_rows(result);
       set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
@@ -1579,25 +1624,25 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
     {
       if ((len=(ulong) net_field_length(&cp)) == NULL_LENGTH)
       {						/* null field */
-    cur->data[field] = 0;
+	cur->data[field] = 0;
       }
       else
       {
-    cur->data[field] = to;
+	cur->data[field] = to;
         if (len > (ulong) (end_to - to))
         {
           free_rows(result);
           set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
           DBUG_RETURN(0);
         }
-    memcpy(to,(char*) cp,len); to[len]=0;
-    to+=len+1;
-    cp+=len;
-    if (mysql_fields)
-    {
-      if (mysql_fields[field].max_length < len)
-        mysql_fields[field].max_length=len;
-    }
+	memcpy(to,(char*) cp,len); to[len]=0;
+	to+=len+1;
+	cp+=len;
+	if (mysql_fields)
+	{
+	  if (mysql_fields[field].max_length < len)
+	    mysql_fields[field].max_length=len;
+	}
       }
     }
     cur->data[field]=to;			/* End of last field */
@@ -1613,7 +1658,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
     mysql->warning_count= uint2korr(cp+1);
     mysql->server_status= uint2korr(cp+3);
     DBUG_PRINT("info",("status: %u  warning_count:  %u",
-               mysql->server_status, mysql->warning_count));
+		       mysql->server_status, mysql->warning_count));
   }
   DBUG_PRINT("exit", ("Got %lu rows", (ulong) result->rows));
   DBUG_RETURN(result);
@@ -1624,6 +1669,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   When next packet is read, the previous field values are destroyed
 */
 
+
 static int
 read_one_row(MYSQL *mysql,uint fields,MYSQL_ROW row, ulong *lengths)
 {
@@ -1673,6 +1719,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   return 0;
 }
 
+
 /****************************************************************************
   Init MySQL structure or allocate one
 ****************************************************************************/
@@ -1733,6 +1780,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   return mysql;
 }
 
+
 /*
   Fill in SSL part of MYSQL structure and set 'use_ssl' flag.
   NB! Errors are not reported until you do mysql_real_connect.
@@ -1742,11 +1790,11 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
 
 my_bool STDCALL
 mysql_ssl_set(MYSQL *mysql __attribute__((unused)) ,
-          const char *key __attribute__((unused)),
-          const char *cert __attribute__((unused)),
-          const char *ca __attribute__((unused)),
-          const char *capath __attribute__((unused)),
-          const char *cipher __attribute__((unused)))
+	      const char *key __attribute__((unused)),
+	      const char *cert __attribute__((unused)),
+	      const char *ca __attribute__((unused)),
+	      const char *capath __attribute__((unused)),
+	      const char *cipher __attribute__((unused)))
 {
   DBUG_ENTER("mysql_ssl_set");
 #if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
@@ -1759,6 +1807,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   DBUG_RETURN(0);
 }
 
+
 /*
   Free strings in the SSL structure and clear 'use_ssl' flag.
   NB! Errors are not reported until you do mysql_real_connect.
@@ -1813,6 +1862,7 @@ MYSQL_DATA *cli_read_rows(MYSQL *mysql,MYSQL_FIELD *mysql_fields,
   DBUG_RETURN(NULL);
 }
 
+
 /*
   Check the server's (subject) Common Name against the
   hostname we connected to
@@ -1890,6 +1940,7 @@ static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const c
 
 #endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */
 
+
 /*
   Note that the mysql argument must be initialized with mysql_init()
   before calling mysql_real_connect !
@@ -1925,6 +1976,8 @@ int cli_read_change_user_result(MYSQL *mysql)
 #endif
 };
 
+
+
 typedef enum my_cs_match_type_enum
 {
   /* MySQL and OS charsets are fully compatible */
@@ -1937,6 +1990,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   my_cs_unsupp
 } my_cs_match_type;
 
+
 typedef struct str2str_st
 {
   const char *os_name;
@@ -2074,7 +2128,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   {"Shift_JIS",      "sjis",     my_cs_exact},
   {"SJIS",           "sjis",     my_cs_exact},
   {"shiftjisx0213",  "sjis",     my_cs_exact},
-
+  
   {"tis620",         "tis620",   my_cs_exact},
   {"tis-620",        "tis620",   my_cs_exact},
 
@@ -2088,6 +2142,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   {NULL,             NULL,       0}
 };
 
+
 static const char *
 my_os_charset_to_mysql_charset(const char *csname)
 {
@@ -2130,6 +2185,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   return csname;
 }
 
+
 #ifndef __WIN__
 #include <stdlib.h> /* for getenv() */
 #ifdef HAVE_LANGINFO_H
@@ -2140,6 +2196,7 @@ int cli_read_change_user_result(MYSQL *mysql)
 #endif
 #endif /* __WIN__ */
 
+
 static int
 mysql_autodetect_character_set(MYSQL *mysql)
 {
@@ -2163,6 +2220,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   return 0;
 }
 
+
 static void
 mysql_set_character_set_with_default_collation(MYSQL *mysql)
 {
@@ -2175,7 +2233,7 @@ int cli_read_change_user_result(MYSQL *mysql)
   {
     /* Try to set compiled default collation when it's possible. */
     CHARSET_INFO *collation;
-    if ((collation=
+    if ((collation= 
          get_charset_by_name(MYSQL_DEFAULT_COLLATION_NAME, MYF(MY_WME))) &&
                              my_charset_same(mysql->charset, collation))
     {
@@ -2193,13 +2251,14 @@ int cli_read_change_user_result(MYSQL *mysql)
   charsets_dir= save;
 }
 
+
 C_MODE_START
 int mysql_init_character_set(MYSQL *mysql)
 {
   /* Set character set */
   if (!mysql->options.charset_name)
   {
-    if (!(mysql->options.charset_name=
+    if (!(mysql->options.charset_name= 
        my_strdup(MYSQL_DEFAULT_CHARSET_NAME,MYF(MY_WME))))
       return 1;
   }
@@ -2303,6 +2362,8 @@ struct st_mysql_client_plugin *mysql_client_builtins[]=
   0
 };
 
+
+
 /* this is a "superset" of MYSQL_PLUGIN_VIO, in C++ I use inheritance */
 typedef struct {
   int (*read_packet)(struct st_plugin_vio *vio, uchar **buf);
@@ -2325,7 +2386,7 @@ struct st_mysql_client_plugin *mysql_client_builtins[]=
   sends a COM_CHANGE_USER command with a caller provided payload
 
   Packet format:
-
+   
     Bytes       Content
     -----       ----
     n           user name - \0-terminated string
@@ -2396,7 +2457,7 @@ static int send_change_user_packet(MCPVIO_EXT *mpvio,
   sends a client authentication packet (second packet in the 3-way handshake)
 
   Packet format (when the server is 4.0 or earlier):
-
+   
     Bytes       Content
     -----       ----
     2           client capabilities
@@ -2405,7 +2466,7 @@ static int send_change_user_packet(MCPVIO_EXT *mpvio,
     9           scramble_323, \0-terminated
 
   Packet format (when the server is 4.1 or newer):
-
+   
     Bytes       Content
     -----       ----
     4           client capabilities
@@ -2431,7 +2492,7 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
 
   /* see end= buff+32 below, fixed size of the packet is 32 bytes */
   buff= my_alloca(33 + USERNAME_LENGTH + data_len + NAME_LEN + NAME_LEN);
-
+  
   mysql->client_flag|= mysql->options.client_flag;
   mysql->client_flag|= CLIENT_CAPABILITIES;
 
@@ -2451,7 +2512,7 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
 
   /* Remove options that server doesn't support */
   mysql->client_flag= mysql->client_flag &
-                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41)
+                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) 
                        | mysql->server_capabilities);
 
 #ifndef HAVE_COMPRESS
@@ -2514,7 +2575,7 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
     DBUG_PRINT("info", ("IO layer change in progress..."));
     if (sslconnect(ssl_fd, net->vio,
                    (long) (mysql->options.connect_timeout), &ssl_error))
-    {
+    {    
       char buf[512];
       ERR_error_string_n(ssl_error, buf, 512);
       buf[511]= 0;
@@ -2522,7 +2583,7 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
                                ER(CR_SSL_CONNECTION_ERROR),
                                buf);
       goto error;
-    }
+    }    
     DBUG_PRINT("info", ("IO layer change done!"));
 
     /* Verify server cert */
@@ -2537,8 +2598,8 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
 #endif /* HAVE_OPENSSL */
 
   DBUG_PRINT("info",("Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu",
-             mysql->server_version, mysql->server_capabilities,
-             mysql->server_status, mysql->client_flag));
+		     mysql->server_version, mysql->server_capabilities,
+		     mysql->server_status, mysql->client_flag));
 
   compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);
 
@@ -2590,7 +2651,7 @@ static int send_client_reply_packet(MCPVIO_EXT *mpvio,
   }
   my_afree(buff);
   return 0;
-
+  
 error:
   my_afree(buff);
   return 1;
@@ -2743,6 +2804,27 @@ static void client_mpvio_info(MYSQL_PLUGIN_VIO *vio,
   mpvio_info(mpvio->mysql->net.vio, info);
 }
 
+
+my_bool libmysql_cleartext_plugin_enabled= 0;
+
+static my_bool check_plugin_enabled(MYSQL *mysql, auth_plugin_t *plugin)
+{
+  if (plugin == &clear_password_client_plugin &&
+      (!libmysql_cleartext_plugin_enabled &&
+       (!mysql->options.extension ||
+       !mysql->options.extension->enable_cleartext_plugin)))
+  {
+    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,
+                             unknown_sqlstate,
+                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD),
+                             clear_password_client_plugin.name,
+                             "plugin not enabled");
+    return TRUE;
+  }
+  return FALSE;
+}
+
+
 /**
   Client side of the plugin driver authentication.
 
@@ -2785,6 +2867,9 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
     auth_plugin_name= auth_plugin->name;
   }
 
+  if (check_plugin_enabled(mysql, auth_plugin))
+    DBUG_RETURN(1);
+
   DBUG_PRINT ("info", ("using plugin %s", auth_plugin_name));
 
   mysql->net.last_errno= 0; /* just in case */
@@ -2808,10 +2893,10 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   mpvio.plugin= auth_plugin;
 
   res= auth_plugin->authenticate_user((struct st_plugin_vio *)&mpvio, mysql);
-  DBUG_PRINT ("info", ("authenticate_user returned %s",
-                       res == CR_OK ? "CR_OK" :
+  DBUG_PRINT ("info", ("authenticate_user returned %s", 
+                       res == CR_OK ? "CR_OK" : 
                        res == CR_ERROR ? "CR_ERROR" :
-                       res == CR_OK_HANDSHAKE_COMPLETE ?
+                       res == CR_OK_HANDSHAKE_COMPLETE ? 
                          "CR_OK_HANDSHAKE_COMPLETE" : "error"));
 
   compile_time_assert(CR_OK == -1);
@@ -2853,7 +2938,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   {
     /* The server asked to use a different authentication plugin */
     if (pkt_length == 1)
-    {
+    { 
       /* old "use short scramble" packet */
       DBUG_PRINT ("info", ("old use short scramble packet from server"));
       auth_plugin_name= old_password_plugin_name;
@@ -2861,7 +2946,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
       mpvio.cached_server_reply.pkt_len= SCRAMBLE_LENGTH + 1;
     }
     else
-    {
+    { 
       /* new "use different plugin" packet */
       uint len;
       auth_plugin_name= (char*)mysql->net.read_pos + 1;
@@ -2876,13 +2961,16 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
                          auth_plugin_name, MYSQL_CLIENT_AUTHENTICATION_PLUGIN)))
       DBUG_RETURN (1);
 
+    if (check_plugin_enabled(mysql, auth_plugin))
+      DBUG_RETURN(1);
+
     mpvio.plugin= auth_plugin;
     res= auth_plugin->authenticate_user((struct st_plugin_vio *)&mpvio, mysql);
 
-    DBUG_PRINT ("info", ("second authenticate_user returned %s",
-                         res == CR_OK ? "CR_OK" :
+    DBUG_PRINT ("info", ("second authenticate_user returned %s", 
+                         res == CR_OK ? "CR_OK" : 
                          res == CR_ERROR ? "CR_ERROR" :
-                         res == CR_OK_HANDSHAKE_COMPLETE ?
+                         res == CR_OK_HANDSHAKE_COMPLETE ? 
                          "CR_OK_HANDSHAKE_COMPLETE" : "error"));
     if (res > CR_OK)
     {
@@ -2915,10 +3003,10 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   DBUG_RETURN (mysql->net.read_pos[0] != 0);
 }
 
-MYSQL * STDCALL
+MYSQL * STDCALL 
 CLI_MYSQL_REAL_CONNECT(MYSQL *mysql,const char *host, const char *user,
-               const char *passwd, const char *db,
-               uint port, const char *unix_socket,ulong client_flag)
+		       const char *passwd, const char *db,
+		       uint port, const char *unix_socket,ulong client_flag)
 {
   char		buff[NAME_LEN+USERNAME_LENGTH+100];
   int           scramble_data_len, pkt_scramble_len= 0;
@@ -2940,9 +3028,9 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   DBUG_ENTER("mysql_real_connect");
 
   DBUG_PRINT("enter",("host: %s  db: %s  user: %s (client)",
-              host ? host : "(Null)",
-              db ? db : "(Null)",
-              user ? user : "(Null)"));
+		      host ? host : "(Null)",
+		      db ? db : "(Null)",
+		      user ? user : "(Null)"));
 
   /* Test whether we're already connected */
   if (net->vio)
@@ -2959,9 +3047,9 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   if (mysql->options.my_cnf_file || mysql->options.my_cnf_group)
   {
     mysql_read_default_options(&mysql->options,
-                   (mysql->options.my_cnf_file ?
-                mysql->options.my_cnf_file : "my"),
-                   mysql->options.my_cnf_group);
+			       (mysql->options.my_cnf_file ?
+				mysql->options.my_cnf_file : "my"),
+			       mysql->options.my_cnf_group);
     my_free(mysql->options.my_cnf_file);
     my_free(mysql->options.my_cnf_group);
     mysql->options.my_cnf_file=mysql->options.my_cnf_group=0;
@@ -3006,16 +3094,16 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   {
     DBUG_PRINT("info", ("Using shared memory"));
     if ((create_shared_memory(mysql,net, mysql->options.connect_timeout)) ==
-    INVALID_HANDLE_VALUE)
+	INVALID_HANDLE_VALUE)
     {
       DBUG_PRINT("error",
-         ("host: '%s'  socket: '%s'  shared memory: %s  have_tcpip: %d",
-          host ? host : "<null>",
-          unix_socket ? unix_socket : "<null>",
-          (int) mysql->options.shared_memory_base_name,
-          (int) have_tcpip));
+		 ("host: '%s'  socket: '%s'  shared memory: %s  have_tcpip: %d",
+		  host ? host : "<null>",
+		  unix_socket ? unix_socket : "<null>",
+		  (int) mysql->options.shared_memory_base_name,
+		  (int) have_tcpip));
       if (mysql->options.protocol == MYSQL_PROTOCOL_MEMORY)
-    goto error;
+	goto error;
 
       /*
         Try also with PIPE or TCP/IP. Clear the error from
@@ -3073,10 +3161,10 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
     strmake(UNIXaddr.sun_path, unix_socket, sizeof(UNIXaddr.sun_path)-1);
 
     if (my_connect(sock, (struct sockaddr *) &UNIXaddr, sizeof(UNIXaddr),
-           mysql->options.connect_timeout))
+		   mysql->options.connect_timeout))
     {
       DBUG_PRINT("error",("Got error %d on connect to local server",
-              socket_errno));
+			  socket_errno));
       set_mysql_extended_error(mysql, CR_CONNECTION_ERROR,
                                unknown_sqlstate,
                                ER(CR_CONNECTION_ERROR),
@@ -3095,17 +3183,17 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   {
     if ((hPipe= create_named_pipe(mysql, mysql->options.connect_timeout,
                                   (char**) &host, (char**) &unix_socket)) ==
-    INVALID_HANDLE_VALUE)
+	INVALID_HANDLE_VALUE)
     {
       DBUG_PRINT("error",
-         ("host: '%s'  socket: '%s'  have_tcpip: %d",
-          host ? host : "<null>",
-          unix_socket ? unix_socket : "<null>",
-          (int) have_tcpip));
+		 ("host: '%s'  socket: '%s'  have_tcpip: %d",
+		  host ? host : "<null>",
+		  unix_socket ? unix_socket : "<null>",
+		  (int) have_tcpip));
       if (mysql->options.protocol == MYSQL_PROTOCOL_PIPE ||
-      (host && !strcmp(host,LOCAL_HOST_NAMEDPIPE)) ||
-      (unix_socket && !strcmp(unix_socket,MYSQL_NAMEDPIPE)))
-    goto error;
+	  (host && !strcmp(host,LOCAL_HOST_NAMEDPIPE)) ||
+	  (unix_socket && !strcmp(unix_socket,MYSQL_NAMEDPIPE)))
+	goto error;
       /* Try also with TCP/IP */
     }
     else
@@ -3158,9 +3246,9 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
     my_snprintf(port_buf, NI_MAXSERV, "%d", port);
     gai_errno= getaddrinfo(host, port_buf, &hints, &res_lst);
 
-    if (gai_errno != 0)
-    {
-      /*
+    if (gai_errno != 0) 
+    { 
+      /* 
         For DBUG we are keeping the right message but for client we default to
         historical error message.
       */
@@ -3298,7 +3386,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   mysql->protocol_version= net->read_pos[0];
   DBUG_DUMP("packet",(uchar*) net->read_pos,10);
   DBUG_PRINT("info",("mysql protocol version %d, server=%d",
-             PROTOCOL_VERSION, mysql->protocol_version));
+		     PROTOCOL_VERSION, mysql->protocol_version));
   if (mysql->protocol_version != PROTOCOL_VERSION)
   {
     set_mysql_extended_error(mysql, CR_VERSION_ERROR, unknown_sqlstate,
@@ -3309,7 +3397,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   server_version_end= end= strend((char*) net->read_pos+1);
   mysql->thread_id=uint4korr(end+1);
   end+=5;
-  /*
+  /* 
     Scramble is split into two parts because old clients do not understand
     long scrambles; here goes the first part.
   */
@@ -3327,6 +3415,12 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
     mysql->server_status=uint2korr(end+3);
     mysql->server_capabilities|= uint2korr(end+5) << 16;
     pkt_scramble_len= end[7];
+    if (pkt_scramble_len < 0)
+    {
+      set_mysql_error(mysql, CR_MALFORMED_PACKET,
+                      unknown_sqlstate);        /* purecov: inspected */
+      goto error;
+    }
   }
   end+= 18;
 
@@ -3342,13 +3436,13 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
 
   /* Save connection information */
   if (!my_multi_malloc(MYF(0),
-               &mysql->host_info, (uint) strlen(host_info)+1,
-               &mysql->host,      (uint) strlen(host)+1,
-               &mysql->unix_socket,unix_socket ?
-               (uint) strlen(unix_socket)+1 : (uint) 1,
-               &mysql->server_version,
-               (uint) (server_version_end - (char*) net->read_pos + 1),
-               NullS) ||
+		       &mysql->host_info, (uint) strlen(host_info)+1,
+		       &mysql->host,      (uint) strlen(host)+1,
+		       &mysql->unix_socket,unix_socket ?
+		       (uint) strlen(unix_socket)+1 : (uint) 1,
+		       &mysql->server_version,
+		       (uint) (server_version_end - (char*) net->read_pos + 1),
+		       NullS) ||
       !(mysql->user=my_strdup(user,MYF(0))) ||
       !(mysql->passwd=my_strdup(passwd,MYF(0))))
   {
@@ -3407,7 +3501,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   if (mysql->client_flag & CLIENT_COMPRESS)      /* We will use compression */
     net->compress=1;
 
-#ifdef CHECK_LICENSE
+#ifdef CHECK_LICENSE 
   if (check_license(mysql))
     goto error;
 #endif
@@ -3441,7 +3535,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
       int status;
 
       if (mysql_real_query(mysql,*ptr, (ulong) strlen(*ptr)))
-    goto error;
+	goto error;
 
       do {
         if (mysql->fields)
@@ -3477,6 +3571,7 @@ int run_plugin_auth(MYSQL *mysql, char *data, uint data_len,
   DBUG_RETURN(0);
 }
 
+
 my_bool mysql_reconnect(MYSQL *mysql)
 {
   MYSQL tmp_mysql;
@@ -3497,8 +3592,8 @@ my_bool mysql_reconnect(MYSQL *mysql)
   tmp_mysql.options.my_cnf_file= tmp_mysql.options.my_cnf_group= 0;
 
   if (!mysql_real_connect(&tmp_mysql,mysql->host,mysql->user,mysql->passwd,
-              mysql->db, mysql->port, mysql->unix_socket,
-              mysql->client_flag | CLIENT_REMEMBER_OPTIONS))
+			  mysql->db, mysql->port, mysql->unix_socket,
+			  mysql->client_flag | CLIENT_REMEMBER_OPTIONS))
   {
     mysql->net.last_errno= tmp_mysql.net.last_errno;
     strmov(mysql->net.last_error, tmp_mysql.net.last_error);
@@ -3534,6 +3629,7 @@ my_bool mysql_reconnect(MYSQL *mysql)
   DBUG_RETURN(0);
 }
 
+
 /**************************************************************************
   Set current database
 **************************************************************************/
@@ -3553,6 +3649,7 @@ my_bool mysql_reconnect(MYSQL *mysql)
   DBUG_RETURN(0);
 }
 
+
 /*************************************************************************
   Send a QUIT to the server and close the connection
   If handle is alloced by mysql connect free it.
@@ -3599,6 +3696,7 @@ static void mysql_close_free_options(MYSQL *mysql)
   DBUG_VOID_RETURN;
 }
 
+
 static void mysql_close_free(MYSQL *mysql)
 {
   my_free(mysql->host_info);
@@ -3613,8 +3711,9 @@ static void mysql_close_free(MYSQL *mysql)
   mysql->host_info= mysql->user= mysql->passwd= mysql->db= 0;
 }
 
+
 /**
-  For use when the connection to the server has been lost (in which case
+  For use when the connection to the server has been lost (in which case 
   the server has discarded all information about prepared statements
   associated with the connection).
 
@@ -3652,6 +3751,7 @@ static void mysql_prune_stmt_list(MYSQL *mysql)
   mysql->stmts= pruned_list;
 }
 
+
 /*
   Clear connection pointer of every statement: this is necessary
   to give error on attempt to use a prepared statement of closed
@@ -3689,6 +3789,7 @@ void mysql_detach_stmt_list(LIST **stmt_list __attribute__((unused)),
 #endif /* MYSQL_CLIENT */
 }
 
+
 void STDCALL mysql_close(MYSQL *mysql)
 {
   DBUG_ENTER("mysql_close");
@@ -3716,6 +3817,7 @@ void STDCALL mysql_close(MYSQL *mysql)
   DBUG_VOID_RETURN;
 }
 
+
 static my_bool cli_read_query_result(MYSQL *mysql)
 {
   uchar *pos;
@@ -3736,8 +3838,8 @@ static my_bool cli_read_query_result(MYSQL *mysql)
     mysql->affected_rows= net_field_length_ll(&pos);
     mysql->insert_id=	  net_field_length_ll(&pos);
     DBUG_PRINT("info",("affected_rows: %lu  insert_id: %lu",
-               (ulong) mysql->affected_rows,
-               (ulong) mysql->insert_id));
+		       (ulong) mysql->affected_rows,
+		       (ulong) mysql->insert_id));
     if (protocol_41(mysql))
     {
       mysql->server_status=uint2korr(pos); pos+=2;
@@ -3750,7 +3852,7 @@ static my_bool cli_read_query_result(MYSQL *mysql)
       mysql->warning_count= 0;
     }
     DBUG_PRINT("info",("status: %u  warning_count: %u",
-               mysql->server_status, mysql->warning_count));
+		       mysql->server_status, mysql->warning_count));
     if (pos < mysql->net.read_pos+length && net_field_length(&pos))
       mysql->info=(char*) pos;
     DBUG_RETURN(0);
@@ -3764,7 +3866,7 @@ static my_bool cli_read_query_result(MYSQL *mysql)
     {
       set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
       DBUG_RETURN(1);
-    }
+    }   
 
     error= handle_local_infile(mysql,(char*) pos);
     if ((length= cli_safe_read(mysql)) == packet_error || error)
@@ -3777,9 +3879,9 @@ static my_bool cli_read_query_result(MYSQL *mysql)
 
   if (!(fields=cli_read_rows(mysql,(MYSQL_FIELD*)0, protocol_41(mysql) ? 7:5)))
     DBUG_RETURN(1);
-  if (!(mysql->fields=unpack_fields(fields,&mysql->field_alloc,
-                    (uint) field_count,0,
-                    mysql->server_capabilities)))
+  if (!(mysql->fields=unpack_fields(mysql, fields,&mysql->field_alloc,
+				    (uint) field_count,0,
+				    mysql->server_capabilities)))
     DBUG_RETURN(1);
   mysql->status= MYSQL_STATUS_GET_RESULT;
   mysql->field_count= (uint) field_count;
@@ -3787,6 +3889,7 @@ static my_bool cli_read_query_result(MYSQL *mysql)
   DBUG_RETURN(0);
 }
 
+
 /*
   Send the query and return so we can do something else.
   Needs to be followed by mysql_read_query_result() when we want to
@@ -3800,6 +3903,7 @@ static my_bool cli_read_query_result(MYSQL *mysql)
   DBUG_RETURN(simple_command(mysql, COM_QUERY, (uchar*) query, length, 1));
 }
 
+
 int STDCALL
 mysql_real_query(MYSQL *mysql, const char *query, ulong length)
 {
@@ -3812,6 +3916,7 @@ static my_bool cli_read_query_result(MYSQL *mysql)
   DBUG_RETURN((int) (*mysql->methods->read_query_result)(mysql));
 }
 
+
 /**************************************************************************
   Alloc result struct for buffered results. All rows are read to buffer.
   mysql_data_seek may be used.
@@ -3831,9 +3936,9 @@ MYSQL_RES * STDCALL mysql_store_result(MYSQL *mysql)
   }
   mysql->status=MYSQL_STATUS_READY;		/* server is ready */
   if (!(result=(MYSQL_RES*) my_malloc((uint) (sizeof(MYSQL_RES)+
-                          sizeof(ulong) *
-                          mysql->field_count),
-                      MYF(MY_WME | MY_ZEROFILL))))
+					      sizeof(ulong) *
+					      mysql->field_count),
+				      MYF(MY_WME | MY_ZEROFILL))))
   {
     set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
     DBUG_RETURN(0);
@@ -3842,7 +3947,7 @@ MYSQL_RES * STDCALL mysql_store_result(MYSQL *mysql)
   result->eof=1;				/* Marker for buffered */
   result->lengths=(ulong*) (result+1);
   if (!(result->data=
-    (*mysql->methods->read_rows)(mysql,mysql->fields,mysql->field_count)))
+	(*mysql->methods->read_rows)(mysql,mysql->fields,mysql->field_count)))
   {
     my_free(result);
     DBUG_RETURN(0);
@@ -3860,6 +3965,7 @@ MYSQL_RES * STDCALL mysql_store_result(MYSQL *mysql)
   DBUG_RETURN(result);				/* Data fetched */
 }
 
+
 /**************************************************************************
   Alloc struct for use with unbuffered reads. Data is fetched by domand
   when calling to mysql_fetch_row.
@@ -3883,13 +3989,13 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
     DBUG_RETURN(0);
   }
   if (!(result=(MYSQL_RES*) my_malloc(sizeof(*result)+
-                      sizeof(ulong)*mysql->field_count,
-                      MYF(MY_WME | MY_ZEROFILL))))
+				      sizeof(ulong)*mysql->field_count,
+				      MYF(MY_WME | MY_ZEROFILL))))
     DBUG_RETURN(0);
   result->lengths=(ulong*) (result+1);
   result->methods= mysql->methods;
   if (!(result->row=(MYSQL_ROW)
-    my_malloc(sizeof(result->row[0])*(mysql->field_count+1), MYF(MY_WME))))
+	my_malloc(sizeof(result->row[0])*(mysql->field_count+1), MYF(MY_WME))))
   {					/* Ptrs: to one row */
     my_free(result);
     DBUG_RETURN(0);
@@ -3907,6 +4013,7 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
   DBUG_RETURN(result);			/* Data is read to be fetched */
 }
 
+
 /**************************************************************************
   Return next row of the query results
 **************************************************************************/
@@ -3923,14 +4030,14 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
       if (mysql->status != MYSQL_STATUS_USE_RESULT)
       {
         set_mysql_error(mysql,
-                        res->unbuffered_fetch_cancelled ?
+                        res->unbuffered_fetch_cancelled ? 
                         CR_FETCH_CANCELED : CR_COMMANDS_OUT_OF_SYNC,
                         unknown_sqlstate);
       }
       else if (!(read_one_row(mysql, res->field_count, res->row, res->lengths)))
       {
-    res->row_count++;
-    DBUG_RETURN(res->current_row=res->row);
+	res->row_count++;
+	DBUG_RETURN(res->current_row=res->row);
       }
       DBUG_PRINT("info",("end of data"));
       res->eof=1;
@@ -3959,6 +4066,7 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
   }
 }
 
+
 /**************************************************************************
   Get column lengths of the current row
   If one uses mysql_use_result, res->lengths contains the length information,
@@ -3977,6 +4085,7 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
   return res->lengths;
 }
 
+
 int STDCALL
 mysql_options(MYSQL *mysql,enum mysql_option option, const void *arg)
 {
@@ -4063,12 +4172,18 @@ static MYSQL_RES * cli_use_result(MYSQL *mysql)
   case MYSQL_DEFAULT_AUTH:
     EXTENSION_SET_STRING(&mysql->options, default_auth, arg);
     break;
+  case MYSQL_ENABLE_CLEARTEXT_PLUGIN:
+    ENSURE_EXTENSIONS_PRESENT(&mysql->options);
+    mysql->options.extension->enable_cleartext_plugin= 
+      (*(my_bool*) arg) ? TRUE : FALSE;
+    break;
   default:
     DBUG_RETURN(1);
   }
   DBUG_RETURN(0);
 }
 
+
 /****************************************************************************
   Functions to get information from the MySQL structure
   These are functions to make shared libraries more usable.
@@ -4090,11 +4205,13 @@ uint STDCALL mysql_errno(MYSQL *mysql)
   return mysql ? mysql->net.last_errno : mysql_server_last_errno;
 }
 
+
 const char * STDCALL mysql_error(MYSQL *mysql)
 {
   return mysql ? mysql->net.last_error : mysql_server_last_error;
 }
 
+
 /*
   Get version number for server in a form easy to test on
 
@@ -4104,7 +4221,7 @@ const char * STDCALL mysql_error(MYSQL *mysql)
 
   EXAMPLE
     4.1.0-alfa ->  40100
-
+  
   NOTES
     We will ensure that a newer server always has a bigger number.
 
@@ -4123,7 +4240,8 @@ const char * STDCALL mysql_error(MYSQL *mysql)
   return (ulong) major*10000L+(ulong) (minor*100+version);
 }
 
-/*
+
+/* 
    mysql_set_character_set function sends SET NAMES cs_name to
    the server (which changes character_set_client, character_set_result
    and character_set_connection) and updates mysql->charset so other
@@ -4173,6 +4291,7 @@ static int native_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)
 
   DBUG_ENTER("native_password_auth_client");
 
+
   if (((MCPVIO_EXT *)vio)->mysql_change_user)
   {
     /*
@@ -4272,8 +4391,8 @@ static int clear_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql)
   int res;
 
   /* send password in clear text */
-  res= vio->write_packet(vio, (const unsigned char *) mysql->passwd,
-                         strlen(mysql->passwd) + 1);
+  res= vio->write_packet(vio, (const unsigned char *) mysql->passwd, 
+						 strlen(mysql->passwd) + 1);
 
   return res ? CR_ERROR : CR_OK;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/sql-common/client_plugin.c b/dep/mysqllite/sql-common/client_plugin.c
index 980fba9..75faeb7 100644
--- a/dep/mysqllite/sql-common/client_plugin.c
+++ b/dep/mysqllite/sql-common/client_plugin.c
@@ -15,7 +15,7 @@
 
 /**
   @file
-
+  
   Support code for the client side (libmysql) plugins
 
   Client plugins are somewhat different from server plugins, they are simpler.
@@ -83,7 +83,7 @@ static int is_not_initialized(MYSQL *mysql, const char *name)
   @param type   plugin type
 
   @note this does NOT necessarily need a mutex, take care!
-
+  
   @retval a pointer to a found plugin or 0
 */
 static struct st_mysql_client_plugin *
@@ -182,7 +182,7 @@ static int is_not_initialized(MYSQL *mysql, const char *name)
 /**
   Loads plugins which are specified in the environment variable
   LIBMYSQL_PLUGINS.
-
+  
   Multiple plugins must be separated by semicolon. This function doesn't
   return or log an error.
 
@@ -197,6 +197,10 @@ static int is_not_initialized(MYSQL *mysql, const char *name)
 static void load_env_plugins(MYSQL *mysql)
 {
   char *plugs, *free_env, *s= getenv("LIBMYSQL_PLUGINS");
+  char *enable_cleartext_plugin= getenv("LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN");
+
+  if (enable_cleartext_plugin && strchr("1Yy", enable_cleartext_plugin[0]))
+    libmysql_cleartext_plugin_enabled= 1;
 
   /* no plugins to load */
   if(!s)
@@ -212,6 +216,7 @@ static void load_env_plugins(MYSQL *mysql)
   } while (s);
 
   my_free(free_env);
+
 }
 
 /********** extern functions to be used by libmysql *********************/
@@ -343,7 +348,7 @@ struct st_mysql_client_plugin *
            mysql->options.extension && mysql->options.extension->plugin_dir ?
            mysql->options.extension->plugin_dir : PLUGINDIR, "/",
            name, SO_EXT, NullS);
-
+   
   DBUG_PRINT ("info", ("dlopeninig %s", dlpath));
   /* Open new dll handle */
   if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))
@@ -372,7 +377,7 @@ struct st_mysql_client_plugin *
   }
 
 #if defined(__APPLE__)
-have_plugin:
+have_plugin:  
 #endif
   if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))
   {
@@ -458,6 +463,7 @@ struct st_mysql_client_plugin *
   DBUG_RETURN (p);
 }
 
+
 /* see <mysql/client_plugin.h> for a full description */
 int mysql_plugin_options(struct st_mysql_client_plugin *plugin,
                                  const char *option,
@@ -468,4 +474,4 @@ int mysql_plugin_options(struct st_mysql_client_plugin *plugin,
   if (!plugin || !plugin->options)
     DBUG_RETURN(1);
   DBUG_RETURN(plugin->options(option, value));
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/sql-common/my_time.c b/dep/mysqllite/sql-common/my_time.c
index 2c3f47b..e42f5f1 100644
--- a/dep/mysqllite/sql-common/my_time.c
+++ b/dep/mysqllite/sql-common/my_time.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
 
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
@@ -28,6 +28,7 @@
   ULL(1000000000000000000), ULL(10000000000000000000)
 };
 
+
 /* Position for YYYY-DD-MM HH-MM-DD.FFFFFF AM in default format */
 
 static uchar internal_format_positions[]=
@@ -39,11 +40,12 @@
 uchar days_in_month[]= {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 0};
 
 /*
-  Offset of system time zone from UTC in seconds used to speed up
+  Offset of system time zone from UTC in seconds used to speed up 
   work of my_system_gmt_sec() function.
 */
 static long my_time_zone=0;
 
+
 /* Calc days in one year. works with 0 <= year <= 99 */
 
 uint calc_days_in_year(uint year)
@@ -100,6 +102,7 @@ my_bool check_date(const MYSQL_TIME *ltime, my_bool not_zero_date,
   return FALSE;
 }
 
+
 /*
   Convert a timestamp string to a MYSQL_TIME value.
 
@@ -115,8 +118,8 @@ my_bool check_date(const MYSQL_TIME *ltime, my_bool not_zero_date,
                         TIME_NO_ZERO_DATE	Don't allow 0000-00-00 date
                         TIME_INVALID_DATES	Allow 2000-02-31
     was_cut             0	Value OK
-            1       If value was cut during conversion
-            2	check_date(date,flags) considers date invalid
+			1       If value was cut during conversion
+			2	check_date(date,flags) considers date invalid
 
   DESCRIPTION
     At least the following formats are recogniced (based on number of digits)
@@ -452,6 +455,7 @@ enum enum_mysql_timestamp_type
   DBUG_RETURN(MYSQL_TIMESTAMP_ERROR);
 }
 
+
 /*
  Convert a time string to a MYSQL_TIME struct.
 
@@ -596,7 +600,7 @@ my_bool str_to_time(const char *str, uint length, MYSQL_TIME *l_time,
   }
   else
     date[4]=0;
-
+    
   /* Check for exponent part: E<gigit> | E<sign><digit> */
   /* (may occur as result of %g formatting of time value) */
   if ((end - str) > 1 &&
@@ -629,7 +633,7 @@ my_bool str_to_time(const char *str, uint length, MYSQL_TIME *l_time,
       date[2] > UINT_MAX || date[3] > UINT_MAX ||
       date[4] > UINT_MAX)
     return 1;
-
+  
   l_time->year=         0;                      /* For protocol::store_time */
   l_time->month=        0;
   l_time->day=          date[0];
@@ -642,7 +646,7 @@ my_bool str_to_time(const char *str, uint length, MYSQL_TIME *l_time,
   /* Check if the value is valid and fits into MYSQL_TIME range */
   if (check_time_range(l_time, warning))
     return 1;
-
+  
   /* Check if there is garbage at end of the MYSQL_TIME specification */
   if (str != end)
   {
@@ -658,6 +662,7 @@ my_bool str_to_time(const char *str, uint length, MYSQL_TIME *l_time,
   return 0;
 }
 
+
 /*
   Check 'time' value to lie in the MYSQL_TIME range
 
@@ -676,7 +681,7 @@ my_bool str_to_time(const char *str, uint length, MYSQL_TIME *l_time,
     1        time value is invalid
 */
 
-int check_time_range(struct st_mysql_time *my_time, int *warning)
+int check_time_range(struct st_mysql_time *my_time, int *warning) 
 {
   longlong hour;
 
@@ -698,6 +703,7 @@ int check_time_range(struct st_mysql_time *my_time, int *warning)
   return 0;
 }
 
+
 /*
   Prepare offset of system time zone from UTC for my_system_gmt_sec() func.
 
@@ -724,6 +730,7 @@ void my_init_time(void)
   my_system_gmt_sec(&my_time, &my_time_zone, &not_used); /* Init my_time_zone */
 }
 
+
 /*
   Handle 2 digit year conversions
 
@@ -742,6 +749,7 @@ uint year_2000_handling(uint year)
   return year;
 }
 
+
 /*
   Calculate nr of day since year 0 in new date-system (from 1615)
 
@@ -774,11 +782,12 @@ long calc_daynr(uint year,uint month,uint day)
     delsum-= (long) ((int) month * 4 + 23) / 10;
   temp=(int) ((y/100+1)*3)/4;
   DBUG_PRINT("exit",("year: %d  month: %d  day: %d -> daynr: %ld",
-             y+(month <= 2),month,day,delsum+y/4-temp));
-  DBUG_ASSERT(delsum+(int) y/4-temp > 0);
+		     y+(month <= 2),month,day,delsum+y/4-temp));
+  DBUG_ASSERT(delsum+(int) y/4-temp >= 0);
   DBUG_RETURN(delsum+(int) y/4-temp);
 } /* calc_daynr */
 
+
 /*
   Convert time in MYSQL_TIME representation in system time zone to its
   my_time_t form (number of seconds in UTC since begginning of Unix Epoch).
@@ -791,9 +800,9 @@ long calc_daynr(uint year,uint month,uint day)
       in_dst_time_gap - set to true if time falls into spring time-gap
 
   NOTES
-    The idea is to cache the time zone offset from UTC (including daylight
-    saving time) for the next call to make things faster. But currently we
-    just calculate this offset during startup (by calling my_init_time()
+    The idea is to cache the time zone offset from UTC (including daylight 
+    saving time) for the next call to make things faster. But currently we 
+    just calculate this offset during startup (by calling my_init_time() 
     function) and use it all the time.
     Time value provided should be legal time value (e.g. '2003-01-01 25:00:00'
     is not allowed).
@@ -922,8 +931,8 @@ long calc_daynr(uint year,uint month,uint day)
   l_time=&tm_tmp;
   for (loop=0;
        loop < 2 &&
-     (t->hour != (uint) l_time->tm_hour ||
-      t->minute != (uint) l_time->tm_min ||
+	 (t->hour != (uint) l_time->tm_hour ||
+	  t->minute != (uint) l_time->tm_min ||
           t->second != (uint) l_time->tm_sec);
        loop++)
   {					/* One check should be enough ? */
@@ -959,7 +968,7 @@ long calc_daynr(uint year,uint month,uint day)
     else if (days > 1)
       days= -1;
     diff=(3600L*(long) (days*24+((int) t->hour - (int) l_time->tm_hour))+
-      (long) (60*((int) t->minute - (int) l_time->tm_min)) +
+	  (long) (60*((int) t->minute - (int) l_time->tm_min)) +
           (long) ((int) t->second - (int) l_time->tm_sec));
     if (diff == 3600)
       tmp+=3600 - t->minute*60 - t->second;	/* Move to next hour */
@@ -970,6 +979,7 @@ long calc_daynr(uint year,uint month,uint day)
   }
   *my_timezone= current_timezone;
 
+
   /* shift back, if we were dealing with boundary dates */
   tmp+= shift*86400L;
 
@@ -989,6 +999,7 @@ long calc_daynr(uint year,uint month,uint day)
   return (my_time_t) tmp;
 } /* my_system_gmt_sec */
 
+
 /* Set MYSQL_TIME structure to 0000-00-00 00:00:00.000000 */
 
 void set_zero_time(MYSQL_TIME *tm, enum enum_mysql_timestamp_type time_type)
@@ -997,6 +1008,7 @@ void set_zero_time(MYSQL_TIME *tm, enum enum_mysql_timestamp_type time_type)
   tm->time_type= time_type;
 }
 
+
 /*
   Functions to convert time/date/datetime value to a string,
   using default format.
@@ -1030,6 +1042,7 @@ int my_datetime_to_str(const MYSQL_TIME *l_time, char *to)
                  l_time->hour, l_time->minute, l_time->second);
 }
 
+
 /*
   Convert struct DATE/TIME/DATETIME value to string using built-in
   MySQL time conversion formats.
@@ -1060,6 +1073,7 @@ int my_TIME_to_str(const MYSQL_TIME *l_time, char *to)
   }
 }
 
+
 /*
   Convert datetime value specified as number to broken-down TIME
   representation and form value of DATETIME type as side-effect.
@@ -1166,6 +1180,7 @@ longlong number_to_datetime(longlong nr, MYSQL_TIME *time_res,
   return LL(-1);
 }
 
+
 /* Convert time value to integer in YYYYMMDDHHMMSS format */
 
 ulonglong TIME_to_ulonglong_datetime(const MYSQL_TIME *my_time)
@@ -1178,6 +1193,7 @@ ulonglong TIME_to_ulonglong_datetime(const MYSQL_TIME *my_time)
                        my_time->second));
 }
 
+
 /* Convert MYSQL_TIME value to integer in YYYYMMDD format */
 
 ulonglong TIME_to_ulonglong_date(const MYSQL_TIME *my_time)
@@ -1186,6 +1202,7 @@ ulonglong TIME_to_ulonglong_date(const MYSQL_TIME *my_time)
                       my_time->day);
 }
 
+
 /*
   Convert MYSQL_TIME value to integer in HHMMSS format.
   This function doesn't take into account time->day member:
@@ -1199,6 +1216,7 @@ ulonglong TIME_to_ulonglong_time(const MYSQL_TIME *my_time)
                       my_time->second);
 }
 
+
 /*
   Convert struct MYSQL_TIME (date and time split into year/month/day/hour/...
   to a number in format YYYYMMDDHHMMSS (DATETIME),
@@ -1235,4 +1253,5 @@ ulonglong TIME_to_ulonglong(const MYSQL_TIME *my_time)
     DBUG_ASSERT(0);
   }
   return 0;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/sql-common/pack.c b/dep/mysqllite/sql-common/pack.c
index 58696ee..7ff8947 100644
--- a/dep/mysqllite/sql-common/pack.c
+++ b/dep/mysqllite/sql-common/pack.c
@@ -117,4 +117,5 @@ uchar *net_store_length(uchar *packet, ulonglong length)
   *packet++=254;
   int8store(packet,length);
   return packet+8;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/sql/net_serv.cc b/dep/mysqllite/sql/net_serv.cc
index dc36743..e2cc320 100644
--- a/dep/mysqllite/sql/net_serv.cc
+++ b/dep/mysqllite/sql/net_serv.cc
@@ -30,7 +30,7 @@
 */
 
 /*
-  HFTODO this must be hidden if we don't want client capabilities in
+  HFTODO this must be hidden if we don't want client capabilities in 
   embedded library
  */
 #include <my_global.h>
@@ -51,6 +51,7 @@
 #define MYSQL_CLIENT
 #endif /*EMBEDDED_LIBRARY */
 
+
 /*
   The following handles the differences when this is linked between the
   client and the server.
@@ -104,6 +105,7 @@ extern void query_cache_insert(const char *packet, ulong length,
 
 static my_bool net_write_buff(NET *net,const uchar *packet,ulong len);
 
+
 /** Init with packet info. */
 
 my_bool my_net_init(NET *net, Vio* vio)
@@ -112,8 +114,8 @@ my_bool my_net_init(NET *net, Vio* vio)
   net->vio = vio;
   my_net_local_init(net);			/* Set some limits */
   if (!(net->buff=(uchar*) my_malloc((size_t) net->max_packet+
-                     NET_HEADER_SIZE + COMP_HEADER_SIZE,
-                     MYF(MY_WME))))
+				     NET_HEADER_SIZE + COMP_HEADER_SIZE,
+				     MYF(MY_WME))))
     DBUG_RETURN(1);
   net->buff_end=net->buff+net->max_packet;
   net->error=0; net->return_status=0;
@@ -143,6 +145,7 @@ my_bool my_net_init(NET *net, Vio* vio)
   DBUG_RETURN(0);
 }
 
+
 void net_end(NET *net)
 {
   DBUG_ENTER("net_end");
@@ -151,6 +154,7 @@ void net_end(NET *net)
   DBUG_VOID_RETURN;
 }
 
+
 /** Realloc the packet buffer. */
 
 my_bool net_realloc(NET *net, size_t length)
@@ -172,7 +176,7 @@ my_bool net_realloc(NET *net, size_t length)
 #endif
     DBUG_RETURN(1);
   }
-  pkt_length = (length+IO_SIZE-1) & ~(IO_SIZE-1);
+  pkt_length = (length+IO_SIZE-1) & ~(IO_SIZE-1); 
   /*
     We must allocate some extra bytes for the end 0 and to be able to
     read big compressed blocks + 1 safety byte since uint3korr() in
@@ -194,6 +198,7 @@ my_bool net_realloc(NET *net, size_t length)
   DBUG_RETURN(0);
 }
 
+
 /**
   Check if there is any data to be read from the socket.
 
@@ -320,6 +325,7 @@ void net_clear(NET *net, my_bool clear_buffer)
   DBUG_VOID_RETURN;
 }
 
+
 /** Flush write_buffer if not empty. */
 
 my_bool net_flush(NET *net)
@@ -329,7 +335,7 @@ my_bool net_flush(NET *net)
   if (net->buff != net->write_pos)
   {
     error=test(net_real_write(net, net->buff,
-                  (size_t) (net->write_pos - net->buff)));
+			      (size_t) (net->write_pos - net->buff)));
     net->write_pos=net->buff;
   }
   /* Sync packet number if using compression */
@@ -338,6 +344,7 @@ my_bool net_flush(NET *net)
   DBUG_RETURN(error);
 }
 
+
 /*****************************************************************************
 ** Write something to server/client buffer
 *****************************************************************************/
@@ -374,7 +381,7 @@ my_bool net_flush(NET *net)
     int3store(buff, z_size);
     buff[3]= (uchar) net->pkt_nr++;
     if (net_write_buff(net, buff, NET_HEADER_SIZE) ||
-    net_write_buff(net, packet, z_size))
+	net_write_buff(net, packet, z_size))
     {
       MYSQL_NET_WRITE_DONE(1);
       return 1;
@@ -408,7 +415,7 @@ my_bool net_flush(NET *net)
     As the command is part of the first data packet, we have to do some data
     juggling to put the command in there, without having to create a new
     packet.
-
+  
     This function will split big packets into sub-packets if needed.
     (Each sub packet can only be 2^24 bytes)
 
@@ -427,8 +434,8 @@ my_bool net_flush(NET *net)
 
 my_bool
 net_write_command(NET *net,uchar command,
-          const uchar *header, size_t head_len,
-          const uchar *packet, size_t len)
+		  const uchar *header, size_t head_len,
+		  const uchar *packet, size_t len)
 {
   size_t length=len+1+head_len;			/* 1 extra byte for command */
   uchar buff[NET_HEADER_SIZE+1];
@@ -450,11 +457,11 @@ my_bool net_flush(NET *net)
       int3store(buff, MAX_PACKET_LENGTH);
       buff[3]= (uchar) net->pkt_nr++;
       if (net_write_buff(net, buff, header_size) ||
-      net_write_buff(net, header, head_len) ||
-      net_write_buff(net, packet, len))
+	  net_write_buff(net, header, head_len) ||
+	  net_write_buff(net, packet, len))
       {
         MYSQL_NET_WRITE_DONE(1);
-    DBUG_RETURN(1);
+	DBUG_RETURN(1);
       }
       packet+= len;
       length-= MAX_PACKET_LENGTH;
@@ -517,9 +524,9 @@ my_bool net_flush(NET *net)
     {
       /* Fill up already used packet and write it */
       memcpy((char*) net->write_pos,packet,left_length);
-      if (net_real_write(net, net->buff,
-             (size_t) (net->write_pos - net->buff) + left_length))
-    return 1;
+      if (net_real_write(net, net->buff, 
+			 (size_t) (net->write_pos - net->buff) + left_length))
+	return 1;
       net->write_pos= net->buff;
       packet+= left_length;
       len-= left_length;
@@ -527,16 +534,16 @@ my_bool net_flush(NET *net)
     if (net->compress)
     {
       /*
-    We can't have bigger packets than 16M with compression
-    Because the uncompressed length is stored in 3 bytes
+	We can't have bigger packets than 16M with compression
+	Because the uncompressed length is stored in 3 bytes
       */
       left_length= MAX_PACKET_LENGTH;
       while (len > left_length)
       {
-    if (net_real_write(net, packet, left_length))
-      return 1;
-    packet+= left_length;
-    len-= left_length;
+	if (net_real_write(net, packet, left_length))
+	  return 1;
+	packet+= left_length;
+	len-= left_length;
       }
     }
     if (len > net->max_packet)
@@ -548,6 +555,7 @@ my_bool net_flush(NET *net)
   return 0;
 }
 
+
 /**
   Read and write one packet using timeouts.
   If needed, the packet is compressed before sending.
@@ -629,44 +637,44 @@ my_bool net_flush(NET *net)
       {
         if (!thr_alarm(&alarmed, net->write_timeout, &alarm_buff))
         {                                       /* Always true for client */
-      my_bool old_mode;
-      while (vio_blocking(net->vio, TRUE, &old_mode) < 0)
-      {
-        if (vio_should_retry(net->vio) && retry_count++ < net->retry_count)
-          continue;
+	  my_bool old_mode;
+	  while (vio_blocking(net->vio, TRUE, &old_mode) < 0)
+	  {
+	    if (vio_should_retry(net->vio) && retry_count++ < net->retry_count)
+	      continue;
 #ifdef EXTRA_DEBUG
-        fprintf(stderr,
-            "%s: my_net_write: fcntl returned error %d, aborting thread\n",
-            my_progname,vio_errno(net->vio));
+	    fprintf(stderr,
+		    "%s: my_net_write: fcntl returned error %d, aborting thread\n",
+		    my_progname,vio_errno(net->vio));
 #endif /* EXTRA_DEBUG */
-        net->error= 2;                     /* Close socket */
+	    net->error= 2;                     /* Close socket */
             net->last_errno= ER_NET_PACKET_TOO_LARGE;
 #ifdef MYSQL_SERVER
             my_error(ER_NET_PACKET_TOO_LARGE, MYF(0));
 #endif
-        goto end;
-      }
-      retry_count=0;
-      continue;
-    }
+	    goto end;
+	  }
+	  retry_count=0;
+	  continue;
+	}
       }
       else
 #endif /* !defined(__WIN__) */
-    if (thr_alarm_in_use(&alarmed) && !thr_got_alarm(&alarmed) &&
-        interrupted)
+	if (thr_alarm_in_use(&alarmed) && !thr_got_alarm(&alarmed) &&
+	    interrupted)
       {
-    if (retry_count++ < net->retry_count)
-        continue;
+	if (retry_count++ < net->retry_count)
+	    continue;
 #ifdef EXTRA_DEBUG
-      fprintf(stderr, "%s: write looped, aborting thread\n",
-          my_progname);
+	  fprintf(stderr, "%s: write looped, aborting thread\n",
+		  my_progname);
 #endif /* EXTRA_DEBUG */
       }
 #if defined(THREAD_SAFE_CLIENT) && !defined(MYSQL_SERVER)
       if (vio_errno(net->vio) == SOCKET_EINTR)
       {
-    DBUG_PRINT("warning",("Interrupted write. Retrying..."));
-    continue;
+	DBUG_PRINT("warning",("Interrupted write. Retrying..."));
+	continue;
       }
 #endif /* defined(THREAD_SAFE_CLIENT) && !defined(MYSQL_SERVER) */
       net->error= 2;				/* Close socket */
@@ -697,6 +705,7 @@ my_bool net_flush(NET *net)
   DBUG_RETURN(((int) (pos != end)));
 }
 
+
 /*****************************************************************************
 ** Read something from server/clinet
 *****************************************************************************/
@@ -704,7 +713,7 @@ my_bool net_flush(NET *net)
 #ifndef NO_ALARM
 
 static my_bool net_safe_read(NET *net, uchar *buff, size_t length,
-                 thr_alarm_t *alarmed)
+			     thr_alarm_t *alarmed)
 {
   uint retry_count=0;
   while (length > 0)
@@ -715,8 +724,8 @@ static my_bool net_safe_read(NET *net, uchar *buff, size_t length,
       my_bool interrupted = vio_should_retry(net->vio);
       if (!thr_got_alarm(alarmed) && interrupted)
       {					/* Probably in MIT threads */
-    if (retry_count++ < net->retry_count)
-      continue;
+	if (retry_count++ < net->retry_count)
+	  continue;
       }
       return 1;
     }
@@ -741,7 +750,7 @@ static my_bool net_safe_read(NET *net, uchar *buff, size_t length,
 */
 
 static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
-                ALARM *alarm_buff)
+				ALARM *alarm_buff)
 {
   uint32 old=remain;
   DBUG_ENTER("my_net_skip_rest");
@@ -754,7 +763,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
   {
     my_bool old_mode;
     if (thr_alarm(alarmed,net->read_timeout, alarm_buff) ||
-    vio_blocking(net->vio, TRUE, &old_mode) < 0)
+	vio_blocking(net->vio, TRUE, &old_mode) < 0)
       DBUG_RETURN(1);				/* Can't setup, abort */
   }
   for (;;)
@@ -763,7 +772,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
     {
       size_t length= min(remain, net->max_packet);
       if (net_safe_read(net, net->buff, length, alarmed))
-    DBUG_RETURN(1);
+	DBUG_RETURN(1);
       update_statistics(thd_increment_bytes_received(length));
       remain -= (uint32) length;
     }
@@ -778,6 +787,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
 }
 #endif /* NO_ALARM */
 
+
 /**
   Reads one packet to net->buff + net->where_b.
   Long packets are handled by my_net_read().
@@ -800,7 +810,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
 #endif
   my_bool net_blocking=vio_is_blocking(net->vio);
   uint32 remain= (net->compress ? NET_HEADER_SIZE+COMP_HEADER_SIZE :
-          NET_HEADER_SIZE);
+		  NET_HEADER_SIZE);
   *complen = 0;
 
   net->reading_or_writing=1;
@@ -817,97 +827,97 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
     {
       while (remain > 0)
       {
-    /* First read is done with non blocking mode */
+	/* First read is done with non blocking mode */
         if ((long) (length= vio_read(net->vio, pos, remain)) <= 0L)
         {
           my_bool interrupted = vio_should_retry(net->vio);
 
-      DBUG_PRINT("info",("vio_read returned %ld  errno: %d",
-                 (long) length, vio_errno(net->vio)));
+	  DBUG_PRINT("info",("vio_read returned %ld  errno: %d",
+			     (long) length, vio_errno(net->vio)));
 #if !defined(__WIN__) || defined(MYSQL_SERVER)
-      /*
-        We got an error that there was no data on the socket. We now set up
-        an alarm to not 'read forever', change the socket to non blocking
-        mode and try again
-      */
-      if ((interrupted || length == 0) && !thr_alarm_in_use(&alarmed))
-      {
-        if (!thr_alarm(&alarmed,net->read_timeout,&alarm_buff)) /* Don't wait too long */
-        {
-          my_bool old_mode;
-          while (vio_blocking(net->vio, TRUE, &old_mode) < 0)
-          {
-        if (vio_should_retry(net->vio) &&
-            retry_count++ < net->retry_count)
-          continue;
-        DBUG_PRINT("error",
-               ("fcntl returned error %d, aborting thread",
-                vio_errno(net->vio)));
+	  /*
+	    We got an error that there was no data on the socket. We now set up
+	    an alarm to not 'read forever', change the socket to non blocking
+	    mode and try again
+	  */
+	  if ((interrupted || length == 0) && !thr_alarm_in_use(&alarmed))
+	  {
+	    if (!thr_alarm(&alarmed,net->read_timeout,&alarm_buff)) /* Don't wait too long */
+	    {
+	      my_bool old_mode;
+	      while (vio_blocking(net->vio, TRUE, &old_mode) < 0)
+	      {
+		if (vio_should_retry(net->vio) &&
+		    retry_count++ < net->retry_count)
+		  continue;
+		DBUG_PRINT("error",
+			   ("fcntl returned error %d, aborting thread",
+			    vio_errno(net->vio)));
 #ifdef EXTRA_DEBUG
-        fprintf(stderr,
-            "%s: read: fcntl returned error %d, aborting thread\n",
-            my_progname,vio_errno(net->vio));
+		fprintf(stderr,
+			"%s: read: fcntl returned error %d, aborting thread\n",
+			my_progname,vio_errno(net->vio));
 #endif /* EXTRA_DEBUG */
-        len= packet_error;
-        net->error= 2;                 /* Close socket */
-            net->last_errno= ER_NET_FCNTL_ERROR;
+		len= packet_error;
+		net->error= 2;                 /* Close socket */
+	        net->last_errno= ER_NET_FCNTL_ERROR;
 #ifdef MYSQL_SERVER
-        my_error(ER_NET_FCNTL_ERROR, MYF(0));
+		my_error(ER_NET_FCNTL_ERROR, MYF(0));
 #endif
-        goto end;
-          }
-          retry_count=0;
-          continue;
-        }
-      }
+		goto end;
+	      }
+	      retry_count=0;
+	      continue;
+	    }
+	  }
 #endif /* (!defined(__WIN__) || defined(MYSQL_SERVER) */
-      if (thr_alarm_in_use(&alarmed) && !thr_got_alarm(&alarmed) &&
-          interrupted)
-      {					/* Probably in MIT threads */
-        if (retry_count++ < net->retry_count)
-          continue;
+	  if (thr_alarm_in_use(&alarmed) && !thr_got_alarm(&alarmed) &&
+	      interrupted)
+	  {					/* Probably in MIT threads */
+	    if (retry_count++ < net->retry_count)
+	      continue;
 #ifdef EXTRA_DEBUG
-        fprintf(stderr, "%s: read looped with error %d, aborting thread\n",
-            my_progname,vio_errno(net->vio));
+	    fprintf(stderr, "%s: read looped with error %d, aborting thread\n",
+		    my_progname,vio_errno(net->vio));
 #endif /* EXTRA_DEBUG */
-      }
+	  }
 #if defined(THREAD_SAFE_CLIENT) && !defined(MYSQL_SERVER)
-      if (vio_errno(net->vio) == SOCKET_EINTR)
-      {
-        DBUG_PRINT("warning",("Interrupted read. Retrying..."));
-        continue;
-      }
+	  if (vio_errno(net->vio) == SOCKET_EINTR)
+	  {
+	    DBUG_PRINT("warning",("Interrupted read. Retrying..."));
+	    continue;
+	  }
 #endif
-      DBUG_PRINT("error",("Couldn't read packet: remain: %u  errno: %d  length: %ld",
-                  remain, vio_errno(net->vio), (long) length));
-      len= packet_error;
-      net->error= 2;				/* Close socket */
+	  DBUG_PRINT("error",("Couldn't read packet: remain: %u  errno: %d  length: %ld",
+			      remain, vio_errno(net->vio), (long) length));
+	  len= packet_error;
+	  net->error= 2;				/* Close socket */
           net->last_errno= (vio_was_interrupted(net->vio) ?
                                    ER_NET_READ_INTERRUPTED :
                                    ER_NET_READ_ERROR);
 #ifdef MYSQL_SERVER
           my_error(net->last_errno, MYF(0));
 #endif
-      goto end;
-    }
-    remain -= (uint32) length;
-    pos+= length;
-    update_statistics(thd_increment_bytes_received(length));
+	  goto end;
+	}
+	remain -= (uint32) length;
+	pos+= length;
+	update_statistics(thd_increment_bytes_received(length));
       }
       if (i == 0)
       {					/* First parts is packet length */
-    ulong helping;
+	ulong helping;
         DBUG_DUMP("packet_header", net->buff+net->where_b,
                   NET_HEADER_SIZE);
-    if (net->buff[net->where_b + 3] != (uchar) net->pkt_nr)
-    {
-      if (net->buff[net->where_b] != (uchar) 255)
-      {
-        DBUG_PRINT("error",
-               ("Packets out of order (Found: %d, expected %u)",
-            (int) net->buff[net->where_b + 3],
-            net->pkt_nr));
-            /*
+	if (net->buff[net->where_b + 3] != (uchar) net->pkt_nr)
+	{
+	  if (net->buff[net->where_b] != (uchar) 255)
+	  {
+	    DBUG_PRINT("error",
+		       ("Packets out of order (Found: %d, expected %u)",
+			(int) net->buff[net->where_b + 3],
+			net->pkt_nr));
+            /* 
               We don't make noise server side, since the client is expected
               to break the protocol for e.g. --send LOAD DATA .. LOCAL where
               the server expects the client to send a file, but the client
@@ -915,24 +925,24 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
             */
 #if defined (EXTRA_DEBUG) && !defined (MYSQL_SERVER)
             fflush(stdout);
-        fprintf(stderr,"Error: Packets out of order (Found: %d, expected %d)\n",
-            (int) net->buff[net->where_b + 3],
-            (uint) (uchar) net->pkt_nr);
+	    fprintf(stderr,"Error: Packets out of order (Found: %d, expected %d)\n",
+		    (int) net->buff[net->where_b + 3],
+		    (uint) (uchar) net->pkt_nr);
             fflush(stderr);
             DBUG_ASSERT(0);
 #endif
-      }
-      len= packet_error;
+	  }
+	  len= packet_error;
           /* Not a NET error on the client. XXX: why? */
 #ifdef MYSQL_SERVER
-      my_error(ER_NET_PACKETS_OUT_OF_ORDER, MYF(0));
+	  my_error(ER_NET_PACKETS_OUT_OF_ORDER, MYF(0));
 #endif
-      goto end;
-    }
-    net->compress_pkt_nr= ++net->pkt_nr;
+	  goto end;
+	}
+	net->compress_pkt_nr= ++net->pkt_nr;
 #ifdef HAVE_COMPRESS
-    if (net->compress)
-    {
+	if (net->compress)
+	{
           /*
             The following uint3korr() may read 4 bytes, so make sure we don't
             read unallocated or uninitialized memory. The right-hand expression
@@ -940,35 +950,35 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
           */
           DBUG_ASSERT(net->where_b + NET_HEADER_SIZE + sizeof(uint32) <=
                       net->max_packet + NET_HEADER_SIZE + COMP_HEADER_SIZE + 1);
-      /*
-        If the packet is compressed then complen > 0 and contains the
-        number of bytes in the uncompressed packet
-      */
-      *complen=uint3korr(&(net->buff[net->where_b + NET_HEADER_SIZE]));
-    }
+	  /*
+	    If the packet is compressed then complen > 0 and contains the
+	    number of bytes in the uncompressed packet
+	  */
+	  *complen=uint3korr(&(net->buff[net->where_b + NET_HEADER_SIZE]));
+	}
 #endif
 
-    len=uint3korr(net->buff+net->where_b);
-    if (!len)				/* End of big multi-packet */
-      goto end;
-    helping = max(len,*complen) + net->where_b;
-    /* The necessary size of net->buff */
-    if (helping >= net->max_packet)
-    {
-      if (net_realloc(net,helping))
-      {
+	len=uint3korr(net->buff+net->where_b);
+	if (!len)				/* End of big multi-packet */
+	  goto end;
+	helping = max(len,*complen) + net->where_b;
+	/* The necessary size of net->buff */
+	if (helping >= net->max_packet)
+	{
+	  if (net_realloc(net,helping))
+	  {
 #if defined(MYSQL_SERVER) && !defined(NO_ALARM)
-        if (!net->compress &&
+	    if (!net->compress &&
                 net->skip_big_packet &&
-        !my_net_skip_rest(net, (uint32) len, &alarmed, &alarm_buff))
-          net->error= 3;		/* Successfully skiped packet */
+		!my_net_skip_rest(net, (uint32) len, &alarmed, &alarm_buff))
+	      net->error= 3;		/* Successfully skiped packet */
 #endif
-        len= packet_error;          /* Return error and close connection */
-        goto end;
-      }
-    }
-    pos=net->buff + net->where_b;
-    remain = (uint32) len;
+	    len= packet_error;          /* Return error and close connection */
+	    goto end;
+	  }
+	}
+	pos=net->buff + net->where_b;
+	remain = (uint32) len;
       }
     }
 
@@ -987,6 +997,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
   return(len);
 }
 
+
 /**
   Read a packet from the client/server and return it without the internal
   package header.
@@ -1022,12 +1033,12 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
       size_t total_length= 0;
       do
       {
-    net->where_b += len;
-    total_length += len;
-    len = my_real_read(net,&complen);
+	net->where_b += len;
+	total_length += len;
+	len = my_real_read(net,&complen);
       } while (len == MAX_PACKET_LENGTH);
       if (len != packet_error)
-    len+= total_length;
+	len+= total_length;
       net->where_b = save_pos;
     }
     net->read_pos = net->buff + net->where_b;
@@ -1050,7 +1061,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
     {
       buf_length= net->buf_length;		/* Data left in old packet */
       first_packet_offset= start_of_packet= (net->buf_length -
-                         net->remain_in_buf);
+					     net->remain_in_buf);
       /* Restore the character that was overwritten by the end 0 */
       net->buff[start_of_packet]= net->save_char;
     }
@@ -1065,72 +1076,72 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
 
       if (buf_length - start_of_packet >= NET_HEADER_SIZE)
       {
-    read_length = uint3korr(net->buff+start_of_packet);
-    if (!read_length)
-    {
-      /* End of multi-byte packet */
-      start_of_packet += NET_HEADER_SIZE;
-      break;
-    }
-    if (read_length + NET_HEADER_SIZE <= buf_length - start_of_packet)
-    {
-      if (multi_byte_packet)
-      {
-        /* Remove packet header for second packet */
-        memmove(net->buff + first_packet_offset + start_of_packet,
-            net->buff + first_packet_offset + start_of_packet +
-            NET_HEADER_SIZE,
-            buf_length - start_of_packet);
-        start_of_packet += read_length;
-        buf_length -= NET_HEADER_SIZE;
-      }
-      else
-        start_of_packet+= read_length + NET_HEADER_SIZE;
-
-      if (read_length != MAX_PACKET_LENGTH)	/* last package */
-      {
-        multi_byte_packet= 0;		/* No last zero len packet */
-        break;
-      }
-      multi_byte_packet= NET_HEADER_SIZE;
-      /* Move data down to read next data packet after current one */
-      if (first_packet_offset)
-      {
-        memmove(net->buff,net->buff+first_packet_offset,
-            buf_length-first_packet_offset);
-        buf_length-=first_packet_offset;
-        start_of_packet -= first_packet_offset;
-        first_packet_offset=0;
-      }
-      continue;
-    }
+	read_length = uint3korr(net->buff+start_of_packet);
+	if (!read_length)
+	{ 
+	  /* End of multi-byte packet */
+	  start_of_packet += NET_HEADER_SIZE;
+	  break;
+	}
+	if (read_length + NET_HEADER_SIZE <= buf_length - start_of_packet)
+	{
+	  if (multi_byte_packet)
+	  {
+	    /* Remove packet header for second packet */
+	    memmove(net->buff + first_packet_offset + start_of_packet,
+		    net->buff + first_packet_offset + start_of_packet +
+		    NET_HEADER_SIZE,
+		    buf_length - start_of_packet);
+	    start_of_packet += read_length;
+	    buf_length -= NET_HEADER_SIZE;
+	  }
+	  else
+	    start_of_packet+= read_length + NET_HEADER_SIZE;
+
+	  if (read_length != MAX_PACKET_LENGTH)	/* last package */
+	  {
+	    multi_byte_packet= 0;		/* No last zero len packet */
+	    break;
+	  }
+	  multi_byte_packet= NET_HEADER_SIZE;
+	  /* Move data down to read next data packet after current one */
+	  if (first_packet_offset)
+	  {
+	    memmove(net->buff,net->buff+first_packet_offset,
+		    buf_length-first_packet_offset);
+	    buf_length-=first_packet_offset;
+	    start_of_packet -= first_packet_offset;
+	    first_packet_offset=0;
+	  }
+	  continue;
+	}
       }
       /* Move data down to read next data packet after current one */
       if (first_packet_offset)
       {
-    memmove(net->buff,net->buff+first_packet_offset,
-        buf_length-first_packet_offset);
-    buf_length-=first_packet_offset;
-    start_of_packet -= first_packet_offset;
-    first_packet_offset=0;
+	memmove(net->buff,net->buff+first_packet_offset,
+		buf_length-first_packet_offset);
+	buf_length-=first_packet_offset;
+	start_of_packet -= first_packet_offset;
+	first_packet_offset=0;
       }
 
       net->where_b=buf_length;
       if ((packet_len = my_real_read(net,&complen)) == packet_error)
       {
         MYSQL_NET_READ_DONE(1, 0);
-    return packet_error;
+	return packet_error;
       }
       if (my_uncompress(net->buff + net->where_b, packet_len,
-            &complen))
+			&complen))
       {
-    net->error= 2;			/* caller will close socket */
+	net->error= 2;			/* caller will close socket */
         net->last_errno= ER_NET_UNCOMPRESS_ERROR;
 #ifdef MYSQL_SERVER
-    my_error(ER_NET_UNCOMPRESS_ERROR, MYF(0));
+	my_error(ER_NET_UNCOMPRESS_ERROR, MYF(0));
 #endif
         MYSQL_NET_READ_DONE(1, 0);
-    return packet_error;
+	return packet_error;
       }
       buf_length+= complen;
     }
@@ -1148,6 +1159,7 @@ static my_bool my_net_skip_rest(NET *net, uint32 remain, thr_alarm_t *alarmed,
   return len;
 }
 
+
 void my_net_set_read_timeout(NET *net, uint timeout)
 {
   DBUG_ENTER("my_net_set_read_timeout");
@@ -1160,6 +1172,7 @@ void my_net_set_read_timeout(NET *net, uint timeout)
   DBUG_VOID_RETURN;
 }
 
+
 void my_net_set_write_timeout(NET *net, uint timeout)
 {
   DBUG_ENTER("my_net_set_write_timeout");
@@ -1170,4 +1183,4 @@ void my_net_set_write_timeout(NET *net, uint timeout)
     vio_timeout(net->vio, 1, timeout);
 #endif
   DBUG_VOID_RETURN;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/sql/password.c b/dep/mysqllite/sql/password.c
index dbddf9b..afa514a 100644
--- a/dep/mysqllite/sql/password.c
+++ b/dep/mysqllite/sql/password.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -45,10 +45,11 @@
            hash_stage2=sha1(hash_stage1)
            reply=xor(hash_stage1, sha1(public_seed,hash_stage2)
 
-           // this three steps are done in scramble()
+           // this three steps are done in scramble() 
 
            send(reply)
 
+     
   SERVER:  recv(reply)
            hash_stage1=xor(reply, sha1(public_seed,hash_stage2))
            candidate_hash2=sha1(hash_stage1)
@@ -87,6 +88,7 @@ void randominit(struct rand_struct *rand_st, ulong seed1, ulong seed2)
   rand_st->seed2=seed2%rand_st->max_value;
 }
 
+
 /*
     Generate random number.
   SYNOPSIS
@@ -103,8 +105,9 @@ double my_rnd(struct rand_struct *rand_st)
   return (((double) rand_st->seed1)/rand_st->max_value_dbl);
 }
 
+
 /*
-    Generate binary hash from raw text string
+    Generate binary hash from raw text string 
     Used for Pre-4.1 password handling
   SYNOPSIS
     hash_password()
@@ -131,6 +134,7 @@ void hash_password(ulong *result, const char *password, uint password_len)
   result[1]=nr2 & (((ulong) 1L << 31) -1L);
 }
 
+
 /*
     Create password to be stored in user database from raw string
     Used for pre-4.1 password handling
@@ -149,6 +153,7 @@ void my_make_scrambled_password_323(char *to, const char *password,
   sprintf(to, "%08lx%08lx", hash_res[0], hash_res[1]);
 }
 
+
 /*
   Wrapper around my_make_scrambled_password_323() to maintain client lib ABI
   compatibility.
@@ -165,6 +170,7 @@ void make_scrambled_password_323(char *to, const char *password)
   my_make_scrambled_password_323(to, password, strlen(password));
 }
 
+
 /*
     Scramble string with password.
     Used in pre 4.1 authentication phase.
@@ -199,6 +205,7 @@ void scramble_323(char *to, const char *message, const char *password)
   *to= 0;
 }
 
+
 /**
   Check scrambled message. Used in pre 4.1 password handling.
 
@@ -252,11 +259,12 @@ static inline uint8 char_val(uint8 X)
       X >= 'A' && X <= 'Z' ? X-'A'+10 : X-'a'+10);
 }
 
+
 /*
     Convert password from hex string (as stored in mysql.user) to binary form.
   SYNOPSIS
     get_salt_from_password_323()
-    res       OUT store salt here
+    res       OUT store salt here 
     password  IN  password string as stored in mysql.user
   NOTE
     This function does not have length check for passwords. It will just crash
@@ -279,12 +287,13 @@ void get_salt_from_password_323(ulong *res, const char *password)
   }
 }
 
+
 /*
     Convert scrambled password from binary form to asciiz hex string.
   SYNOPSIS
     make_password_from_salt_323()
-    to    OUT store resulting string password here, at least 17 bytes
-    salt  IN  password in salt format, 2 ulongs
+    to    OUT store resulting string password here, at least 17 bytes 
+    salt  IN  password in salt format, 2 ulongs 
 */
 
 void make_password_from_salt_323(char *to, const ulong *salt)
@@ -292,6 +301,7 @@ void make_password_from_salt_323(char *to, const ulong *salt)
   sprintf(to,"%08lx%08lx", salt[0], salt[1]);
 }
 
+
 /*
      **************** MySQL 4.1.1 authentication routines *************
 */
@@ -315,10 +325,12 @@ void create_random_string(char *to, uint length, struct rand_struct *rand_st)
   *to= '\0';
 }
 
+
 /* Character to use as version identifier for version 4.1 */
 
 #define PVERSION41_CHAR '*'
 
+
 /*
     Convert given octet sequence to asciiz string of hex characters;
     str..str+len and 'to' may not overlap.
@@ -333,7 +345,7 @@ void create_random_string(char *to, uint length, struct rand_struct *rand_st)
 
 char *octet2hex(char *to, const char *str, uint len)
 {
-  const char *str_end= str + len;
+  const char *str_end= str + len; 
   for (; str != str_end; ++str)
   {
     *to++= _dig_vec_upper[((uchar) *str) >> 4];
@@ -343,6 +355,7 @@ char *octet2hex(char *to, const char *str, uint len)
   return to;
 }
 
+
 /*
     Convert given asciiz string of hex (0..9 a..f) characters to octet
     sequence.
@@ -351,7 +364,7 @@ char *octet2hex(char *to, const char *str, uint len)
     to        OUT buffer to place result; must be at least len/2 bytes
     str, len  IN  begin, length for character string; str and to may not
                   overlap; len % 2 == 0
-*/
+*/ 
 
 static void
 hex2octet(uint8 *to, const char *str, uint len)
@@ -364,6 +377,7 @@ char *octet2hex(char *to, const char *str, uint len)
   }
 }
 
+
 /*
     Encrypt/Decrypt function used for password encryption in authentication.
     Simple XOR is used here but it is OK as we crypt random strings. Note,
@@ -384,6 +398,7 @@ char *octet2hex(char *to, const char *str, uint len)
     *to++= *s1++ ^ *s2++;
 }
 
+
 /*
     MySQL 4.1.1 password hashing: SHA conversion (see RFC 2289, 3174) twice
     applied to the password string, and then produced octet sequence is
@@ -416,6 +431,7 @@ void my_make_scrambled_password(char *to, const char *password,
   *to++= PVERSION41_CHAR;
   octet2hex(to, (const char*) hash_stage2, SHA1_HASH_SIZE);
 }
+  
 
 /*
   Wrapper around my_make_scrambled_password() to maintain client lib ABI
@@ -433,6 +449,7 @@ void make_scrambled_password(char *to, const char *password)
   my_make_scrambled_password(to, password, strlen(password));
 }
 
+
 /*
     Produce an obscure octet sequence from password and random
     string, recieved from the server. This sequence corresponds to the
@@ -443,11 +460,11 @@ void make_scrambled_password(char *to, const char *password)
     server's greeting.
   SYNOPSIS
     scramble()
-    buf       OUT store scrambled string here. The buf must be at least
-                  SHA1_HASH_SIZE bytes long.
-    message   IN  random message, must be exactly SCRAMBLE_LENGTH long and
+    buf       OUT store scrambled string here. The buf must be at least 
+                  SHA1_HASH_SIZE bytes long. 
+    message   IN  random message, must be exactly SCRAMBLE_LENGTH long and 
                   NULL-terminated.
-    password  IN  users' password
+    password  IN  users' password 
 */
 
 void
@@ -474,6 +491,7 @@ void make_scrambled_password(char *to, const char *password)
   my_crypt(to, (const uchar *) to, hash_stage1, SCRAMBLE_LENGTH);
 }
 
+
 /*
     Check that scrambled message corresponds to the password; the function
     is used by server to check that recieved reply is authentic.
@@ -484,7 +502,7 @@ void make_scrambled_password(char *to, const char *password)
     check_scramble()
     scramble     clients' reply, presumably produced by scramble()
     message      original random string, previously sent to client
-                 (presumably second argument of scramble()), must be
+                 (presumably second argument of scramble()), must be 
                  exactly SCRAMBLE_LENGTH long and NULL-terminated.
     hash_stage2  hex2octet-decoded database entry
     All params are IN.
@@ -513,9 +531,10 @@ void make_scrambled_password(char *to, const char *password)
   mysql_sha1_reset(&sha1_context);
   mysql_sha1_input(&sha1_context, buf, SHA1_HASH_SIZE);
   mysql_sha1_result(&sha1_context, hash_stage2_reassured);
-  return memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);
+  return test(memcmp(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE));
 }
 
+
 /*
   Convert scrambled password from asciiz hex string to binary form.
 
@@ -525,7 +544,7 @@ void make_scrambled_password(char *to, const char *password)
                   bytes long.
     password  IN  4.1.1 version value of user.password
 */
-
+    
 void get_salt_from_password(uint8 *hash_stage2, const char *password)
 {
   hex2octet(hash_stage2, password+1 /* skip '*' */, SHA1_HASH_SIZE * 2);
@@ -535,7 +554,7 @@ void get_salt_from_password(uint8 *hash_stage2, const char *password)
     Convert scrambled password from binary form to asciiz hex string.
   SYNOPSIS
     make_password_from_salt()
-    to    OUT store resulting string here, 2*SHA1_HASH_SIZE+2 bytes
+    to    OUT store resulting string here, 2*SHA1_HASH_SIZE+2 bytes 
     salt  IN  password in salt format
 */
 
@@ -543,4 +562,4 @@ void make_password_from_salt(char *to, const uint8 *hash_stage2)
 {
   *to++= PVERSION41_CHAR;
   octet2hex(to, (const char*) hash_stage2, SHA1_HASH_SIZE);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/bchange.c b/dep/mysqllite/strings/bchange.c
index 430c85d..ed7b2e1 100644
--- a/dep/mysqllite/strings/bchange.c
+++ b/dep/mysqllite/strings/bchange.c
@@ -28,7 +28,7 @@
 #include "m_string.h"
 
 void bchange(register uchar *dst, size_t old_length, register const uchar *src,
-         size_t new_length, size_t tot_length)
+	     size_t new_length, size_t tot_length)
 {
   size_t rest=tot_length-old_length;
   if (old_length < new_length)
@@ -36,4 +36,4 @@ void bchange(register uchar *dst, size_t old_length, register const uchar *src,
   else
     bmove(dst+new_length,dst+old_length,rest);
   memcpy(dst,src,new_length);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/bmove_upp.c b/dep/mysqllite/strings/bmove_upp.c
index 1aba086..f05cc18 100644
--- a/dep/mysqllite/strings/bmove_upp.c
+++ b/dep/mysqllite/strings/bmove_upp.c
@@ -29,4 +29,4 @@ void bmove_upp(register uchar *dst, register const uchar *src,
                register size_t len)
 {
   while (len-- != 0) *--dst = *--src;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/ctype-big5.c b/dep/mysqllite/strings/ctype-big5.c
index 634b107..6d2e725 100644
--- a/dep/mysqllite/strings/ctype-big5.c
+++ b/dep/mysqllite/strings/ctype-big5.c
@@ -32,9 +32,9 @@
 
 #ifdef HAVE_CHARSET_big5
 
-/*
+/* 
   Support for Chinese(BIG5) characters, by jou@nematic.ieo.nctu.edu.tw
-  modified by Wei He (hewei@mail.ied.ac.cn)
+  modified by Wei He (hewei@mail.ied.ac.cn) 
   modified by Alex Barkov <bar@udm.net>
 */
 
@@ -176,6 +176,7 @@
   (uchar) '\370',(uchar) '\371',(uchar) '\372',(uchar) '\373',(uchar) '\374',(uchar) '\375',(uchar) '\376',(uchar) '\377',
 };
 
+
 static MY_UNICASE_INFO cA2[256]=
 {
   /* A200-A20F */
@@ -368,6 +369,7 @@
   {0x0000,0x0000,0x0000}
 };
 
+
 static MY_UNICASE_INFO cA3[256]=
 {
   /* A300-A30F */
@@ -560,6 +562,7 @@
   {0x0000,0x0000,0x0000}
 };
 
+
 static MY_UNICASE_INFO cC7[256]=
 {
   /* C700-C70F */
@@ -649,7 +652,7 @@
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   /* C7A0-C7AF */
-  {0x0000,0x0000,0x0000},
+  {0x0000,0x0000,0x0000}, 
   {0xC7A1,0xC7A1,0x30E7},
   {0xC7A2,0xC7A2,0x30E8},
   {0xC7A3,0xC7A3,0x30E9},
@@ -752,6 +755,7 @@
   {0x0000,0x0000,0x0000}
 };
 
+
 static MY_UNICASE_INFO *my_caseinfo_big5[256]=
 {
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 0 */
@@ -788,6 +792,7 @@
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 };
 
+
 static uint16 big5strokexfrm(uint16 i)
 {
   if ((i == 0xA440) || (i == 0xA441))  return 0xA440;
@@ -829,8 +834,10 @@ static uint16 big5strokexfrm(uint16 i)
   return 0xA140;
 }
 
+
+
 static int my_strnncoll_big5_internal(const uchar **a_res,
-                      const uchar **b_res, size_t length)
+				      const uchar **b_res, size_t length)
 {
   const uchar *a= *a_res, *b= *b_res;
 
@@ -839,26 +846,27 @@ static int my_strnncoll_big5_internal(const uchar **a_res,
     if ((length > 0) && isbig5code(*a,*(a+1)) && isbig5code(*b, *(b+1)))
     {
       if (*a != *b || *(a+1) != *(b+1))
-    return ((int) big5code(*a,*(a+1)) -
-        (int) big5code(*b,*(b+1)));
+	return ((int) big5code(*a,*(a+1)) -
+		(int) big5code(*b,*(b+1)));
       a+= 2;
       b+= 2;
       length--;
     }
     else if (sort_order_big5[*a++] !=
-         sort_order_big5[*b++])
+	     sort_order_big5[*b++])
       return ((int) sort_order_big5[a[-1]] -
-          (int) sort_order_big5[b[-1]]);
+	      (int) sort_order_big5[b[-1]]);
   }
   *a_res= a;
   *b_res= b;
   return 0;
 }
 
+
 /* Compare strings */
 
-static int my_strnncoll_big5(CHARSET_INFO *cs __attribute__((unused)),
-                 const uchar *a, size_t a_length,
+static int my_strnncoll_big5(CHARSET_INFO *cs __attribute__((unused)), 
+			     const uchar *a, size_t a_length,
                              const uchar *b, size_t b_length,
                              my_bool b_is_prefix)
 {
@@ -867,11 +875,12 @@ static int my_strnncoll_big5(CHARSET_INFO *cs __attribute__((unused)),
   return res ? res : (int)((b_is_prefix ? length : a_length) - b_length);
 }
 
+
 /* compare strings, ignore end space */
 
-static int my_strnncollsp_big5(CHARSET_INFO * cs __attribute__((unused)),
-                   const uchar *a, size_t a_length,
-                   const uchar *b, size_t b_length,
+static int my_strnncollsp_big5(CHARSET_INFO * cs __attribute__((unused)), 
+			       const uchar *a, size_t a_length, 
+			       const uchar *b, size_t b_length,
                                my_bool diff_if_only_endspace_difference)
 {
   size_t length= min(a_length, b_length);
@@ -902,14 +911,15 @@ static int my_strnncollsp_big5(CHARSET_INFO * cs __attribute__((unused)),
     for (end= a + a_length-length; a < end ; a++)
     {
       if (*a != ' ')
-    return (*a < ' ') ? -swap : swap;
+	return (*a < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 static size_t my_strnxfrm_big5(CHARSET_INFO *cs __attribute__((unused)),
-                               uchar *dest, size_t len,
+                               uchar *dest, size_t len, 
                                const uchar *src, size_t srclen)
 {
   uint16 e;
@@ -938,18 +948,19 @@ static size_t my_strnxfrm_big5(CHARSET_INFO *cs __attribute__((unused)),
 #if 0
 static int my_strcoll_big5(const uchar *s1, const uchar *s2)
 {
+
   while (*s1 && *s2)
   {
     if (*(s1+1) && *(s2+1) && isbig5code(*s1,*(s1+1)) && isbig5code(*s2, *(s2+1)))
     {
       if (*s1 != *s2 || *(s1+1) != *(s2+1))
-    return ((int) big5code(*s1,*(s1+1)) -
-        (int) big5code(*s2,*(s2+1)));
+	return ((int) big5code(*s1,*(s1+1)) -
+		(int) big5code(*s2,*(s2+1)));
       s1 +=2;
       s2 +=2;
     } else if (sort_order_big5[(uchar) *s1++] != sort_order_big5[(uchar) *s2++])
       return ((int) sort_order_big5[(uchar) s1[-1]] -
-          (int) sort_order_big5[(uchar) s2[-1]]);
+	      (int) sort_order_big5[(uchar) s2[-1]]);
   }
   return 0;
 }
@@ -982,17 +993,20 @@ static int my_strxfrm_big5(uchar *dest, const uchar *src, int len)
 }
 #endif
 
+
 static uint ismbchar_big5(CHARSET_INFO *cs __attribute__((unused)),
                          const char* p, const char *e)
 {
   return (isbig5head(*(p)) && (e)-(p)>1 && isbig5tail(*((p)+1))? 2: 0);
 }
 
+
 static uint mbcharlen_big5(CHARSET_INFO *cs __attribute__((unused)), uint c)
 {
   return (isbig5head(c)? 2 : 1);
 }
 
+
 /* page 0 0xA140-0xC7FC */
 static uint16 tab_big5_uni0[]={
 0x3000,0xFF0C,0x3001,0x3002,0xFF0E,0x2022,0xFF1B,0xFF1A,
@@ -3803,6 +3817,7 @@ static int func_big5_uni_onechar(int code){
   return(0);
 }
 
+
 /* page 0 0x00A2-0x00F7 */
 static uint16 tab_uni_big50[]={
 0xA246,0xA247,     0,0xA244,     0,0xA1B1,     0,     0,
@@ -6761,57 +6776,62 @@ static int func_uni_big5_onechar(int code){
   return(0);
 }
 
+
 static int
 my_wc_mb_big5(CHARSET_INFO *cs __attribute__((unused)),
-          my_wc_t wc, uchar *s, uchar *e)
+	      my_wc_t wc, uchar *s, uchar *e)
 {
+
   int code;
 
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((int) wc < 0x80)
   {
     s[0]= (uchar) wc;
     return 1;
   }
-
+  
   if (!(code=func_uni_big5_onechar(wc)))
     return MY_CS_ILUNI;
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL;
-
+  
   s[0]=code>>8;
   s[1]=code&0xFF;
-
+  
   return 2;
 }
 
-static int
+
+static int 
 my_mb_wc_big5(CHARSET_INFO *cs __attribute__((unused)),
-          my_wc_t *pwc,const uchar *s,const uchar *e)
+	      my_wc_t *pwc,const uchar *s,const uchar *e)
 {
-  int hi;
 
+  int hi;
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((hi= s[0]) < 0x80)
   {
     pwc[0]=hi;
     return 1;
   }
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
 
   if (!(pwc[0]=func_big5_uni_onechar((hi<<8)+s[1])))
     return -2;
-
+  
   return 2;
 }
 
+
 /*
   Returns a well formed length of a BIG5 string.
   CP950 and HKSCS additional characters are also accepted.
@@ -6847,6 +6867,7 @@ size_t my_well_formed_len_big5(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (b - b0);
 }
 
+
 static MY_COLLATION_HANDLER my_collation_big5_chinese_ci_handler =
 {
   NULL,			/* init */
@@ -6925,6 +6946,7 @@ size_t my_well_formed_len_big5(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_big5_chinese_ci_handler
 };
 
+
 CHARSET_INFO my_charset_big5_bin=
 {
     84,0,0, 		/* number     */
@@ -6957,4 +6979,5 @@ size_t my_well_formed_len_big5(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_mb_bin_handler
 };
 
-#endif
\ No newline at end of file
+
+#endif
diff --git a/dep/mysqllite/strings/ctype-bin.c b/dep/mysqllite/strings/ctype-bin.c
index 1bed5b1..ed674da 100644
--- a/dep/mysqllite/strings/ctype-bin.c
+++ b/dep/mysqllite/strings/ctype-bin.c
@@ -1,15 +1,15 @@
 /* Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved. & tommy@valley.ne.jp.
-
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
@@ -17,6 +17,7 @@
 
 /* This file is for binary pseudo charset, created by bar@mysql.com */
 
+
 #include <my_global.h>
 #include "m_string.h"
 #include "m_ctype.h"
@@ -42,6 +43,7 @@
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 };
 
+
 /* Dummy array for toupper / tolower / sortorder */
 
 static uchar bin_char_array[] =
@@ -64,11 +66,12 @@
   240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
 };
 
-static my_bool
+
+static my_bool 
 my_coll_init_8bit_bin(CHARSET_INFO *cs,
                       void *(*alloc)(size_t) __attribute__((unused)))
 {
-  cs->max_sort_char=255;
+  cs->max_sort_char=255; 
   return FALSE;
 }
 
@@ -82,6 +85,7 @@ static int my_strnncoll_binary(CHARSET_INFO * cs __attribute__((unused)),
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
 
+
 size_t my_lengthsp_binary(CHARSET_INFO *cs __attribute__((unused)),
                           const char *ptr __attribute__((unused)),
                           size_t length)
@@ -89,6 +93,7 @@ size_t my_lengthsp_binary(CHARSET_INFO *cs __attribute__((unused)),
   return length;
 }
 
+
 /*
   Compare two strings. Result is sign(first_argument - second_argument)
 
@@ -120,6 +125,7 @@ static int my_strnncollsp_binary(CHARSET_INFO * cs __attribute__((unused)),
   return my_strnncoll_binary(cs,s,slen,t,tlen,0);
 }
 
+
 static int my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
                                  const uchar *s, size_t slen,
                                  const uchar *t, size_t tlen,
@@ -130,6 +136,7 @@ static int my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
   return cmp ? cmp : (int)((t_is_prefix ? len : slen) - tlen);
 }
 
+
 /*
   Compare two strings. Result is sign(first_argument - second_argument)
 
@@ -141,7 +148,7 @@ static int my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
     t			String to compare
     tlen		Length of 't'
     diff_if_only_endspace_difference
-                Set to 1 if the strings should be regarded as different
+		        Set to 1 if the strings should be regarded as different
                         if they only difference in end space
 
   NOTE
@@ -156,7 +163,7 @@ static int my_strnncoll_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
 */
 
 static int my_strnncollsp_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
-                                   const uchar *a, size_t a_length,
+                                   const uchar *a, size_t a_length, 
                                    const uchar *b, size_t b_length,
                                    my_bool diff_if_only_endspace_difference)
 {
@@ -195,12 +202,13 @@ static int my_strnncollsp_8bit_bin(CHARSET_INFO * cs __attribute__((unused)),
     for (end= a + a_length-length; a < end ; a++)
     {
       if (*a != ' ')
-    return (*a < ' ') ? -swap : swap;
+	return (*a < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 /* This function is used for all conversion functions */
 
 static size_t my_case_str_bin(CHARSET_INFO *cs __attribute__((unused)),
@@ -209,6 +217,7 @@ static size_t my_case_str_bin(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
 static size_t my_case_bin(CHARSET_INFO *cs __attribute__((unused)),
                           char *src __attribute__((unused)),
                           size_t srclen,
@@ -218,34 +227,38 @@ static size_t my_case_bin(CHARSET_INFO *cs __attribute__((unused)),
   return srclen;
 }
 
+
 static int my_strcasecmp_bin(CHARSET_INFO * cs __attribute__((unused)),
-                 const char *s, const char *t)
+			     const char *s, const char *t)
 {
   return strcmp(s,t);
 }
 
+
 uint my_mbcharlen_8bit(CHARSET_INFO *cs __attribute__((unused)),
                       uint c __attribute__((unused)))
 {
   return 1;
 }
 
+
 static int my_mb_wc_bin(CHARSET_INFO *cs __attribute__((unused)),
-            my_wc_t *wc,
-            const uchar *str,
-            const uchar *end __attribute__((unused)))
+			my_wc_t *wc,
+			const uchar *str,
+			const uchar *end __attribute__((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   *wc=str[0];
   return 1;
 }
 
+
 static int my_wc_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
-            my_wc_t wc,
-            uchar *s,
-            uchar *e __attribute__((unused)))
+			my_wc_t wc,
+			uchar *s,
+			uchar *e __attribute__((unused)))
 {
   if (s >= e)
     return MY_CS_TOOSMALL;
@@ -258,12 +271,13 @@ static int my_wc_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
   return MY_CS_ILUNI;
 }
 
+
 void my_hash_sort_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
                            const uchar *key, size_t len,
                            ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
-
+  
   /*
      Remove trailing spaces. We have to do this to be able to compare
     'A ' and 'A' as identical
@@ -272,27 +286,29 @@ void my_hash_sort_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
 
   for (; pos < (uchar*) key ; pos++)
   {
-    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) *
-         ((uint)*pos)) + (nr1[0] << 8);
+    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) * 
+	     ((uint)*pos)) + (nr1[0] << 8);
     nr2[0]+=3;
   }
 }
 
+
 void my_hash_sort_bin(CHARSET_INFO *cs __attribute__((unused)),
-              const uchar *key, size_t len,ulong *nr1, ulong *nr2)
+		      const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
-
+  
   key+= len;
-
+  
   for (; pos < (uchar*) key ; pos++)
   {
-    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) *
-         ((uint)*pos)) + (nr1[0] << 8);
+    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) * 
+	     ((uint)*pos)) + (nr1[0] << 8);
     nr2[0]+=3;
   }
 }
 
+
 /*
   The following defines is here to keep the following code identical to
   the one in ctype-simple.c
@@ -301,35 +317,36 @@ void my_hash_sort_bin(CHARSET_INFO *cs __attribute__((unused)),
 #define likeconv(s,A) (A)
 #define INC_PTR(cs,A,B) (A)++
 
+
 int my_wildcmp_bin(CHARSET_INFO *cs,
                    const char *str,const char *str_end,
                    const char *wildstr,const char *wildend,
                    int escape, int w_one, int w_many)
 {
   int result= -1;			/* Not found, using wildcards */
-
+  
   while (wildstr != wildend)
   {
     while (*wildstr != w_many && *wildstr != w_one)
     {
       if (*wildstr == escape && wildstr+1 != wildend)
-    wildstr++;
+	wildstr++;
       if (str == str_end || likeconv(cs,*wildstr++) != likeconv(cs,*str++))
-    return(1);			/* No match */
+	return(1);			/* No match */
       if (wildstr == wildend)
-    return(str != str_end);		/* Match if both are at end */
+	return(str != str_end);		/* Match if both are at end */
       result=1;				/* Found an anchor char */
     }
     if (*wildstr == w_one)
     {
       do
       {
-    if (str == str_end)		/* Skip one char if possible */
-      return(result);
-    INC_PTR(cs,str,str_end);
+	if (str == str_end)		/* Skip one char if possible */
+	  return(result);
+	INC_PTR(cs,str,str_end);
       } while (++wildstr < wildend && *wildstr == w_one);
       if (wildstr == wildend)
-    break;
+	break;
     }
     if (*wildstr == w_many)
     {					/* Found w_many */
@@ -338,39 +355,39 @@ int my_wildcmp_bin(CHARSET_INFO *cs,
       /* Remove any '%' and '_' from the wild search string */
       for (; wildstr != wildend ; wildstr++)
       {
-    if (*wildstr == w_many)
-      continue;
-    if (*wildstr == w_one)
-    {
-      if (str == str_end)
-        return(-1);
-      INC_PTR(cs,str,str_end);
-      continue;
-    }
-    break;				/* Not a wild character */
+	if (*wildstr == w_many)
+	  continue;
+	if (*wildstr == w_one)
+	{
+	  if (str == str_end)
+	    return(-1);
+	  INC_PTR(cs,str,str_end);
+	  continue;
+	}
+	break;				/* Not a wild character */
       }
       if (wildstr == wildend)
-    return(0);			/* match if w_many is last */
+	return(0);			/* match if w_many is last */
       if (str == str_end)
-    return(-1);
-
+	return(-1);
+      
       if ((cmp= *wildstr) == escape && wildstr+1 != wildend)
-    cmp= *++wildstr;
+	cmp= *++wildstr;
 
       INC_PTR(cs,wildstr,wildend);	/* This is compared through cmp */
       cmp=likeconv(cs,cmp);
       do
       {
-    while (str != str_end && (uchar) likeconv(cs,*str) != cmp)
-      str++;
-    if (str++ == str_end)
-      return(-1);
-    {
-      int tmp=my_wildcmp_bin(cs,str,str_end,wildstr,wildend,escape,w_one,
-                 w_many);
-      if (tmp <= 0)
-        return(tmp);
-    }
+	while (str != str_end && (uchar) likeconv(cs,*str) != cmp)
+	  str++;
+	if (str++ == str_end)
+	  return(-1);
+	{
+	  int tmp=my_wildcmp_bin(cs,str,str_end,wildstr,wildend,escape,w_one,
+				 w_many);
+	  if (tmp <= 0)
+	    return(tmp);
+	}
       } while (str != str_end && wildstr[0] != w_many);
       return(-1);
     }
@@ -378,6 +395,7 @@ int my_wildcmp_bin(CHARSET_INFO *cs,
   return(str != str_end ? 1 : 0);
 }
 
+
 static size_t my_strnxfrm_bin(CHARSET_INFO *cs __attribute__((unused)),
                               uchar *dest, size_t dstlen,
                               const uchar *src, size_t srclen)
@@ -389,6 +407,7 @@ static size_t my_strnxfrm_bin(CHARSET_INFO *cs __attribute__((unused)),
   return dstlen;
 }
 
+
 static
 size_t my_strnxfrm_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
                             uchar *dest, size_t dstlen,
@@ -401,11 +420,12 @@ size_t my_strnxfrm_8bit_bin(CHARSET_INFO *cs __attribute__((unused)),
   return dstlen;
 }
 
+
 static
 uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
-          const char *b, size_t b_length,
-          const char *s, size_t s_length,
-          my_match_t *match, uint nmatch)
+		  const char *b, size_t b_length,
+		  const char *s, size_t s_length,
+		  my_match_t *match, uint nmatch)
 {
   register const uchar *str, *search, *end, *search_end;
 
@@ -432,35 +452,36 @@ uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
     {
       if ( (*str++) == (*search))
       {
-    register const uchar *i,*j;
+	register const uchar *i,*j;
 
-    i= str;
-    j= search+1;
+	i= str;
+	j= search+1;
 
-    while (j != search_end)
-      if ((*i++) != (*j++))
+	while (j != search_end)
+	  if ((*i++) != (*j++))
             goto skip;
 
         if (nmatch > 0)
-    {
-      match[0].beg= 0;
-      match[0].end= (size_t) (str- (const uchar*)b-1);
-      match[0].mb_len= match[0].end;
-
-      if (nmatch > 1)
-      {
-        match[1].beg= match[0].end;
-        match[1].end= match[0].end+s_length;
-        match[1].mb_len= match[1].end-match[1].beg;
-      }
-    }
-    return 2;
+	{
+	  match[0].beg= 0;
+	  match[0].end= (size_t) (str- (const uchar*)b-1);
+	  match[0].mb_len= match[0].end;
+
+	  if (nmatch > 1)
+	  {
+	    match[1].beg= match[0].end;
+	    match[1].end= match[0].end+s_length;
+	    match[1].mb_len= match[1].end-match[1].beg;
+	  }
+	}
+	return 2;
       }
     }
   }
   return 0;
 }
 
+
 MY_COLLATION_HANDLER my_collation_8bit_bin_handler =
 {
   my_coll_init_8bit_bin,
@@ -476,6 +497,7 @@ uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
   my_propagate_simple
 };
 
+
 static MY_COLLATION_HANDLER my_collation_binary_handler =
 {
   NULL,			/* init */
@@ -491,6 +513,7 @@ uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
   my_propagate_simple
 };
 
+
 static MY_CHARSET_HANDLER my_charset_handler=
 {
   NULL,			/* init */
@@ -522,6 +545,7 @@ uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
   my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_bin =
 {
     63,0,0,			/* number        */
@@ -552,4 +576,4 @@ uint my_instr_bin(CHARSET_INFO *cs __attribute__((unused)),
     0,                          /* escape_with_backslash_is_dangerous */
     &my_charset_handler,
     &my_collation_binary_handler
-};
\ No newline at end of file
+};
diff --git a/dep/mysqllite/strings/ctype-cp932.c b/dep/mysqllite/strings/ctype-cp932.c
index 05dce91..692f1d3 100644
--- a/dep/mysqllite/strings/ctype-cp932.c
+++ b/dep/mysqllite/strings/ctype-cp932.c
@@ -22,6 +22,7 @@
 
 #ifdef HAVE_CHARSET_cp932
 
+
 /*
  * This comment is parsed by configure to create ctype.c,
  * so don't change it unless you know what you are doing.
@@ -180,8 +181,9 @@
 #define iscp932tail(c) ((0x40<=(c) && (c)<=0x7e) || \
                        (0x80<=(c) && (c)<=0xfc))
 
+
 static uint ismbchar_cp932(CHARSET_INFO *cs __attribute__((unused)),
-             const char* p, const char *e)
+			 const char* p, const char *e)
 {
   return (iscp932head((uchar) *p) && (e-p)>1 && iscp932tail((uchar)p[1]) ? 2: 0);
 }
@@ -191,8 +193,10 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   return (iscp932head((uchar) c) ? 2 : 1);
 }
 
+
 #define cp932code(c,d)	((((uint) (uchar)(c)) << 8) | (uint) (uchar) (d))
 
+
 static MY_UNICASE_INFO c81[256]=
 {
   /* 8100-810F */
@@ -207,7 +211,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   /* 8130-813F */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-
+  
   {0x8140,0x8140,0x3000}, /* 8140-814F */
   {0x8141,0x8141,0x3001},
   {0x8142,0x8142,0x3002},
@@ -402,6 +406,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},
 };
 
+
 static MY_UNICASE_INFO c82[256]=
 {
   /* 8200-820F */
@@ -609,6 +614,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO c83[256]=
 {
   /* 8300-830F */
@@ -818,6 +824,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO c84[256]=
 {
   /* 8400-840F */
@@ -1027,6 +1034,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO c87[256]=
 {
   /* 8700-870F */
@@ -1236,6 +1244,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO cEE[256]=
 {
   /* EE00-EE0F */
@@ -1267,7 +1276,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xEE4D,0xEE4D,0x7429},
   {0xEE4E,0xEE4E,0x742E},
   {0xEE4F,0xEE4F,0x7462},
-
+  
   {0xEE50,0xEE50,0x7489}, /* EE50 */
   {0xEE51,0xEE51,0x749F},
   {0xEE52,0xEE52,0x7501},
@@ -1446,6 +1455,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO cFA[256]=
 {
   /* FA00-FA0F */
@@ -1655,6 +1665,7 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0}
 };
 
+
 static MY_UNICASE_INFO *my_caseinfo_cp932[256]=
 {
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 0 */
@@ -1691,9 +1702,10 @@ static uint mbcharlen_cp932(CHARSET_INFO *cs __attribute__((unused)),uint c)
   NULL, NULL, cFA,  NULL, NULL, NULL, NULL, NULL
 };
 
+
 static int my_strnncoll_cp932_internal(CHARSET_INFO *cs,
-                      const uchar **a_res, size_t a_length,
-                      const uchar **b_res, size_t b_length)
+				      const uchar **a_res, size_t a_length,
+				      const uchar **b_res, size_t b_length)
 {
   const uchar *a= *a_res, *b= *b_res;
   const uchar *a_end= a + a_length;
@@ -1701,18 +1713,18 @@ static int my_strnncoll_cp932_internal(CHARSET_INFO *cs,
   while (a < a_end && b < b_end)
   {
     if (ismbchar_cp932(cs,(char*) a, (char*) a_end) &&
-    ismbchar_cp932(cs,(char*) b, (char*) b_end))
+	ismbchar_cp932(cs,(char*) b, (char*) b_end))
     {
       uint a_char= cp932code(*a, *(a+1));
       uint b_char= cp932code(*b, *(b+1));
       if (a_char != b_char)
-    return a_char - b_char;
+	return a_char - b_char;
       a += 2;
       b += 2;
     } else
     {
       if (sort_order_cp932[(uchar)*a] != sort_order_cp932[(uchar)*b])
-    return sort_order_cp932[(uchar)*a] - sort_order_cp932[(uchar)*b];
+	return sort_order_cp932[(uchar)*a] - sort_order_cp932[(uchar)*b];
       a++;
       b++;
     }
@@ -1722,9 +1734,10 @@ static int my_strnncoll_cp932_internal(CHARSET_INFO *cs,
   return 0;
 }
 
+
 static int my_strnncoll_cp932(CHARSET_INFO *cs __attribute__((unused)),
-                  const uchar *a, size_t a_length,
-                  const uchar *b, size_t b_length,
+			      const uchar *a, size_t a_length, 
+			      const uchar *b, size_t b_length,
                               my_bool b_is_prefix)
 {
   int res= my_strnncoll_cp932_internal(cs, &a, a_length, &b, b_length);
@@ -1733,8 +1746,9 @@ static int my_strnncoll_cp932(CHARSET_INFO *cs __attribute__((unused)),
   return res ? res : (int) (a_length - b_length);
 }
 
+
 static int my_strnncollsp_cp932(CHARSET_INFO *cs __attribute__((unused)),
-                                const uchar *a, size_t a_length,
+                                const uchar *a, size_t a_length, 
                                 const uchar *b, size_t b_length,
                                 my_bool diff_if_only_endspace_difference
                                 __attribute__((unused)))
@@ -1767,12 +1781,14 @@ static int my_strnncollsp_cp932(CHARSET_INFO *cs __attribute__((unused)),
     for (; a < a_end ; a++)
     {
       if (*a != (uchar) ' ')
-    return (*a < (uchar) ' ') ? -swap : swap;
+	return (*a < (uchar) ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
+
 static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
                                 uchar *dest, size_t len,
                                 const uchar *src, size_t srclen)
@@ -1785,7 +1801,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
     {
       *dest++ = *src++;
       if (dest < d_end && src < s_end)
-    *dest++ = *src++;
+	*dest++ = *src++;
     }
     else
       *dest++ = sort_order_cp932[(uchar)*src++];
@@ -1795,6 +1811,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
   return len;
 }
 
+
 static uint16 cp932_to_unicode[65536]=
 {
       0x0000,      0x0001,      0x0002,      0x0003, /* 0000 */
@@ -18183,6 +18200,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
       0x0000,      0x0000,      0x0000,      0x0000,
 };
 
+
 static uint16 unicode_to_cp932[65536]=
 {
       0x0000,      0x0001,      0x0002,      0x0003, /* 0000 */
@@ -34571,16 +34589,18 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
       0x0000,      0x0000,      0x0000,      0x0000,
 };
 
+
 /*
   CP932 encoding components:
-
+  
   [00..7F]                        = ASCII [U+0000..U+007F]
   [A1..DF]                        = JIS-X-0201 Katakana [U+FF61..U+FF9F]
   [81..9F,E0..FC][40..7E,80..FC]  = JIS-X-0208 (MS version)
-
+  
   [80,A0,FD,FE,FF]                = Invalid leading byte
 */
 
+
 /**
   Scans a CP932 character from the input string
   and converts to Unicode code point.
@@ -34598,7 +34618,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
 
 static int
 my_mb_wc_cp932(CHARSET_INFO *cs  __attribute__((unused)),
-           my_wc_t *pwc, const uchar *s, const uchar *e){
+	       my_wc_t *pwc, const uchar *s, const uchar *e){
   int hi;
 
   if (s >= e)
@@ -34627,6 +34647,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
   return 2;
 }
 
+
 /**
   Puts the given Unicode character into a CP932 string.
 
@@ -34641,7 +34662,7 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
 */
 static int
 my_wc_mb_cp932(CHARSET_INFO *cs __attribute__((unused)),
-           my_wc_t wc, uchar *s, uchar *e)
+	       my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
 
@@ -34677,6 +34698,8 @@ static size_t my_strnxfrm_cp932(CHARSET_INFO *cs __attribute__((unused)),
   return 2;
 }
 
+
+
 static
 size_t my_numcells_cp932(CHARSET_INFO *cs __attribute__((unused)),
                       const char *str, const char *str_end)
@@ -34684,7 +34707,7 @@ size_t my_numcells_cp932(CHARSET_INFO *cs __attribute__((unused)),
   size_t clen= 0;
   const uchar *b= (const uchar *) str;
   const uchar *e= (const uchar *) str_end;
-
+  
   for (clen= 0; b < e; )
   {
     if (*b >= 0xA1 && *b <= 0xDF)
@@ -34750,6 +34773,7 @@ size_t my_well_formed_len_cp932(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (b - b0);
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
   NULL,			/* init */
@@ -34765,6 +34789,7 @@ size_t my_well_formed_len_cp932(CHARSET_INFO *cs __attribute__((unused)),
   my_propagate_simple
 };
 
+
 static MY_CHARSET_HANDLER my_charset_handler=
 {
   NULL,			/* init */
@@ -34796,6 +34821,7 @@ size_t my_well_formed_len_cp932(CHARSET_INFO *cs __attribute__((unused)),
   my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_cp932_japanese_ci=
 {
     95,0,0,		/* number */
@@ -34860,4 +34886,4 @@ size_t my_well_formed_len_cp932(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_mb_bin_handler
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/ctype-czech.c b/dep/mysqllite/strings/ctype-czech.c
index ac580f5..b65a771 100644
--- a/dep/mysqllite/strings/ctype-czech.c
+++ b/dep/mysqllite/strings/ctype-czech.c
@@ -15,41 +15,41 @@
 
 /* File strings/ctype-czech.c for MySQL.
 
-    This file implements the Czech sorting for the MySQL database
-    server (www.mysql.com). Due to some complicated rules the
-    Czech language has for sorting strings, a more complex
-    solution was needed than the one-to-one conversion table. To
-    note a few, here is an example of a Czech sorting sequence:
-
-        co < hlaska < hlska < hlava < chlapec < krtek
-
-    It because some of the rules are: double char 'ch' is sorted
-    between 'h' and 'i'. Accented character '' (a with acute) is
-    sorted after 'a' and before 'b', but only if the word is
-    otherwise the same. However, because 's' is sorted before 'v'
-    in hlava, the accentness of '' is overridden. There are many
-    more rules.
-
-    This file defines functions my_strxfrm and my_strcoll for
-    C-like zero terminated strings and my_strnxfrm and my_strnncoll
-    for strings where the length comes as an parameter. Also
-    defined here you will find function my_like_range that returns
-    index range strings for LIKE expression and the
-    MY_STRXFRM_MULTIPLY set to value 4 -- this is the ratio the
-    strings grows during my_strxfrm. The algorithm has four
-    passes, that's why we need four times more space for expanded
-    string.
-
-    This file also contains the ISO-Latin-2 definitions of
-    characters.
-
-    Author: (c) 1997--1998 Jan Pazdziora, adelton@fi.muni.cz
-    Jan Pazdziora has a shared copyright for this code
-
-    The original of this file can also be found at
-    http://www.fi.muni.cz/~adelton/l10n/
-
-    Bug reports and suggestions are always welcome.
+	This file implements the Czech sorting for the MySQL database
+	server (www.mysql.com). Due to some complicated rules the
+	Czech language has for sorting strings, a more complex
+	solution was needed than the one-to-one conversion table. To
+	note a few, here is an example of a Czech sorting sequence:
+
+		co < hlaska < hlska < hlava < chlapec < krtek
+
+	It because some of the rules are: double char 'ch' is sorted
+	between 'h' and 'i'. Accented character '' (a with acute) is
+	sorted after 'a' and before 'b', but only if the word is
+	otherwise the same. However, because 's' is sorted before 'v'
+	in hlava, the accentness of '' is overridden. There are many
+	more rules.
+
+	This file defines functions my_strxfrm and my_strcoll for
+	C-like zero terminated strings and my_strnxfrm and my_strnncoll
+	for strings where the length comes as an parameter. Also
+	defined here you will find function my_like_range that returns
+	index range strings for LIKE expression and the
+	MY_STRXFRM_MULTIPLY set to value 4 -- this is the ratio the
+	strings grows during my_strxfrm. The algorithm has four
+	passes, that's why we need four times more space for expanded
+	string.
+
+	This file also contains the ISO-Latin-2 definitions of
+	characters.
+
+	Author: (c) 1997--1998 Jan Pazdziora, adelton@fi.muni.cz
+	Jan Pazdziora has a shared copyright for this code
+
+	The original of this file can also be found at
+	http://www.fi.muni.cz/~adelton/l10n/
+
+	Bug reports and suggestions are always welcome.
 */
 
 /*
@@ -79,8 +79,8 @@
 #ifdef HAVE_CHARSET_latin2
 
 /*
-    These are four tables for four passes of the algorithm. Please see
-    below for what are the "special values"
+	These are four tables for four passes of the algorithm. Please see
+	below for what are the "special values"
 */
 
 static uchar *CZ_SORT_TABLE[] = {
@@ -91,77 +91,77 @@
 };
 
 /*
-    These define the valuse for the double chars that need to be
-    sorted as they were single characters -- in Czech these are
-    'ch', 'Ch' and 'CH'.
+	These define the valuse for the double chars that need to be
+	sorted as they were single characters -- in Czech these are
+	'ch', 'Ch' and 'CH'.
 */
 
 struct wordvalue
-    {
-      const char * word;
-      uchar *outvalue;
-    };
+	{
+	  const char * word;
+	  uchar *outvalue;
+	};
 static struct wordvalue doubles[] = {
-    { "ch", (uchar*) "\014\031\057\057" },
-    { "Ch", (uchar*) "\014\031\060\060" },
-    { "CH", (uchar*) "\014\031\061\061" },
-    { "c",  (uchar*) "\005\012\021\021" },
-    { "C",  (uchar*) "\005\012\022\022" },
-    };
+	{ "ch", (uchar*) "\014\031\057\057" },
+	{ "Ch", (uchar*) "\014\031\060\060" },
+	{ "CH", (uchar*) "\014\031\061\061" },
+	{ "c",  (uchar*) "\005\012\021\021" },
+	{ "C",  (uchar*) "\005\012\022\022" },
+	};
 
 /*
-    Unformal description of the algorithm:
+	Unformal description of the algorithm:
 
-    We walk the string left to right.
+	We walk the string left to right.
 
-    The end of the string is either passed as parameter, or is
-    *p == 0. This is hidden in the IS_END macro.
+	The end of the string is either passed as parameter, or is
+	*p == 0. This is hidden in the IS_END macro.
 
-    In the first two passes, we compare word by word. So we make
-    first and second pass on the first word, first and second pass
-    on the second word, etc. If we come to the end of the string
-    during the first pass, we need to jump to the last word of the
-    second pass.
+	In the first two passes, we compare word by word. So we make
+	first and second pass on the first word, first and second pass
+	on the second word, etc. If we come to the end of the string
+	during the first pass, we need to jump to the last word of the
+	second pass.
 
-    End of pass is marked with value 1 on the output.
+	End of pass is marked with value 1 on the output.
 
-    For each character, we read it's value from the table.
+	For each character, we read it's value from the table.
 
-    If the value is ignore (0), we go straight to the next character.
+	If the value is ignore (0), we go straight to the next character.
 
-    If the value is space/end of word (2) and we are in the first
-    or second pass, we skip all characters having value 0 -- 2 and
-    switch the passwd.
+	If the value is space/end of word (2) and we are in the first
+	or second pass, we skip all characters having value 0 -- 2 and
+	switch the passwd.
 
-    If it's the compose character (255), we check if the double
-    exists behind it, find its value.
+	If it's the compose character (255), we check if the double
+	exists behind it, find its value.
 
-    We append 0 to the end.
+	We append 0 to the end.
 ---
-    Neformln popis algoritmu:
+	Neformln popis algoritmu:
 
-    Prochzme etzec zleva doprava.
+	Prochzme etzec zleva doprava.
 
-    Konec etzce je pedn bu jako parametr, nebo je to *p == 0.
-    Toto je oeteno makrem IS_END.
+	Konec etzce je pedn bu jako parametr, nebo je to *p == 0.
+	Toto je oeteno makrem IS_END.
 
-    Pokud jsme doli na konec etzce pi prchodu 0, nejdeme na
-    zatek, ale na uloenou pozici, protoe prvn a druh prchod
-    b souasn.
+	Pokud jsme doli na konec etzce pi prchodu 0, nejdeme na
+	zatek, ale na uloenou pozici, protoe prvn a druh prchod
+	b souasn.
 
-    Konec vstupu (prchodu) ozname na vstupu hodnotou 1.
+	Konec vstupu (prchodu) ozname na vstupu hodnotou 1.
 
-    Pro kad znak etzce nateme hodnotu z tdc tabulky.
+	Pro kad znak etzce nateme hodnotu z tdc tabulky.
 
-    Jde-li o hodnotu ignorovat (0), skome ihned na dal znak..
+	Jde-li o hodnotu ignorovat (0), skome ihned na dal znak..
 
-    Jde-li o hodnotu konec slova (2) a je to prchod 0 nebo 1,
-    peskome vechny dal 0 -- 2 a prohodme prchody.
+	Jde-li o hodnotu konec slova (2) a je to prchod 0 nebo 1,
+	peskome vechny dal 0 -- 2 a prohodme prchody.
 
-    Jde-li o kompozitn znak (255), otestujeme, zda nsleduje
-    sprvn do dvojice, dohledme sprvnou hodnotu.
+	Jde-li o kompozitn znak (255), otestujeme, zda nsleduje
+	sprvn do dvojice, dohledme sprvnou hodnotu.
 
-    Na konci pipojme znak 0
+	Na konci pipojme znak 0
  */
 
 #define ADD_TO_RESULT(dest, len, totlen, value)			\
@@ -218,15 +218,15 @@ struct wordvalue
       int j = 0;					\
       while (pattern[j])				\
       {							\
-    if (IS_END(q, src, len) || (*q != pattern[j]))	\
-     break;						\
-    j++; q++;					\
+	if (IS_END(q, src, len) || (*q != pattern[j]))	\
+	 break;						\
+	j++; q++;					\
       }							\
       if (!(pattern[j]))				\
       {							\
-    value = (int)(doubles[i].outvalue[pass]);	\
-    p= (const uchar *) q - 1;			\
-    break;						\
+	value = (int)(doubles[i].outvalue[pass]);	\
+	p= (const uchar *) q - 1;			\
+	break;						\
       }							\
     }							\
   }							\
@@ -240,8 +240,8 @@ struct wordvalue
 */
 
 static int my_strnncoll_czech(CHARSET_INFO *cs __attribute__((unused)),
-                  const uchar *s1, size_t len1,
-                  const uchar *s2, size_t len2,
+			      const uchar *s1, size_t len1, 
+			      const uchar *s2, size_t len2,
                               my_bool s2_is_prefix)
 {
   int v1, v2;
@@ -266,13 +266,15 @@ static int my_strnncoll_czech(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
+
 /*
   TODO: Fix this one to compare strings as they are done in ctype-simple1
 */
 
 static
-int my_strnncollsp_czech(CHARSET_INFO * cs,
-                         const uchar *s, size_t slen,
+int my_strnncollsp_czech(CHARSET_INFO * cs, 
+                         const uchar *s, size_t slen, 
                          const uchar *t, size_t tlen,
                          my_bool diff_if_only_endspace_difference
                          __attribute__((unused)))
@@ -282,12 +284,13 @@ int my_strnncollsp_czech(CHARSET_INFO * cs,
   return my_strnncoll_czech(cs,s,slen,t,tlen,0);
 }
 
+
 /*
   Function strnxfrm, actually strxfrm, with Czech sorting, which expect
   the length of the strings being specified
 */
 
-static size_t my_strnxfrm_czech(CHARSET_INFO *cs __attribute__((unused)),
+static size_t my_strnxfrm_czech(CHARSET_INFO *cs __attribute__((unused)), 
                                 uchar *dest, size_t len,
                                 const uchar *src, size_t srclen)
 {
@@ -310,27 +313,29 @@ static size_t my_strnxfrm_czech(CHARSET_INFO *cs __attribute__((unused)),
 
 #undef IS_END
 
+
 /*
-    Neformln popis algoritmu:
-
-    prochzme etzec zleva doprava
-    konec etzce poznme podle *p == 0
-    pokud jsme doli na konec etzce pi prchodu 0, nejdeme na
-        zatek, ale na uloenou pozici, protoe prvn a druh
-        prchod b souasn
-    konec vstupu (prchodu) ozname na vstupu hodnotou 1
-
-    nateme hodnotu z tdc tabulky
-    jde-li o hodnotu ignorovat (0), skome na dal prchod
-    jde-li o hodnotu konec slova (2) a je to prchod 0 nebo 1,
-        peskome vechny dal 0 -- 2 a prohodme
-        prchody
-    jde-li o kompozitn znak (255), otestujeme, zda nsleduje
-        sprvn do dvojice, dohledme sprvnou hodnotu
-
-    na konci pipojme znak 0
+	Neformln popis algoritmu:
+
+	prochzme etzec zleva doprava
+	konec etzce poznme podle *p == 0
+	pokud jsme doli na konec etzce pi prchodu 0, nejdeme na
+		zatek, ale na uloenou pozici, protoe prvn a druh
+		prchod b souasn
+	konec vstupu (prchodu) ozname na vstupu hodnotou 1
+
+	nateme hodnotu z tdc tabulky
+	jde-li o hodnotu ignorovat (0), skome na dal prchod
+	jde-li o hodnotu konec slova (2) a je to prchod 0 nebo 1,
+		peskome vechny dal 0 -- 2 a prohodme
+		prchody
+	jde-li o kompozitn znak (255), otestujeme, zda nsleduje
+		sprvn do dvojice, dohledme sprvnou hodnotu
+
+	na konci pipojme znak 0
  */
 
+
 /*
 ** Calculate min_str and max_str that ranges a LIKE string.
 ** Arguments:
@@ -356,11 +361,11 @@ static size_t my_strnxfrm_czech(CHARSET_INFO *cs __attribute__((unused)),
 #define EXAMPLE
 
 static my_bool my_like_range_czech(CHARSET_INFO *cs __attribute__((unused)),
-                   const char *ptr,size_t ptr_length,
-                   pbool escape, pbool w_one, pbool w_many,
-                   size_t res_length, char *min_str,
-                   char *max_str,
-                   size_t *min_length,size_t *max_length)
+				   const char *ptr,size_t ptr_length,
+				   pbool escape, pbool w_one, pbool w_many,
+				   size_t res_length, char *min_str,
+				   char *max_str,
+				   size_t *min_length,size_t *max_length)
 {
 #ifdef EXAMPLE
   uchar value;
@@ -537,6 +542,7 @@ static my_bool my_like_range_czech(CHARSET_INFO *cs __attribute__((unused)),
 0x0159,0x016F,0x00FA,0x0171,0x00FC,0x00FD,0x0163,0x02D9
 };
 
+
 /* 0000-00FD , 254 chars */
 static uchar tab_uni_8859_2_plane00[]={
 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
@@ -579,6 +585,7 @@ static my_bool my_like_range_czech(CHARSET_INFO *cs __attribute__((unused)),
   {0,0,NULL}
 };
 
+
 static MY_COLLATION_HANDLER my_collation_latin2_czech_ci_handler =
 {
   NULL,			/* init */
@@ -626,6 +633,7 @@ static my_bool my_like_range_czech(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_latin2_czech_ci_handler
 };
 
+
 #endif
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/ctype-euc_kr.c b/dep/mysqllite/strings/ctype-euc_kr.c
index e1e6b4f..5267ca8 100644
--- a/dep/mysqllite/strings/ctype-euc_kr.c
+++ b/dep/mysqllite/strings/ctype-euc_kr.c
@@ -13,7 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
-/*
+/* 
  * This file is for Korean EUC charset, and created by powerm90@tinc.co.kr.
  * and updated by mrpark@tinc.co.kr.
  */
@@ -31,6 +31,7 @@
 
 #ifdef HAVE_CHARSET_euckr
 
+
 static uchar ctype_euc_kr[257] =
 {
     0,				/* For standard library */
@@ -181,11 +182,11 @@
 /*
  Unicode mapping is done according to:
  ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/KSC/KSC5601.TXT
-
+ 
  Valid multi-byte characters:
-
+ 
    [81..FE][41..5A,61..7A,81..FE]
-
+ 
  Note, 0x5C is not a valid MB tail,
  so escape_with_backslash_is_dangerous is not set.
 */
@@ -200,6 +201,7 @@
                               iseuc_kr_tail2(c) || \
                               iseuc_kr_tail3(c))
 
+
 static uint ismbchar_euc_kr(CHARSET_INFO *cs __attribute__((unused)),
                             const char* p, const char *e)
 {
@@ -213,6 +215,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   return (iseuc_kr_head(c) ? 2 : 1);
 }
 
+
 static MY_UNICASE_INFO cA3[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -417,6 +420,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3FF,0xA3FF,0x003F}
 };
 
+
 static MY_UNICASE_INFO cA5[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -618,9 +622,10 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA5FC,0xA5FC,0x003F},
   {0xA5FD,0xA5FD,0x003F},
   {0xA5FE,0xA5FE,0x003F},
-  {0xA5FF,0xA5FF,0x003F}
+  {0xA5FF,0xA5FF,0x003F} 
 };
 
+
 static MY_UNICASE_INFO cA7[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -825,6 +830,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7FF,0xA7FF,0x003F}
 };
 
+
 static MY_UNICASE_INFO cA8[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -1029,6 +1035,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8FF,0xA8FF,0x003F}
 };
 
+
 static MY_UNICASE_INFO cA9[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -1231,7 +1238,8 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA9FD,0xA9FD,0x2083},
   {0xA9FE,0xA9FE,0x2084},
   {0xA9FF,0xA9FF,0x003F}
-};
+};  
+
 
 static MY_UNICASE_INFO cAC[256]=
 {
@@ -1437,6 +1445,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xACFF,0xACFF,0x003F}
 };
 
+
 static MY_UNICASE_INFO *my_caseinfo_euckr[256]=
 {
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 0 */
@@ -1473,6 +1482,7 @@ static uint mbcharlen_euc_kr(CHARSET_INFO *cs __attribute__((unused)),uint c)
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 
+
 /* page 0 0x8141-0xC8FE */
 static uint16 tab_ksc5601_uni0[]={
 0xAC02,0xAC03,0xAC05,0xAC06,0xAC0B,0xAC0C,0xAC0D,0xAC0E,
@@ -9857,57 +9867,61 @@ static int func_uni_ksc5601_onechar(int code){
   return(0);
 }
 
+
 static int
 my_wc_mb_euc_kr(CHARSET_INFO *cs __attribute__((unused)),
-         my_wc_t wc, uchar *s, uchar *e)
+		 my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((uint) wc < 0x80)
   {
     s[0]= (uchar) wc;
     return 1;
   }
-
+  
   if (!(code=func_uni_ksc5601_onechar(wc)))
     return MY_CS_ILUNI;
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+  
   s[0]=code>>8;
   s[1]=code&0xFF;
-
+  
   return 2;
 }
 
-static int
+
+static int 
 my_mb_wc_euc_kr(CHARSET_INFO *cs __attribute__((unused)),
-         my_wc_t *pwc, const uchar *s, const uchar *e)
+		 my_wc_t *pwc, const uchar *s, const uchar *e)
 {
+  
   int hi;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((hi= s[0]) < 0x80)
   {
     pwc[0]=hi;
     return 1;
   }
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+  
   if (!(pwc[0]=func_ksc5601_uni_onechar((hi<<8)+s[1])))
     return -2;
-
+  
   return 2;
 }
 
+
 /*
   Returns well formed length of a EUC-KR string.
 */
@@ -9942,6 +9956,7 @@ static int func_uni_ksc5601_onechar(int code){
   return (size_t) (b - b0);
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
   NULL,			/* init */
@@ -9988,6 +10003,7 @@ static int func_uni_ksc5601_onechar(int code){
   my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_euckr_korean_ci=
 {
     19,0,0,		/* number */
@@ -10020,6 +10036,7 @@ static int func_uni_ksc5601_onechar(int code){
     &my_collation_ci_handler
 };
 
+
 CHARSET_INFO my_charset_euckr_bin=
 {
     85,0,0,		/* number */
@@ -10052,4 +10069,4 @@ static int func_uni_ksc5601_onechar(int code){
     &my_collation_mb_bin_handler
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/ctype-extra.c b/dep/mysqllite/strings/ctype-extra.c
index 528f24c..b45e995 100644
--- a/dep/mysqllite/strings/ctype-extra.c
+++ b/dep/mysqllite/strings/ctype-extra.c
@@ -8646,4 +8646,4 @@
   &my_charset_8bit_handler,
   &my_collation_8bit_simple_ci_handler,
 }
-};
\ No newline at end of file
+};
diff --git a/dep/mysqllite/strings/ctype-gb2312.c b/dep/mysqllite/strings/ctype-gb2312.c
index a5699f1..0e26801 100644
--- a/dep/mysqllite/strings/ctype-gb2312.c
+++ b/dep/mysqllite/strings/ctype-gb2312.c
@@ -164,8 +164,9 @@
 #define isgb2312head(c) (0xa1<=(uchar)(c) && (uchar)(c)<=0xf7)
 #define isgb2312tail(c) (0xa1<=(uchar)(c) && (uchar)(c)<=0xfe)
 
+
 static uint ismbchar_gb2312(CHARSET_INFO *cs __attribute__((unused)),
-            const char* p, const char *e)
+		    const char* p, const char *e)
 {
   return (isgb2312head(*(p)) && (e)-(p)>1 && isgb2312tail(*((p)+1))? 2: 0);
 }
@@ -175,6 +176,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   return (isgb2312head(c)? 2 : 1);
 }
 
+
 static MY_UNICASE_INFO cA2[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -197,7 +199,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx90 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-  {0xA2A0,0xA2A0,0xA2A0}, /* A2A0 */
+  {0xA2A0,0xA2A0,0xA2A0}, /* A2A0 */ 
   {0xA2A1,0xA2A1,0x003F},
   {0xA2A2,0xA2A2,0x003F},
   {0xA2A3,0xA2A3,0x003F},
@@ -213,7 +215,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2AD,0xA2AD,0x003F},
   {0xA2AE,0xA2AE,0x003F},
   {0xA2AF,0xA2AF,0x003F},
-  {0xA2B0,0xA2B0,0x003F}, /* A2B0 */
+  {0xA2B0,0xA2B0,0x003F}, /* A2B0 */ 
   {0xA2B1,0xA2B1,0x2488},
   {0xA2B2,0xA2B2,0x2489},
   {0xA2B3,0xA2B3,0x248A},
@@ -229,7 +231,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2BD,0xA2BD,0x2494},
   {0xA2BE,0xA2BE,0x2495},
   {0xA2BF,0xA2BF,0x2496},
-  {0xA2C0,0xA2C0,0x2497}, /* A2C0 */
+  {0xA2C0,0xA2C0,0x2497}, /* A2C0 */ 
   {0xA2C1,0xA2C1,0x2498},
   {0xA2C2,0xA2C2,0x2499},
   {0xA2C3,0xA2C3,0x249A},
@@ -245,7 +247,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2CD,0xA2CD,0x247C},
   {0xA2CE,0xA2CE,0x247D},
   {0xA2CF,0xA2CF,0x247E},
-  {0xA2D0,0xA2D0,0x247F}, /* A2D0 */
+  {0xA2D0,0xA2D0,0x247F}, /* A2D0 */ 
   {0xA2D1,0xA2D1,0x2480},
   {0xA2D2,0xA2D2,0x2481},
   {0xA2D3,0xA2D3,0x2482},
@@ -261,7 +263,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2DD,0xA2DD,0x2464},
   {0xA2DE,0xA2DE,0x2465},
   {0xA2DF,0xA2DF,0x2466},
-  {0xA2E0,0xA2E0,0x2467}, /* A2E0 */
+  {0xA2E0,0xA2E0,0x2467}, /* A2E0 */ 
   {0xA2E1,0xA2E1,0x2468},
   {0xA2E2,0xA2E2,0x2469},
   {0xA2E3,0xA2E3,0x003F},
@@ -277,7 +279,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2ED,0xA2ED,0x3228},
   {0xA2EE,0xA2EE,0x3229},
   {0xA2EF,0xA2EF,0x003F},
-  {0xA2F0,0xA2F0,0x003F}, /* A2F0 */
+  {0xA2F0,0xA2F0,0x003F}, /* A2F0 */ 
   {0xA2F1,0xA2F1,0x2160},
   {0xA2F2,0xA2F2,0x2161},
   {0xA2F3,0xA2F3,0x2162},
@@ -295,6 +297,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA2FF,0xA2FF,0xA2FF}
 };
 
+
 static MY_UNICASE_INFO cA3[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -317,7 +320,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx90 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-  {0xA3A0,0xA3A0,0xA3A0}, /* A3A0 */
+  {0xA3A0,0xA3A0,0xA3A0}, /* A3A0 */ 
   {0xA3A1,0xA3A1,0xFF01},
   {0xA3A2,0xA3A2,0xFF02},
   {0xA3A3,0xA3A3,0xFF03},
@@ -333,7 +336,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3AD,0xA3AD,0xFF0D},
   {0xA3AE,0xA3AE,0xFF0E},
   {0xA3AF,0xA3AF,0xFF0F},
-  {0xA3B0,0xA3B0,0xFF10}, /* A3B0 */
+  {0xA3B0,0xA3B0,0xFF10}, /* A3B0 */ 
   {0xA3B1,0xA3B1,0xFF11},
   {0xA3B2,0xA3B2,0xFF12},
   {0xA3B3,0xA3B3,0xFF13},
@@ -349,7 +352,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3BD,0xA3BD,0xFF1D},
   {0xA3BE,0xA3BE,0xFF1E},
   {0xA3BF,0xA3BF,0xFF1F},
-  {0xA3C0,0xA3C0,0xFF20}, /* A3C0 */
+  {0xA3C0,0xA3C0,0xFF20}, /* A3C0 */ 
   {0xA3C1,0xA3E1,0xFF21},
   {0xA3C2,0xA3E2,0xFF22},
   {0xA3C3,0xA3E3,0xFF23},
@@ -365,7 +368,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3CD,0xA3ED,0xFF2D},
   {0xA3CE,0xA3EE,0xFF2E},
   {0xA3CF,0xA3EF,0xFF2F},
-  {0xA3D0,0xA3F0,0xFF30}, /* A3D0 */
+  {0xA3D0,0xA3F0,0xFF30}, /* A3D0 */ 
   {0xA3D1,0xA3F1,0xFF31},
   {0xA3D2,0xA3F2,0xFF32},
   {0xA3D3,0xA3F3,0xFF33},
@@ -381,7 +384,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3DD,0xA3DD,0xFF3D},
   {0xA3DE,0xA3DE,0xFF3E},
   {0xA3DF,0xA3DF,0xFF3F},
-  {0xA3E0,0xA3E0,0xFF40}, /* A3E0 */
+  {0xA3E0,0xA3E0,0xFF40}, /* A3E0 */ 
   {0xA3C1,0xA3E1,0xFF41},
   {0xA3C2,0xA3E2,0xFF42},
   {0xA3C3,0xA3E3,0xFF43},
@@ -397,7 +400,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3CD,0xA3ED,0xFF4D},
   {0xA3CE,0xA3EE,0xFF4E},
   {0xA3CF,0xA3EF,0xFF4F},
-  {0xA3D0,0xA3F0,0xFF50}, /* A3F0 */
+  {0xA3D0,0xA3F0,0xFF50}, /* A3F0 */ 
   {0xA3D1,0xA3F1,0xFF51},
   {0xA3D2,0xA3F2,0xFF52},
   {0xA3D3,0xA3F3,0xFF53},
@@ -415,8 +418,9 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA3FF,0xA3FF,0xA3FF}
 };
 
+
 static MY_UNICASE_INFO cA6[256]=
-{
+{ 
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx10 */
@@ -437,7 +441,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx90 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-  {0xA6A0,0xA6A0,0xA6A0}, /* A6A0 */
+  {0xA6A0,0xA6A0,0xA6A0}, /* A6A0 */ 
   {0xA6A1,0xA6C1,0x0391},
   {0xA6A2,0xA6C2,0x0392},
   {0xA6A3,0xA6C3,0x0393},
@@ -453,7 +457,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6AD,0xA6CD,0x039D},
   {0xA6AE,0xA6CE,0x039E},
   {0xA6AF,0xA6CF,0x039F},
-  {0xA6B0,0xA6D0,0x03A0}, /* A6B0 */
+  {0xA6B0,0xA6D0,0x03A0}, /* A6B0 */ 
   {0xA6B1,0xA6D1,0x03A1},
   {0xA6B2,0xA6D2,0x03A3},
   {0xA6B3,0xA6D3,0x03A4},
@@ -469,7 +473,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6BD,0xA6BD,0x003F},
   {0xA6BE,0xA6BE,0x003F},
   {0xA6BF,0xA6BF,0x003F},
-  {0xA6C0,0xA6C0,0x003F}, /* A6C0 */
+  {0xA6C0,0xA6C0,0x003F}, /* A6C0 */ 
   {0xA6A1,0xA6C1,0x03B1},
   {0xA6A2,0xA6C2,0x03B2},
   {0xA6A3,0xA6C3,0x03B3},
@@ -485,7 +489,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6AD,0xA6CD,0x03BD},
   {0xA6AE,0xA6CE,0x03BE},
   {0xA6AF,0xA6CF,0x03BF},
-  {0xA6B0,0xA6D0,0x03C0}, /* A6D0 */
+  {0xA6B0,0xA6D0,0x03C0}, /* A6D0 */ 
   {0xA6B1,0xA6D1,0x03C1},
   {0xA6B2,0xA6D2,0x03C3},
   {0xA6B3,0xA6D3,0x03C4},
@@ -501,7 +505,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6DD,0xA6DD,0x003F},
   {0xA6DE,0xA6DE,0x003F},
   {0xA6DF,0xA6DF,0x003F},
-  {0xA6E0,0xA6E0,0x003F}, /* A6E0 */
+  {0xA6E0,0xA6E0,0x003F}, /* A6E0 */ 
   {0xA6E1,0xA6E1,0x003F},
   {0xA6E2,0xA6E2,0x003F},
   {0xA6E3,0xA6E3,0x003F},
@@ -517,7 +521,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6ED,0xA6ED,0x003F},
   {0xA6EE,0xA6EE,0x003F},
   {0xA6EF,0xA6EF,0x003F},
-  {0xA6F0,0xA6F0,0x003F}, /* A6F0 */
+  {0xA6F0,0xA6F0,0x003F}, /* A6F0 */ 
   {0xA6F1,0xA6F1,0x003F},
   {0xA6F2,0xA6F2,0x003F},
   {0xA6F3,0xA6F3,0x003F},
@@ -534,9 +538,10 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA6FE,0xA6FE,0x003F},
   {0xA6FF,0xA6FF,0xA6FF}
 };
+  
 
 static MY_UNICASE_INFO cA7[256]=
-{
+{  
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx10 */
@@ -557,7 +562,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx90 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-  {0xA7A0,0xA7A0,0xA7A0}, /* A7A0 */
+  {0xA7A0,0xA7A0,0xA7A0}, /* A7A0 */ 
   {0xA7A1,0xA7D1,0x0410},
   {0xA7A2,0xA7D2,0x0411},
   {0xA7A3,0xA7D3,0x0412},
@@ -573,7 +578,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7AD,0xA7DD,0x041B},
   {0xA7AE,0xA7DE,0x041C},
   {0xA7AF,0xA7DF,0x041D},
-  {0xA7B0,0xA7E0,0x041E}, /* A7B0 */
+  {0xA7B0,0xA7E0,0x041E}, /* A7B0 */ 
   {0xA7B1,0xA7E1,0x041F},
   {0xA7B2,0xA7E2,0x0420},
   {0xA7B3,0xA7E3,0x0421},
@@ -589,7 +594,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7BD,0xA7ED,0x042B},
   {0xA7BE,0xA7EE,0x042C},
   {0xA7BF,0xA7EF,0x042D},
-  {0xA7C0,0xA7F0,0x042E}, /* A7C0 */
+  {0xA7C0,0xA7F0,0x042E}, /* A7C0 */ 
   {0xA7C1,0xA7F1,0x042F},
   {0xA7C2,0xA7C2,0x003F},
   {0xA7C3,0xA7C3,0x003F},
@@ -605,7 +610,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7CD,0xA7CD,0x003F},
   {0xA7CE,0xA7CE,0x003F},
   {0xA7CF,0xA7CF,0x003F},
-  {0xA7D0,0xA7D0,0x003F}, /* A7D0 */
+  {0xA7D0,0xA7D0,0x003F}, /* A7D0 */ 
   {0xA7A1,0xA7D1,0x0430},
   {0xA7A2,0xA7D2,0x0431},
   {0xA7A3,0xA7D3,0x0432},
@@ -621,7 +626,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7AD,0xA7DD,0x043B},
   {0xA7AE,0xA7DE,0x043C},
   {0xA7AF,0xA7DF,0x043D},
-  {0xA7B0,0xA7E0,0x043E}, /* A7E0 */
+  {0xA7B0,0xA7E0,0x043E}, /* A7E0 */ 
   {0xA7B1,0xA7E1,0x043F},
   {0xA7B2,0xA7E2,0x0440},
   {0xA7B3,0xA7E3,0x0441},
@@ -637,7 +642,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7BD,0xA7ED,0x044B},
   {0xA7BE,0xA7EE,0x044C},
   {0xA7BF,0xA7EF,0x044D},
-  {0xA7C0,0xA7F0,0x044E}, /* A7F0 */
+  {0xA7C0,0xA7F0,0x044E}, /* A7F0 */ 
   {0xA7C1,0xA7F1,0x044F},
   {0xA7F2,0xA7F2,0x003F},
   {0xA7F3,0xA7F3,0x003F},
@@ -654,9 +659,10 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA7FE,0xA7FE,0x003F},
   {0xA7FF,0xA7FF,0xA7FF}
 };
+  
 
 static MY_UNICASE_INFO cA8[256]=
-{
+{ 
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx10 */
@@ -677,7 +683,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx90 */
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
-  {0xA8A0,0xA8A0,0xA8A0}, /* A8A0 */
+  {0xA8A0,0xA8A0,0xA8A0}, /* A8A0 */ 
   {0xA8A1,0xA8A1,0x0101},
   {0xA8A2,0xA8A2,0x00E1},
   {0xA8A3,0xA8A3,0x01CE},
@@ -693,7 +699,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8AD,0xA8AD,0x014D},
   {0xA8AE,0xA8AE,0x00F3},
   {0xA8AF,0xA8AF,0x01D2},
-  {0xA8B0,0xA8B0,0x00F2}, /* A8B0 */
+  {0xA8B0,0xA8B0,0x00F2}, /* A8B0 */ 
   {0xA8B1,0xA8B1,0x016B},
   {0xA8B2,0xA8B2,0x00FA},
   {0xA8B3,0xA8B3,0x01D4},
@@ -709,7 +715,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8BD,0xA8BD,0x003F},
   {0xA8BE,0xA8BE,0x003F},
   {0xA8BF,0xA8BF,0x003F},
-  {0xA8C0,0xA8C0,0x003F}, /* A8C0 */
+  {0xA8C0,0xA8C0,0x003F}, /* A8C0 */ 
   {0xA8C1,0xA8C1,0x003F},
   {0xA8C2,0xA8C2,0x003F},
   {0xA8C3,0xA8C3,0x003F},
@@ -725,7 +731,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8CD,0xA8CD,0x310D},
   {0xA8CE,0xA8CE,0x310E},
   {0xA8CF,0xA8CF,0x310F},
-  {0xA8D0,0xA8D0,0x3110}, /* A8D0 */
+  {0xA8D0,0xA8D0,0x3110}, /* A8D0 */ 
   {0xA8D1,0xA8D1,0x3111},
   {0xA8D2,0xA8D2,0x3112},
   {0xA8D3,0xA8D3,0x3113},
@@ -741,7 +747,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8DD,0xA8DD,0x311D},
   {0xA8DE,0xA8DE,0x311E},
   {0xA8DF,0xA8DF,0x311F},
-  {0xA8E0,0xA8E0,0x3120}, /* A8E0 */
+  {0xA8E0,0xA8E0,0x3120}, /* A8E0 */ 
   {0xA8E1,0xA8E1,0x3121},
   {0xA8E2,0xA8E2,0x3122},
   {0xA8E3,0xA8E3,0x3123},
@@ -757,7 +763,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8ED,0xA8ED,0x003F},
   {0xA8EE,0xA8EE,0x003F},
   {0xA8EF,0xA8EF,0x003F},
-  {0xA8F0,0xA8F0,0x003F}, /* A8F0 */
+  {0xA8F0,0xA8F0,0x003F}, /* A8F0 */ 
   {0xA8F1,0xA8F1,0x003F},
   {0xA8F2,0xA8F2,0x003F},
   {0xA8F3,0xA8F3,0x003F},
@@ -775,6 +781,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   {0xA8FF,0xA8FF,0xA8FF}
 };
 
+
 static MY_UNICASE_INFO *my_caseinfo_gb2312[256]=
 {
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 0 */
@@ -811,6 +818,7 @@ static uint mbcharlen_gb2312(CHARSET_INFO *cs __attribute__((unused)),uint c)
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 
+
 /* page 0 0x2121-0x2658 */
 static uint16 tab_gb2312_uni0[]={
 0x3000,0x3001,0x3002,0x30FB,0x02C9,0x02C7,0x00A8,0x3003,
@@ -3356,6 +3364,7 @@ static int func_gb2312_uni_onechar(int code){
   return(0);
 }
 
+
 /* page 0 0x00A4-0x01DC */
 static uint16 tab_uni_gb23120[]={
 0x2168,     0,     0,0x216C,0x2127,     0,     0,     0,
@@ -6263,12 +6272,13 @@ static int func_uni_gb2312_onechar(int code){
   return(0);
 }
 
+
 static int
 my_wc_mb_gb2312(CHARSET_INFO *cs  __attribute__((unused)),
-        my_wc_t wc, uchar *s, uchar *e)
+		my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
 
@@ -6277,42 +6287,44 @@ static int func_uni_gb2312_onechar(int code){
     s[0]= (uchar) wc;
     return 1;
   }
-
+  
   if (!(code=func_uni_gb2312_onechar(wc)))
     return MY_CS_ILUNI;
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+  
   code|=0x8080;
   s[0]=code>>8;
   s[1]=code&0xFF;
   return 2;
 }
 
-static int
+
+static int 
 my_mb_wc_gb2312(CHARSET_INFO *cs  __attribute__((unused)),
-        my_wc_t *pwc, const uchar *s, const uchar *e){
+		my_wc_t *pwc, const uchar *s, const uchar *e){
   int hi;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((hi= s[0]) < 0x80)
   {
     pwc[0]=hi;
     return 1;
   }
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+  
   if (!(pwc[0]=func_gb2312_uni_onechar(((hi<<8)+s[1])&0x7F7F)))
     return -2;
-
+  
   return 2;
 }
 
+
 /*
   Returns well formed length of a EUC-KR string.
 */
@@ -6347,6 +6359,7 @@ static int func_uni_gb2312_onechar(int code){
   return (size_t) (b - b0);
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
   NULL,			/* init */
@@ -6393,6 +6406,7 @@ static int func_uni_gb2312_onechar(int code){
   my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_gb2312_chinese_ci=
 {
     24,0,0,		/* number */
@@ -6457,4 +6471,4 @@ static int func_uni_gb2312_onechar(int code){
     &my_collation_mb_bin_handler
 };
 
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/ctype-gbk.c b/dep/mysqllite/strings/ctype-gbk.c
index fbbbcbe..a9558e5 100644
--- a/dep/mysqllite/strings/ctype-gbk.c
+++ b/dep/mysqllite/strings/ctype-gbk.c
@@ -13,7 +13,7 @@
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
 
-/* This file is for Chinese character sets GBK, created by Wei He
+/* This file is for Chinese character sets GBK, created by Wei He 
    (hewei@mail.ied.ac.cn)
 */
 
@@ -25,12 +25,14 @@
  * .configure. mbmaxlen_gbk=2
  */
 
+
 #include <my_global.h>
 #include "m_string.h"
 #include "m_ctype.h"
 
 #ifdef HAVE_CHARSET_gbk
 
+
 /* Support for Chinese(GBK) characters, by hewei@mail.ied.ac.cn */
 
 #define isgbkhead(c) (0x81<=(uchar)(c) && (uchar)(c)<=0xfe)
@@ -135,6 +137,7 @@
   (uchar) '\370',(uchar) '\371',(uchar) '\372',(uchar) '\373',(uchar) '\374',(uchar) '\375',(uchar) '\376',(uchar) '\377',
 };
 
+
 static MY_UNICASE_INFO cA2[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -543,6 +546,7 @@
   {0xA3FF,0xA3FF,0xA3FF}
 };
 
+
 static MY_UNICASE_INFO cA6[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -747,6 +751,7 @@
   {0xA6FF,0xA6FF,0xA6FF}
 };
 
+
 static MY_UNICASE_INFO cA7[256]=
 {
   {0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0}, /* xx00 */
@@ -951,6 +956,7 @@
   {0xA7FF,0xA7FF,0xA7FF}
 };
 
+
 static MY_UNICASE_INFO *my_caseinfo_gbk[256]=
 {
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 0 */
@@ -987,6 +993,8 @@
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
 };
 
+
+
 static uchar sort_order_gbk[]=
 {
   '\000','\001','\002','\003','\004','\005','\006','\007',
@@ -3430,11 +3438,12 @@ static uint16 gbksortorder(uint16 i)
   return 0x8100+gbk_order[idx];
 }
 
+
 int my_strnncoll_gbk_internal(const uchar **a_res, const uchar **b_res,
-                  size_t length)
+			      size_t length)
 {
   const uchar *a= *a_res, *b= *b_res;
-  uint a_char,b_char;
+  uint a_char,b_char; 
 
   while (length--)
   {
@@ -3444,22 +3453,24 @@ int my_strnncoll_gbk_internal(const uchar **a_res, const uchar **b_res,
       b_char= gbkcode(*b,*(b+1));
       if (a_char != b_char)
         return ((int) gbksortorder((uint16) a_char) -
-        (int) gbksortorder((uint16) b_char));
+		(int) gbksortorder((uint16) b_char));
       a+= 2;
       b+= 2;
       length--;
     }
     else if (sort_order_gbk[*a++] != sort_order_gbk[*b++])
       return ((int) sort_order_gbk[a[-1]] -
-          (int) sort_order_gbk[b[-1]]);
+	      (int) sort_order_gbk[b[-1]]);
   }
   *a_res= a;
   *b_res= b;
   return 0;
 }
 
+
+
 int my_strnncoll_gbk(CHARSET_INFO *cs __attribute__((unused)),
-             const uchar *a, size_t a_length,
+		     const uchar *a, size_t a_length,
                      const uchar *b, size_t b_length,
                      my_bool b_is_prefix)
 {
@@ -3468,9 +3479,10 @@ int my_strnncoll_gbk(CHARSET_INFO *cs __attribute__((unused)),
   return res ? res : (int) ((b_is_prefix ? length : a_length) - b_length);
 }
 
+
 static int my_strnncollsp_gbk(CHARSET_INFO * cs __attribute__((unused)),
-                  const uchar *a, size_t a_length,
-                  const uchar *b, size_t b_length,
+			      const uchar *a, size_t a_length, 
+			      const uchar *b, size_t b_length,
                               my_bool diff_if_only_endspace_difference)
 {
   size_t length= min(a_length, b_length);
@@ -3501,12 +3513,13 @@ static int my_strnncollsp_gbk(CHARSET_INFO * cs __attribute__((unused)),
     for (end= a + a_length-length; a < end ; a++)
     {
       if (*a != ' ')
-    return (*a < ' ') ? -swap : swap;
+	return (*a < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 static size_t my_strnxfrm_gbk(CHARSET_INFO *cs __attribute__((unused)),
                               uchar *dest, size_t len,
                               const uchar *src, size_t srclen)
@@ -3526,7 +3539,7 @@ static size_t my_strnxfrm_gbk(CHARSET_INFO *cs __attribute__((unused)),
         *dest++ = gbktail(e);
       src+=2;
       len--;
-    } else
+    } else 
       *dest++ = sort_order_gbk[(uchar) *src++];
   }
   if (dstlen > srclen)
@@ -3534,8 +3547,9 @@ static size_t my_strnxfrm_gbk(CHARSET_INFO *cs __attribute__((unused)),
   return dstlen;
 }
 
+
 static uint ismbchar_gbk(CHARSET_INFO *cs __attribute__((unused)),
-         const char* p, const char *e)
+		 const char* p, const char *e)
 {
   return (isgbkhead(*(p)) && (e)-(p)>1 && isgbktail(*((p)+1))? 2: 0);
 }
@@ -7557,6 +7571,8 @@ static int func_gbk_uni_onechar(int code){
   return(0);
 }
 
+
+
 /* page 0 0x00A4-0x0451 */
 static uint16 tab_uni_gbk0[]={
 0xA1E8,     0,     0,0xA1EC,0xA1A7,     0,     0,     0,
@@ -10649,25 +10665,25 @@ static int func_uni_gbk_onechar(int code){
 
 static int
 my_wc_mb_gbk(CHARSET_INFO *cs  __attribute__((unused)),
-          my_wc_t wc, uchar *s, uchar *e)
+	      my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   if ((uint) wc < 0x80)
   {
     s[0]= (uchar) wc;
     return 1;
   }
-
+  
   if (!(code=func_uni_gbk_onechar(wc)))
     return MY_CS_ILUNI;
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+    
   s[0]=code>>8;
   s[1]=code&0xFF;
   return 2;
@@ -10675,30 +10691,32 @@ static int func_uni_gbk_onechar(int code){
 
 static int
 my_mb_wc_gbk(CHARSET_INFO *cs __attribute__((unused)),
-          my_wc_t *pwc, const uchar *s, const uchar *e)
+	      my_wc_t *pwc, const uchar *s, const uchar *e)
 {
   int hi;
-
+  
   if (s >= e)
     return MY_CS_TOOSMALL;
-
+  
   hi=s[0];
-
+  
   if (hi<0x80)
   {
     pwc[0]=hi;
     return 1;
   }
-
+  
   if (s+2>e)
     return MY_CS_TOOSMALL2;
-
+    
   if (!(pwc[0]=func_gbk_uni_onechar( (hi<<8) + s[1])))
     return -2;
-
+  
   return 2;
+  
 }
 
+
 /*
   Returns well formed length of a GBK string.
 */
@@ -10733,6 +10751,9 @@ size_t my_well_formed_len_gbk(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (b - b0);
 }
 
+
+                             
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
   NULL,			/* init */
@@ -10779,6 +10800,7 @@ size_t my_well_formed_len_gbk(CHARSET_INFO *cs __attribute__((unused)),
   my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_gbk_chinese_ci=
 {
     28,0,0,		/* number */
@@ -10843,4 +10865,5 @@ size_t my_well_formed_len_gbk(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_mb_bin_handler
 };
 
-#endif
\ No newline at end of file
+
+#endif
diff --git a/dep/mysqllite/strings/ctype-latin1.c b/dep/mysqllite/strings/ctype-latin1.c
index 6463bb9..3a96a73 100644
--- a/dep/mysqllite/strings/ctype-latin1.c
+++ b/dep/mysqllite/strings/ctype-latin1.c
@@ -97,7 +97,7 @@
 
 /*
   WL#1494 notes:
-
+  
   We'll use cp1252 instead of iso-8859-1.
   cp1252 contains printable characters in the range 0x80-0x9F.
   In ISO 8859-1, these code points have no associated printable
@@ -105,7 +105,7 @@
   one would lose the euro (for instance). Since most people are
   unaware of the difference, and since we don't really want a
   "Windows ANSI" to differ from a "Unix ANSI", we will:
-
+   
    - continue to pretend the latin1 character set is ISO 8859-1
    - actually allow the storage of euro etc. so it's actually cp1252
 
@@ -358,28 +358,28 @@
 
 static
 int my_mb_wc_latin1(CHARSET_INFO *cs  __attribute__((unused)),
-            my_wc_t *wc,
-            const uchar *str,
-            const uchar *end __attribute__((unused)))
+		    my_wc_t *wc,
+		    const uchar *str,
+		    const uchar *end __attribute__((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   *wc=cs_to_uni[*str];
   return (!wc[0] && str[0]) ? -1 : 1;
 }
 
 static
 int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
-            my_wc_t wc,
-            uchar *str,
-            uchar *end __attribute__((unused)))
+		    my_wc_t wc,
+		    uchar *str,
+		    uchar *end __attribute__((unused)))
 {
   uchar *pl;
-
+  
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   pl= uni_to_cs[(wc>>8) & 0xFF];
   str[0]= pl ? pl[wc & 0xFF] : '\0';
   return (!str[0] && wc) ? MY_CS_ILUNI : 1;
@@ -416,6 +416,7 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
     my_scan_8bit
 };
 
+
 CHARSET_INFO my_charset_latin1=
 {
     8,0,0,				/* number    */
@@ -448,6 +449,9 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
     &my_collation_8bit_simple_ci_handler
 };
 
+
+
+
 /*
  * This file is the latin1 character set with German sorting
  *
@@ -459,6 +463,7 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
  * ''  ->  "ss"
  */
 
+
 /*
  * This is a simple latin1 mapping table, which maps all accented
  * characters to their non-accented equivalents.  Note: in this
@@ -486,6 +491,7 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
    68, 78, 79, 79, 79, 79,214,247,216, 85, 85, 85,220, 89,222, 89
 };
 
+
 /*
   same as sort_order_latin_de, but maps ALL accented chars to unaccented ones
 */
@@ -522,6 +528,7 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,69, 0, 0, 0, 0, 0,69, 0, 0, 0, 0
 };
 
+
 /*
   Some notes about the following comparison rules:
   By definition, my_strnncoll_latin_de must works exactly as if had called
@@ -535,9 +542,10 @@ int my_wc_mb_latin1(CHARSET_INFO *cs  __attribute__((unused)),
   sort_order_latin_de[] at all
 */
 
+
 static int my_strnncoll_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
-                  const uchar *a, size_t a_length,
-                  const uchar *b, size_t b_length,
+				  const uchar *a, size_t a_length,
+				  const uchar *b, size_t b_length,
                                   my_bool b_is_prefix)
 {
   const uchar *a_end= a + a_length;
@@ -572,12 +580,13 @@ static int my_strnncoll_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
     which string ran out first
   */
   return ((a < a_end || a_extend) ? (b_is_prefix ? 0 : 1) :
-      (b < b_end || b_extend) ? -1 : 0);
+	  (b < b_end || b_extend) ? -1 : 0);
 }
 
+
 static int my_strnncollsp_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
-                    const uchar *a, size_t a_length,
-                    const uchar *b, size_t b_length,
+				    const uchar *a, size_t a_length,
+				    const uchar *b, size_t b_length,
                                     my_bool diff_if_only_endspace_difference)
 {
   const uchar *a_end= a + a_length, *b_end= b + b_length;
@@ -640,12 +649,13 @@ static int my_strnncollsp_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
     for ( ; a < a_end ; a++)
     {
       if (*a != ' ')
-    return (*a < ' ') ? -swap : swap;
+	return (*a < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 static size_t my_strnxfrm_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
                                     uchar *dest, size_t len,
                                     const uchar *src, size_t srclen)
@@ -664,9 +674,10 @@ static size_t my_strnxfrm_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
   return (int) len;
 }
 
+
 void my_hash_sort_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
-                const uchar *key, size_t len,
-                ulong *nr1, ulong *nr2)
+			    const uchar *key, size_t len,
+			    ulong *nr1, ulong *nr2)
 {
   const uchar *end;
   /*
@@ -688,6 +699,7 @@ void my_hash_sort_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
   }
 }
 
+
 static MY_COLLATION_HANDLER my_collation_german2_ci_handler=
 {
   NULL,			/* init */
@@ -703,6 +715,7 @@ void my_hash_sort_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
   my_propagate_complex
 };
 
+
 CHARSET_INFO my_charset_latin1_german2_ci=
 {
   31,0,0,				/* number    */
@@ -735,6 +748,7 @@ void my_hash_sort_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
   &my_collation_german2_ci_handler
 };
 
+
 CHARSET_INFO my_charset_latin1_bin=
 {
   47,0,0,				/* number    */
@@ -765,4 +779,5 @@ void my_hash_sort_latin1_de(CHARSET_INFO *cs __attribute__((unused)),
   0,                                    /* escape_with_backslash_is_dangerous */
   &my_charset_handler,
   &my_collation_8bit_bin_handler
-};
\ No newline at end of file
+};
+
diff --git a/dep/mysqllite/strings/ctype-mb.c b/dep/mysqllite/strings/ctype-mb.c
index 34dad3b..e0da940 100644
--- a/dep/mysqllite/strings/ctype-mb.c
+++ b/dep/mysqllite/strings/ctype-mb.c
@@ -19,19 +19,20 @@
 
 #ifdef USE_MB
 
+
 size_t my_caseup_str_mb(CHARSET_INFO * cs, char *str)
 {
   register uint32 l;
   register uchar *map= cs->to_upper;
   char *str_orig= str;
-
+  
   while (*str)
   {
     /* Pointing after the '\0' is safe here. */
     if ((l= my_ismbchar(cs, str, str + cs->mbmaxlen)))
       str+= l;
     else
-    {
+    { 
       *str= (char) map[(uchar)*str];
       str++;
     }
@@ -39,12 +40,13 @@ size_t my_caseup_str_mb(CHARSET_INFO * cs, char *str)
   return (size_t) (str - str_orig);
 }
 
+
 size_t my_casedn_str_mb(CHARSET_INFO * cs, char *str)
 {
   register uint32 l;
   register uchar *map= cs->to_lower;
   char *str_orig= str;
-
+  
   while (*str)
   {
     /* Pointing after the '\0' is safe here. */
@@ -59,6 +61,7 @@ size_t my_casedn_str_mb(CHARSET_INFO * cs, char *str)
   return (size_t) (str - str_orig);
 }
 
+
 static inline MY_UNICASE_INFO*
 get_case_info_for_ch(CHARSET_INFO *cs, uint page, uint offs)
 {
@@ -66,6 +69,7 @@ size_t my_casedn_str_mb(CHARSET_INFO * cs, char *str)
   return cs->caseinfo ? ((p= cs->caseinfo[page]) ? &p[offs] : NULL) :  NULL;
 }
 
+
 /*
   For character sets which don't change octet length in case conversion.
 */
@@ -80,7 +84,7 @@ size_t my_caseup_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   DBUG_ASSERT(cs->caseup_multiply == 1);
   DBUG_ASSERT(src == dst && srclen == dstlen);
   DBUG_ASSERT(cs->mbmaxlen == 2);
-
+  
   while (src < srcend)
   {
     if ((l=my_ismbchar(cs, src, srcend)))
@@ -94,7 +98,7 @@ size_t my_caseup_mb(CHARSET_INFO * cs, char *src, size_t srclen,
       else
         src+= l;
     }
-    else
+    else 
     {
       *src=(char) map[(uchar) *src];
       src++;
@@ -103,6 +107,7 @@ size_t my_caseup_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   return srclen;
 }
 
+
 size_t my_casedn_mb(CHARSET_INFO * cs, char *src, size_t srclen,
                     char *dst __attribute__((unused)),
                     size_t dstlen __attribute__((unused)))
@@ -112,9 +117,9 @@ size_t my_casedn_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   register uchar *map=cs->to_lower;
 
   DBUG_ASSERT(cs->casedn_multiply == 1);
-  DBUG_ASSERT(src == dst && srclen == dstlen);
+  DBUG_ASSERT(src == dst && srclen == dstlen);  
   DBUG_ASSERT(cs->mbmaxlen == 2);
-
+  
   while (src < srcend)
   {
     if ((l= my_ismbchar(cs, src, srcend)))
@@ -137,6 +142,7 @@ size_t my_casedn_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   return srclen;
 }
 
+
 /*
   Case folding functions for character set
   where case conversion can change string octet length.
@@ -185,15 +191,17 @@ size_t my_casedn_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   return (size_t) (dst - dst0);
 }
 
+
 size_t
 my_casedn_mb_varlen(CHARSET_INFO * cs, char *src, size_t srclen,
                     char *dst, size_t dstlen)
 {
-  DBUG_ASSERT(dstlen >= srclen * cs->casedn_multiply);
+  DBUG_ASSERT(dstlen >= srclen * cs->casedn_multiply); 
   DBUG_ASSERT(src != dst || cs->casedn_multiply == 1);
   return my_casefold_mb_varlen(cs, src, srclen, dst, dstlen, cs->to_lower, 0);
 }
 
+
 size_t
 my_caseup_mb_varlen(CHARSET_INFO * cs, char *src, size_t srclen,
                     char *dst, size_t dstlen)
@@ -203,6 +211,7 @@ size_t my_casedn_mb(CHARSET_INFO * cs, char *src, size_t srclen,
   return my_casefold_mb_varlen(cs, src, srclen, dst, dstlen, cs->to_upper, 1);
 }
 
+
 /*
   my_strcasecmp_mb() returns 0 if strings are equal, non-zero otherwise.
  */
@@ -211,14 +220,14 @@ int my_strcasecmp_mb(CHARSET_INFO * cs,const char *s, const char *t)
 {
   register uint32 l;
   register uchar *map=cs->to_upper;
-
+  
   while (*s && *t)
   {
     /* Pointing after the '\0' is safe here. */
     if ((l=my_ismbchar(cs, s, s + cs->mbmaxlen)))
     {
       while (l--)
-        if (*s++ != *t++)
+        if (*s++ != *t++) 
           return 1;
     }
     else if (my_mbcharlen(cs, *t) > 1)
@@ -230,6 +239,7 @@ int my_strcasecmp_mb(CHARSET_INFO * cs,const char *s, const char *t)
   return (*t != *s);
 }
 
+
 /*
 ** Compare string against string with wildcard
 **	0 if matched
@@ -242,9 +252,9 @@ int my_strcasecmp_mb(CHARSET_INFO * cs,const char *s, const char *t)
 #define likeconv(s,A) (uchar) (s)->sort_order[(uchar) (A)]
 
 int my_wildcmp_mb(CHARSET_INFO *cs,
-          const char *str,const char *str_end,
-          const char *wildstr,const char *wildend,
-          int escape, int w_one, int w_many)
+		  const char *str,const char *str_end,
+		  const char *wildstr,const char *wildend,
+		  int escape, int w_one, int w_many)
 {
   int result= -1;				/* Not found, using wildcards */
 
@@ -254,65 +264,65 @@ int my_wildcmp_mb(CHARSET_INFO *cs,
     {
       int l;
       if (*wildstr == escape && wildstr+1 != wildend)
-    wildstr++;
+	wildstr++;
       if ((l = my_ismbchar(cs, wildstr, wildend)))
       {
-      if (str+l > str_end || memcmp(str, wildstr, l) != 0)
-          return 1;
-      str += l;
-      wildstr += l;
+	  if (str+l > str_end || memcmp(str, wildstr, l) != 0)
+	      return 1;
+	  str += l;
+	  wildstr += l;
       }
       else
       if (str == str_end || likeconv(cs,*wildstr++) != likeconv(cs,*str++))
-    return(1);				/* No match */
+	return(1);				/* No match */
       if (wildstr == wildend)
-    return (str != str_end);		/* Match if both are at end */
+	return (str != str_end);		/* Match if both are at end */
       result=1;					/* Found an anchor char */
     }
     if (*wildstr == w_one)
     {
       do
       {
-    if (str == str_end)			/* Skip one char if possible */
-      return (result);
-    INC_PTR(cs,str,str_end);
+	if (str == str_end)			/* Skip one char if possible */
+	  return (result);
+	INC_PTR(cs,str,str_end);
       } while (++wildstr < wildend && *wildstr == w_one);
       if (wildstr == wildend)
-    break;
+	break;
     }
     if (*wildstr == w_many)
     {						/* Found w_many */
       uchar cmp;
       const char* mb = wildstr;
       int mb_len=0;
-
+      
       wildstr++;
       /* Remove any '%' and '_' from the wild search string */
       for (; wildstr != wildend ; wildstr++)
       {
-    if (*wildstr == w_many)
-      continue;
-    if (*wildstr == w_one)
-    {
-      if (str == str_end)
-        return (-1);
-      INC_PTR(cs,str,str_end);
-      continue;
-    }
-    break;					/* Not a wild character */
+	if (*wildstr == w_many)
+	  continue;
+	if (*wildstr == w_one)
+	{
+	  if (str == str_end)
+	    return (-1);
+	  INC_PTR(cs,str,str_end);
+	  continue;
+	}
+	break;					/* Not a wild character */
       }
       if (wildstr == wildend)
-    return(0);				/* Ok if w_many is last */
+	return(0);				/* Ok if w_many is last */
       if (str == str_end)
-    return -1;
-
+	return -1;
+      
       if ((cmp= *wildstr) == escape && wildstr+1 != wildend)
-    cmp= *++wildstr;
-
+	cmp= *++wildstr;
+	
       mb=wildstr;
       mb_len= my_ismbchar(cs, wildstr, wildend);
       INC_PTR(cs,wildstr,wildend);		/* This is compared trough cmp */
-      cmp=likeconv(cs,cmp);
+      cmp=likeconv(cs,cmp);   
       do
       {
         for (;;)
@@ -335,12 +345,12 @@ int my_wildcmp_mb(CHARSET_INFO *cs,
           }
           INC_PTR(cs,str, str_end);
         }
-    {
-      int tmp=my_wildcmp_mb(cs,str,str_end,wildstr,wildend,escape,w_one,
+	{
+	  int tmp=my_wildcmp_mb(cs,str,str_end,wildstr,wildend,escape,w_one,
                                 w_many);
-      if (tmp <= 0)
-        return (tmp);
-    }
+	  if (tmp <= 0)
+	    return (tmp);
+	}
       } while (str != str_end && wildstr[0] != w_many);
       return(-1);
     }
@@ -348,11 +358,12 @@ int my_wildcmp_mb(CHARSET_INFO *cs,
   return (str != str_end ? 1 : 0);
 }
 
+
 size_t my_numchars_mb(CHARSET_INFO *cs __attribute__((unused)),
-              const char *pos, const char *end)
+		      const char *pos, const char *end)
 {
   register size_t count= 0;
-  while (pos < end)
+  while (pos < end) 
   {
     uint mb_len;
     pos+= (mb_len= my_ismbchar(cs,pos,end)) ? mb_len : 1;
@@ -361,11 +372,12 @@ size_t my_numchars_mb(CHARSET_INFO *cs __attribute__((unused)),
   return count;
 }
 
+
 size_t my_charpos_mb(CHARSET_INFO *cs __attribute__((unused)),
-             const char *pos, const char *end, size_t length)
+		     const char *pos, const char *end, size_t length)
 {
   const char *start= pos;
-
+  
   while (length && pos < end)
   {
     uint mb_len;
@@ -375,6 +387,7 @@ size_t my_charpos_mb(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (length ? end+2-start : pos-start);
 }
 
+
 size_t my_well_formed_len_mb(CHARSET_INFO *cs, const char *b, const char *e,
                              size_t pos, int *error)
 {
@@ -396,14 +409,15 @@ size_t my_well_formed_len_mb(CHARSET_INFO *cs, const char *b, const char *e,
   return (size_t) (b - b_start);
 }
 
+
 uint my_instr_mb(CHARSET_INFO *cs,
-                 const char *b, size_t b_length,
+                 const char *b, size_t b_length, 
                  const char *s, size_t s_length,
                  my_match_t *match, uint nmatch)
 {
   register const char *end, *b0;
   int res= 0;
-
+  
   if (s_length <= b_length)
   {
     if (!s_length)
@@ -416,16 +430,16 @@ uint my_instr_mb(CHARSET_INFO *cs,
       }
       return 1;		/* Empty string is always found */
     }
-
+    
     b0= b;
     end= b+b_length-s_length+1;
-
+    
     while (b < end)
     {
       int mb_len;
-
-      if (!cs->coll->strnncoll(cs, (uchar*) b,   s_length,
-                       (uchar*) s, s_length, 0))
+      
+      if (!cs->coll->strnncoll(cs, (uchar*) b,   s_length, 
+      				   (uchar*) s, s_length, 0))
       {
         if (nmatch)
         {
@@ -450,6 +464,7 @@ uint my_instr_mb(CHARSET_INFO *cs,
   return 0;
 }
 
+
 /* BINARY collations handlers for MB charsets */
 
 int
@@ -463,9 +478,10 @@ uint my_instr_mb(CHARSET_INFO *cs,
   return cmp ? cmp : (int) ((t_is_prefix ? len : slen) - tlen);
 }
 
-/*
-  Compare two strings.
 
+/*
+  Compare two strings. 
+  
   SYNOPSIS
     my_strnncollsp_mb_bin()
     cs			Chararacter set
@@ -474,7 +490,7 @@ uint my_instr_mb(CHARSET_INFO *cs,
     t			String to compare
     tlen		Length of 't'
     diff_if_only_endspace_difference
-                Set to 1 if the strings should be regarded as different
+		        Set to 1 if the strings should be regarded as different
                         if they only difference in end space
 
   NOTE
@@ -490,7 +506,7 @@ uint my_instr_mb(CHARSET_INFO *cs,
 
 int
 my_strnncollsp_mb_bin(CHARSET_INFO * cs __attribute__((unused)),
-                      const uchar *a, size_t a_length,
+                      const uchar *a, size_t a_length, 
                       const uchar *b, size_t b_length,
                       my_bool diff_if_only_endspace_difference)
 {
@@ -501,7 +517,7 @@ uint my_instr_mb(CHARSET_INFO *cs,
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
   diff_if_only_endspace_difference= 0;
 #endif
-
+  
   end= a + (length= min(a_length, b_length));
   while (a < end)
   {
@@ -529,12 +545,13 @@ uint my_instr_mb(CHARSET_INFO *cs,
     for (end= a + a_length-length; a < end ; a++)
     {
       if (*a != ' ')
-    return (*a < ' ') ? -swap : swap;
+	return (*a < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 static size_t my_strnxfrm_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
                                  uchar *dest, size_t dstlen,
                                  const uchar *src, size_t srclen)
@@ -546,6 +563,7 @@ static size_t my_strnxfrm_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
   return dstlen;
 }
 
+
 int
 my_strcasecmp_mb_bin(CHARSET_INFO * cs __attribute__((unused)),
                      const char *s, const char *t)
@@ -553,27 +571,29 @@ static size_t my_strnxfrm_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
   return strcmp(s,t);
 }
 
+
 void
 my_hash_sort_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
                     const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
-
+  
   /*
      Remove trailing spaces. We have to do this to be able to compare
     'A ' and 'A' as identical
   */
   key= skip_trailing_space(key, len);
-
+  
   for (; pos < (uchar*) key ; pos++)
   {
-    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) *
-         ((uint)*pos)) + (nr1[0] << 8);
+    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) * 
+	     ((uint)*pos)) + (nr1[0] << 8);
     nr2[0]+=3;
   }
 }
 
-/*
+
+/* 
   Fill the given buffer with 'maximum character' for given charset
   SYNOPSIS
       pad_max_char()
@@ -589,13 +609,13 @@ static size_t my_strnxfrm_mb_bin(CHARSET_INFO *cs __attribute__((unused)),
         and optionally pad with a single space character.
       - for Unicode character set (utf-8):
         create a buffer with multibyte representation of the max_sort_char
-        character, and copy it into max_str in a loop.
+        character, and copy it into max_str in a loop. 
 */
 static void pad_max_char(CHARSET_INFO *cs, char *str, char *end)
 {
   char buf[10];
   char buflen;
-
+  
   if (!(cs->state & MY_CS_UNICODE))
   {
     if (cs->max_sort_char <= 255)
@@ -612,7 +632,7 @@ static void pad_max_char(CHARSET_INFO *cs, char *str, char *end)
     buflen= cs->cset->wc_mb(cs, cs->max_sort_char, (uchar*) buf,
                             (uchar*) buf + sizeof(buf));
   }
-
+  
   DBUG_ASSERT(buflen > 0);
   do
   {
@@ -624,10 +644,10 @@ static void pad_max_char(CHARSET_INFO *cs, char *str, char *end)
     }
     else
     {
-      /*
+      /* 
         There is no space for whole multibyte
         character, then add trailing spaces.
-      */
+      */  
       *str++= ' ';
     }
   } while (str < end);
@@ -651,11 +671,11 @@ static void pad_max_char(CHARSET_INFO *cs, char *str, char *end)
 */
 
 my_bool my_like_range_mb(CHARSET_INFO *cs,
-             const char *ptr,size_t ptr_length,
-             pbool escape, pbool w_one, pbool w_many,
-             size_t res_length,
-             char *min_str,char *max_str,
-             size_t *min_length,size_t *max_length)
+			 const char *ptr,size_t ptr_length,
+			 pbool escape, pbool w_one, pbool w_many,
+			 size_t res_length,
+			 char *min_str,char *max_str,
+			 size_t *min_length,size_t *max_length)
 {
   uint mb_len;
   const char *end= ptr + ptr_length;
@@ -663,7 +683,7 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
   char *min_end= min_str + res_length;
   char *max_end= max_str + res_length;
   size_t maxcharlen= res_length / cs->mbmaxlen;
-  const char *contraction_flags= cs->contractions ?
+  const char *contraction_flags= cs->contractions ? 
               ((const char*) cs->contractions) + 0x40*0x40 : NULL;
 
   for (; ptr != end && min_str != min_end && maxcharlen ; maxcharlen--)
@@ -672,7 +692,7 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
     if (*ptr == escape && ptr+1 != end)
       ptr++;                                    /* Skip escape */
     else if (*ptr == w_one || *ptr == w_many)   /* '_' and '%' in SQL */
-    {
+    {      
 fill_max_and_min:
       /*
         Calculate length of keys:
@@ -685,13 +705,13 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
       /* Create min key  */
       do
       {
-    *min_str++= (char) cs->min_sort_char;
+	*min_str++= (char) cs->min_sort_char;
       } while (min_str != min_end);
-
-      /*
+      
+      /* 
         Write max key: create a buffer with multibyte
         representation of the max_sort_char character,
-        and copy it into max_str in a loop.
+        and copy it into max_str in a loop. 
       */
       *max_length= res_length;
       pad_max_char(cs, max_str, max_end);
@@ -736,21 +756,21 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
           contraction_flags[(uchar) *ptr])
       {
         /* Ptr[0] is a contraction head. */
-
+        
         if (ptr[1] == w_one || ptr[1] == w_many)
         {
           /* Contraction head followed by a wildcard, quit. */
           goto fill_max_and_min;
         }
-
+        
         /*
           Some letters can be both contraction heads and contraction tails.
           For example, in Danish 'aa' is a separate single letter which
           is sorted after 'z'. So 'a' can be both head and tail.
-
+          
           If ptr[0]+ptr[1] is a contraction,
           then put both letters together.
-
+          
           If ptr[1] can be a contraction part, but ptr[0]+ptr[1]
           is not a contraction, then we put only ptr[0],
           and continue with ptr[1] on the next loop.
@@ -764,14 +784,14 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
             /* Both contraction parts don't fit, quit */
             goto fill_max_and_min;
           }
-
+          
           /* Put contraction head */
           *min_str++= *max_str++= *ptr++;
           maxcharlen--;
         }
       }
       /* Put contraction tail, or a single character */
-      *min_str++= *max_str++= *ptr++;
+      *min_str++= *max_str++= *ptr++;    
     }
   }
 
@@ -781,6 +801,7 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
   return 0;
 }
 
+
 /**
    Calculate min_str and max_str that ranges a LIKE string.
    Generic function, currently used for ucs2, utf16, utf32,
@@ -966,6 +987,7 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
   return FALSE;
 }
 
+
 int
 my_wildcmp_mb_bin(CHARSET_INFO *cs,
                   const char *str,const char *str_end,
@@ -980,61 +1002,61 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
     {
       int l;
       if (*wildstr == escape && wildstr+1 != wildend)
-    wildstr++;
+	wildstr++;
       if ((l = my_ismbchar(cs, wildstr, wildend)))
       {
-      if (str+l > str_end || memcmp(str, wildstr, l) != 0)
-          return 1;
-      str += l;
-      wildstr += l;
+	  if (str+l > str_end || memcmp(str, wildstr, l) != 0)
+	      return 1;
+	  str += l;
+	  wildstr += l;
       }
       else
       if (str == str_end || *wildstr++ != *str++)
-    return(1);				/* No match */
+	return(1);				/* No match */
       if (wildstr == wildend)
-    return (str != str_end);		/* Match if both are at end */
+	return (str != str_end);		/* Match if both are at end */
       result=1;					/* Found an anchor char */
     }
     if (*wildstr == w_one)
     {
       do
       {
-    if (str == str_end)			/* Skip one char if possible */
-      return (result);
-    INC_PTR(cs,str,str_end);
+	if (str == str_end)			/* Skip one char if possible */
+	  return (result);
+	INC_PTR(cs,str,str_end);
       } while (++wildstr < wildend && *wildstr == w_one);
       if (wildstr == wildend)
-    break;
+	break;
     }
     if (*wildstr == w_many)
     {						/* Found w_many */
       uchar cmp;
       const char* mb = wildstr;
       int mb_len=0;
-
+      
       wildstr++;
       /* Remove any '%' and '_' from the wild search string */
       for (; wildstr != wildend ; wildstr++)
       {
-    if (*wildstr == w_many)
-      continue;
-    if (*wildstr == w_one)
-    {
-      if (str == str_end)
-        return (-1);
-      INC_PTR(cs,str,str_end);
-      continue;
-    }
-    break;					/* Not a wild character */
+	if (*wildstr == w_many)
+	  continue;
+	if (*wildstr == w_one)
+	{
+	  if (str == str_end)
+	    return (-1);
+	  INC_PTR(cs,str,str_end);
+	  continue;
+	}
+	break;					/* Not a wild character */
       }
       if (wildstr == wildend)
-    return(0);				/* Ok if w_many is last */
+	return(0);				/* Ok if w_many is last */
       if (str == str_end)
-    return -1;
-
+	return -1;
+      
       if ((cmp= *wildstr) == escape && wildstr+1 != wildend)
-    cmp= *++wildstr;
-
+	cmp= *++wildstr;
+	
       mb=wildstr;
       mb_len= my_ismbchar(cs, wildstr, wildend);
       INC_PTR(cs,wildstr,wildend);		/* This is compared trough cmp */
@@ -1059,11 +1081,11 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
           }
           INC_PTR(cs,str, str_end);
         }
-    {
-      int tmp=my_wildcmp_mb_bin(cs,str,str_end,wildstr,wildend,escape,w_one,w_many);
-      if (tmp <= 0)
-        return (tmp);
-    }
+	{
+	  int tmp=my_wildcmp_mb_bin(cs,str,str_end,wildstr,wildend,escape,w_one,w_many);
+	  if (tmp <= 0)
+	    return (tmp);
+	}
       } while (str != str_end && wildstr[0] != w_many);
       return(-1);
     }
@@ -1071,8 +1093,9 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
   return (str != str_end ? 1 : 0);
 }
 
+
 /*
-  Data was produced from EastAsianWidth.txt
+  Data was produced from EastAsianWidth.txt 
   using utt11-dump utility.
 */
 static char pg11[256]=
@@ -1279,11 +1302,12 @@ my_bool my_like_range_mb(CHARSET_INFO *cs,
 {0,NULL},{1,NULL},{0,pgFA},{0,NULL},{0,NULL},{0,NULL},{0,pgFE},{0,pgFF}
 };
 
+
 size_t my_numcells_mb(CHARSET_INFO *cs, const char *b, const char *e)
 {
   my_wc_t wc;
   size_t clen= 0;
-
+  
   while (b < e)
   {
     int mb_len;
@@ -1310,6 +1334,7 @@ size_t my_numcells_mb(CHARSET_INFO *cs, const char *b, const char *e)
   return clen;
 }
 
+
 int my_mb_ctype_mb(CHARSET_INFO *cs, int *ctype,
                    const uchar *s, const uchar *e)
 {
@@ -1320,10 +1345,11 @@ int my_mb_ctype_mb(CHARSET_INFO *cs, int *ctype,
   else
     *ctype= my_uni_ctype[wc>>8].ctype ?
             my_uni_ctype[wc>>8].ctype[wc&0xFF] :
-            my_uni_ctype[wc>>8].pctype;
+            my_uni_ctype[wc>>8].pctype;    
   return res;
 }
 
+
 MY_COLLATION_HANDLER my_collation_mb_bin_handler =
 {
     NULL,		/* init */
@@ -1339,4 +1365,5 @@ int my_mb_ctype_mb(CHARSET_INFO *cs, int *ctype,
     my_propagate_simple
 };
 
-#endif
\ No newline at end of file
+
+#endif
diff --git a/dep/mysqllite/strings/ctype-simple.c b/dep/mysqllite/strings/ctype-simple.c
index 8a5fb37..d5f1c53 100644
--- a/dep/mysqllite/strings/ctype-simple.c
+++ b/dep/mysqllite/strings/ctype-simple.c
@@ -30,46 +30,48 @@ size_t my_strnxfrmlen_simple(CHARSET_INFO *cs, size_t len)
   return len * (cs->strxfrm_multiply ? cs->strxfrm_multiply : 1);
 }
 
+
 /*
   Converts a string into its sort key.
-
+  
   SYNOPSIS
      my_strnxfrm_xxx()
-
+     
   IMPLEMENTATION
-
+     
      The my_strxfrm_xxx() function transforms a string pointed to by
-     'src' with length 'srclen' according to the charset+collation
+     'src' with length 'srclen' according to the charset+collation 
      pair 'cs' and copies the result key into 'dest'.
-
+     
      Comparing two strings using memcmp() after my_strnxfrm_xxx()
      is equal to comparing two original strings with my_strnncollsp_xxx().
-
+     
      Not more than 'dstlen' bytes are written into 'dst'.
      To garantee that the whole string is transformed, 'dstlen' must be
      at least srclen*cs->strnxfrm_multiply bytes long. Otherwise,
      consequent memcmp() may return a non-accurate result.
-
+     
      If the source string is too short to fill whole 'dstlen' bytes,
      then the 'dest' string is padded up to 'dstlen', ensuring that:
-
+     
        "a"  == "a "
        "a\0" < "a"
        "a\0" < "a "
-
+     
      my_strnxfrm_simple() is implemented for 8bit charsets and
      simple collations with one-to-one string->key transformation.
-
-     See also implementations for various charsets/collations in
+     
+     See also implementations for various charsets/collations in  
      other ctype-xxx.c files.
-
+     
   RETURN
-
+  
     Target len 'dstlen'.
-
+  
 */
 
-size_t my_strnxfrm_simple(CHARSET_INFO * cs,
+
+size_t my_strnxfrm_simple(CHARSET_INFO * cs, 
                           uchar *dest, size_t len,
                           const uchar *src, size_t srclen)
 {
@@ -93,7 +95,8 @@ size_t my_strnxfrm_simple(CHARSET_INFO * cs,
   return dstlen;
 }
 
-int my_strnncoll_simple(CHARSET_INFO * cs, const uchar *s, size_t slen,
+
+int my_strnncoll_simple(CHARSET_INFO * cs, const uchar *s, size_t slen, 
                         const uchar *t, size_t tlen,
                         my_bool t_is_prefix)
 {
@@ -113,6 +116,7 @@ int my_strnncoll_simple(CHARSET_INFO * cs, const uchar *s, size_t slen,
   return slen > tlen ? 1 : slen < tlen ? -1 : 0 ;
 }
 
+
 /*
   Compare strings, discarding end space
 
@@ -124,7 +128,7 @@ int my_strnncoll_simple(CHARSET_INFO * cs, const uchar *s, size_t slen,
     b			Second string to compare
     b_length		Length of 'b'
     diff_if_only_endspace_difference
-                Set to 1 if the strings should be regarded as different
+		        Set to 1 if the strings should be regarded as different
                         if they only difference in end space
 
   IMPLEMENTATION
@@ -143,8 +147,8 @@ int my_strnncoll_simple(CHARSET_INFO * cs, const uchar *s, size_t slen,
     > 0	 a > b
 */
 
-int my_strnncollsp_simple(CHARSET_INFO * cs, const uchar *a, size_t a_length,
-              const uchar *b, size_t b_length,
+int my_strnncollsp_simple(CHARSET_INFO * cs, const uchar *a, size_t a_length, 
+			  const uchar *b, size_t b_length,
                           my_bool diff_if_only_endspace_difference)
 {
   const uchar *map= cs->sort_order, *end;
@@ -182,12 +186,13 @@ int my_strnncollsp_simple(CHARSET_INFO * cs, const uchar *a, size_t a_length,
     for (end= a + a_length-length; a < end ; a++)
     {
       if (map[*a] != map[' '])
-    return (map[*a] < map[' ']) ? -swap : swap;
+	return (map[*a] < map[' ']) ? -swap : swap;
     }
   }
   return res;
 }
 
+
 size_t my_caseup_str_8bit(CHARSET_INFO * cs,char *str)
 {
   register uchar *map= cs->to_upper;
@@ -197,6 +202,7 @@ size_t my_caseup_str_8bit(CHARSET_INFO * cs,char *str)
   return (size_t) (str - str_orig);
 }
 
+
 size_t my_casedn_str_8bit(CHARSET_INFO * cs,char *str)
 {
   register uchar *map= cs->to_lower;
@@ -206,6 +212,7 @@ size_t my_casedn_str_8bit(CHARSET_INFO * cs,char *str)
   return (size_t) (str - str_orig);
 }
 
+
 size_t my_caseup_8bit(CHARSET_INFO * cs, char *src, size_t srclen,
                       char *dst __attribute__((unused)),
                       size_t dstlen __attribute__((unused)))
@@ -218,6 +225,7 @@ size_t my_caseup_8bit(CHARSET_INFO * cs, char *src, size_t srclen,
   return srclen;
 }
 
+
 size_t my_casedn_8bit(CHARSET_INFO * cs, char *src, size_t srclen,
                       char *dst __attribute__((unused)),
                       size_t dstlen __attribute__((unused)))
@@ -238,26 +246,27 @@ int my_strcasecmp_8bit(CHARSET_INFO * cs,const char *s, const char *t)
   return ((int) map[(uchar) s[0]] - (int) map[(uchar) t[-1]]);
 }
 
+
 int my_mb_wc_8bit(CHARSET_INFO *cs,my_wc_t *wc,
-          const uchar *str,
-          const uchar *end __attribute__((unused)))
+		  const uchar *str,
+		  const uchar *end __attribute__((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   *wc=cs->tab_to_uni[*str];
   return (!wc[0] && str[0]) ? -1 : 1;
 }
 
 int my_wc_mb_8bit(CHARSET_INFO *cs,my_wc_t wc,
-          uchar *str,
-          uchar *end)
+		  uchar *str,
+		  uchar *end)
 {
   MY_UNI_IDX *idx;
 
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   for (idx=cs->tab_from_uni; idx->tab ; idx++)
   {
     if (idx->from <= wc && idx->to >= wc)
@@ -269,7 +278,8 @@ int my_wc_mb_8bit(CHARSET_INFO *cs,my_wc_t wc,
   return MY_CS_ILUNI;
 }
 
-/*
+
+/* 
    We can't use vsprintf here as it's not guaranteed to return
    the length on all operating systems.
    This function is also not called in a safe environment, so the
@@ -278,7 +288,7 @@ int my_wc_mb_8bit(CHARSET_INFO *cs,my_wc_t wc,
 
 size_t my_snprintf_8bit(CHARSET_INFO *cs  __attribute__((unused)),
                         char* to, size_t n  __attribute__((unused)),
-             const char* fmt, ...)
+		     const char* fmt, ...)
 {
   va_list args;
   int result;
@@ -288,30 +298,32 @@ size_t my_snprintf_8bit(CHARSET_INFO *cs  __attribute__((unused)),
   return result;
 }
 
+
 void my_hash_sort_simple(CHARSET_INFO *cs,
-             const uchar *key, size_t len,
-             ulong *nr1, ulong *nr2)
+			 const uchar *key, size_t len,
+			 ulong *nr1, ulong *nr2)
 {
   register uchar *sort_order=cs->sort_order;
   const uchar *end;
-
+  
   /*
     Remove end space. We have to do this to be able to compare
     'A ' and 'A' as identical
   */
   end= skip_trailing_space(key, len);
-
+  
   for (; key < (uchar*) end ; key++)
   {
-    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) *
-         ((uint) sort_order[(uint) *key])) + (nr1[0] << 8);
+    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) * 
+	     ((uint) sort_order[(uint) *key])) + (nr1[0] << 8);
     nr2[0]+=3;
   }
 }
 
+
 long my_strntol_8bit(CHARSET_INFO *cs,
-             const char *nptr, size_t l, int base,
-             char **endptr, int *err)
+		     const char *nptr, size_t l, int base,
+		     char **endptr, int *err)
 {
   int negative;
   register uint32 cutoff;
@@ -326,14 +338,14 @@ long my_strntol_8bit(CHARSET_INFO *cs,
 
   s = nptr;
   e = nptr+l;
-
+  
   for ( ; s<e && my_isspace(cs, *s) ; s++);
-
+  
   if (s == e)
   {
     goto noconv;
   }
-
+  
   /* Check for a sign.	*/
   if (*s == '-')
   {
@@ -374,13 +386,13 @@ long my_strntol_8bit(CHARSET_INFO *cs,
       i += c;
     }
   }
-
+  
   if (s == save)
     goto noconv;
-
+  
   if (endptr != NULL)
     *endptr = (char *) s;
-
+  
   if (negative)
   {
     if (i  > (uint32) INT_MIN32)
@@ -388,13 +400,13 @@ long my_strntol_8bit(CHARSET_INFO *cs,
   }
   else if (i > INT_MAX32)
     overflow = 1;
-
+  
   if (overflow)
   {
     err[0]= ERANGE;
     return negative ? INT_MIN32 : INT_MAX32;
   }
-
+  
   return (negative ? -((long) i) : (long) i);
 
 noconv:
@@ -404,9 +416,10 @@ long my_strntol_8bit(CHARSET_INFO *cs,
   return 0L;
 }
 
+
 ulong my_strntoul_8bit(CHARSET_INFO *cs,
-               const char *nptr, size_t l, int base,
-               char **endptr, int *err)
+		       const char *nptr, size_t l, int base,
+		       char **endptr, int *err)
 {
   int negative;
   register uint32 cutoff;
@@ -421,9 +434,9 @@ ulong my_strntoul_8bit(CHARSET_INFO *cs,
 
   s = nptr;
   e = nptr+l;
-
+  
   for( ; s<e && my_isspace(cs, *s); s++);
-
+  
   if (s==e)
   {
     goto noconv;
@@ -447,7 +460,7 @@ ulong my_strntoul_8bit(CHARSET_INFO *cs,
   cutlim = (uint) (((uint32)~0L) % (uint32) base);
   overflow = 0;
   i = 0;
-
+  
   for (c = *s; s != e; c = *++s)
   {
     if (c>='0' && c<='9')
@@ -480,9 +493,9 @@ ulong my_strntoul_8bit(CHARSET_INFO *cs,
     err[0]= ERANGE;
     return (~(uint32) 0);
   }
-
+  
   return (negative ? -((long) i) : (long) i);
-
+  
 noconv:
   err[0]= EDOM;
   if (endptr != NULL)
@@ -490,9 +503,10 @@ ulong my_strntoul_8bit(CHARSET_INFO *cs,
   return 0L;
 }
 
+
 longlong my_strntoll_8bit(CHARSET_INFO *cs __attribute__((unused)),
-              const char *nptr, size_t l, int base,
-              char **endptr,int *err)
+			  const char *nptr, size_t l, int base,
+			  char **endptr,int *err)
 {
   int negative;
   register ulonglong cutoff;
@@ -585,9 +599,10 @@ longlong my_strntoll_8bit(CHARSET_INFO *cs __attribute__((unused)),
   return 0L;
 }
 
+
 ulonglong my_strntoull_8bit(CHARSET_INFO *cs,
-               const char *nptr, size_t l, int base,
-               char **endptr, int *err)
+			   const char *nptr, size_t l, int base,
+			   char **endptr, int *err)
 {
   int negative;
   register ulonglong cutoff;
@@ -673,6 +688,7 @@ ulonglong my_strntoull_8bit(CHARSET_INFO *cs,
   return 0L;
 }
 
+
 /*
   Read double from string
 
@@ -683,7 +699,7 @@ ulonglong my_strntoull_8bit(CHARSET_INFO *cs,
     length	Optional length for string.
     end		result pointer to end of converted string
     err		Error number if failed conversion
-
+    
   NOTES:
     If length is not INT_MAX32 or str[length] != 0 then the given str must
     be writeable
@@ -695,9 +711,10 @@ ulonglong my_strntoull_8bit(CHARSET_INFO *cs,
     Value of number in string
 */
 
+
 double my_strntod_8bit(CHARSET_INFO *cs __attribute__((unused)),
-               char *str, size_t length,
-               char **end, int *err)
+		       char *str, size_t length,
+		       char **end, int *err)
 {
   if (length == INT_MAX32)
     length= 65535;                          /* Should be big enough */
@@ -705,6 +722,7 @@ double my_strntod_8bit(CHARSET_INFO *cs __attribute__((unused)),
   return my_strtod(str, end, err);
 }
 
+
 /*
   This is a fast version optimized for the case of radix 10 / -10
 
@@ -722,7 +740,7 @@ size_t my_long10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
 
   e = p = &buffer[sizeof(buffer)-1];
   *p= 0;
-
+  
   if (radix < 0)
   {
     if (val < 0)
@@ -734,23 +752,24 @@ size_t my_long10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
       sign= 1;
     }
   }
-
+  
   new_val = (long) (uval / 10);
   *--p    = '0'+ (char) (uval - (unsigned long) new_val * 10);
   val     = new_val;
-
+  
   while (val != 0)
   {
     new_val=val/10;
     *--p = '0' + (char) (val-new_val*10);
     val= new_val;
   }
-
+  
   len= min(len, (size_t) (e-p));
   memcpy(dst, p, len);
   return len+sign;
 }
 
+
 size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
                                  char *dst, size_t len, int radix,
                                  longlong val)
@@ -760,7 +779,7 @@ size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
   long long_val;
   uint sign= 0;
   ulonglong uval = (ulonglong)val;
-
+  
   if (radix < 0)
   {
     if (val < 0)
@@ -772,17 +791,17 @@ size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
       sign= 1;
     }
   }
-
+  
   e = p = &buffer[sizeof(buffer)-1];
   *p= 0;
-
+  
   if (uval == 0)
   {
     *--p= '0';
     len= 1;
     goto cnv;
   }
-
+  
   while (uval > (ulonglong) LONG_MAX)
   {
     ulonglong quo= uval/(uint) 10;
@@ -790,7 +809,7 @@ size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
     *--p = '0' + rem;
     uval= quo;
   }
-
+  
   long_val= (long) uval;
   while (long_val != 0)
   {
@@ -798,13 +817,14 @@ size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
     *--p = (char) ('0' + (long_val - quo*10));
     long_val= quo;
   }
-
+  
   len= min(len, (size_t) (e-p));
 cnv:
   memcpy(dst, p, len);
   return len+sign;
 }
 
+
 /*
 ** Compare string against string with wildcard
 **	0 if matched
@@ -820,10 +840,11 @@ size_t my_longlong10_to_str_8bit(CHARSET_INFO *cs __attribute__((unused)),
 
 #define INC_PTR(cs,A,B) (A)++
 
+
 int my_wildcmp_8bit(CHARSET_INFO *cs,
-            const char *str,const char *str_end,
-            const char *wildstr,const char *wildend,
-            int escape, int w_one, int w_many)
+		    const char *str,const char *str_end,
+		    const char *wildstr,const char *wildend,
+		    int escape, int w_one, int w_many)
 {
   int result= -1;			/* Not found, using wildcards */
 
@@ -832,65 +853,65 @@ int my_wildcmp_8bit(CHARSET_INFO *cs,
     while (*wildstr != w_many && *wildstr != w_one)
     {
       if (*wildstr == escape && wildstr+1 != wildend)
-    wildstr++;
+	wildstr++;
 
       if (str == str_end || likeconv(cs,*wildstr++) != likeconv(cs,*str++))
-    return(1);				/* No match */
+	return(1);				/* No match */
       if (wildstr == wildend)
-    return(str != str_end);		/* Match if both are at end */
+	return(str != str_end);		/* Match if both are at end */
       result=1;					/* Found an anchor char     */
     }
     if (*wildstr == w_one)
     {
       do
       {
-    if (str == str_end)			/* Skip one char if possible */
-      return(result);
-    INC_PTR(cs,str,str_end);
+	if (str == str_end)			/* Skip one char if possible */
+	  return(result);
+	INC_PTR(cs,str,str_end);
       } while (++wildstr < wildend && *wildstr == w_one);
       if (wildstr == wildend)
-    break;
+	break;
     }
     if (*wildstr == w_many)
     {						/* Found w_many */
       uchar cmp;
-
+      
       wildstr++;
       /* Remove any '%' and '_' from the wild search string */
       for (; wildstr != wildend ; wildstr++)
       {
-    if (*wildstr == w_many)
-      continue;
-    if (*wildstr == w_one)
-    {
-      if (str == str_end)
-        return(-1);
-      INC_PTR(cs,str,str_end);
-      continue;
-    }
-    break;					/* Not a wild character */
+	if (*wildstr == w_many)
+	  continue;
+	if (*wildstr == w_one)
+	{
+	  if (str == str_end)
+	    return(-1);
+	  INC_PTR(cs,str,str_end);
+	  continue;
+	}
+	break;					/* Not a wild character */
       }
       if (wildstr == wildend)
-    return(0);				/* Ok if w_many is last */
+	return(0);				/* Ok if w_many is last */
       if (str == str_end)
-    return(-1);
-
+	return(-1);
+      
       if ((cmp= *wildstr) == escape && wildstr+1 != wildend)
-    cmp= *++wildstr;
+	cmp= *++wildstr;
 
       INC_PTR(cs,wildstr,wildend);	/* This is compared trough cmp */
       cmp=likeconv(cs,cmp);
       do
       {
-    while (str != str_end && (uchar) likeconv(cs,*str) != cmp)
-      str++;
-    if (str++ == str_end) return(-1);
-    {
-      int tmp=my_wildcmp_8bit(cs,str,str_end,wildstr,wildend,escape,w_one,
-                  w_many);
-      if (tmp <= 0)
-        return(tmp);
-    }
+	while (str != str_end && (uchar) likeconv(cs,*str) != cmp)
+	  str++;
+	if (str++ == str_end) return(-1);
+	{
+	  int tmp=my_wildcmp_8bit(cs,str,str_end,wildstr,wildend,escape,w_one,
+				  w_many);
+	  if (tmp <= 0)
+	    return(tmp);
+	}
       } while (str != str_end && wildstr[0] != w_many);
       return(-1);
     }
@@ -898,6 +919,7 @@ int my_wildcmp_8bit(CHARSET_INFO *cs,
   return(str != str_end ? 1 : 0);
 }
 
+
 /*
 ** Calculate min_str and max_str that ranges a LIKE string.
 ** Arguments:
@@ -916,11 +938,11 @@ int my_wildcmp_8bit(CHARSET_INFO *cs,
 */
 
 my_bool my_like_range_simple(CHARSET_INFO *cs,
-                 const char *ptr, size_t ptr_length,
-                 pbool escape, pbool w_one, pbool w_many,
-                 size_t res_length,
-                 char *min_str,char *max_str,
-                 size_t *min_length, size_t *max_length)
+			     const char *ptr, size_t ptr_length,
+			     pbool escape, pbool w_one, pbool w_many,
+			     size_t res_length,
+			     char *min_str,char *max_str,
+			     size_t *min_length, size_t *max_length)
 {
   const char *end= ptr + ptr_length;
   char *min_org=min_str;
@@ -950,8 +972,8 @@ my_bool my_like_range_simple(CHARSET_INFO *cs,
       *max_length= res_length;
       do
       {
-    *min_str++= 0;
-    *max_str++= (char) cs->max_sort_char;
+	*min_str++= 0;
+	*max_str++= (char) cs->max_sort_char;
       } while (min_str != min_end);
       return 0;
     }
@@ -964,6 +986,7 @@ my_bool my_like_range_simple(CHARSET_INFO *cs,
   return 0;
 }
 
+
 size_t my_scan_8bit(CHARSET_INFO *cs, const char *str, const char *end, int sq)
 {
   const char *str0= str;
@@ -989,24 +1012,28 @@ size_t my_scan_8bit(CHARSET_INFO *cs, const char *str, const char *end, int sq)
   }
 }
 
+
 void my_fill_8bit(CHARSET_INFO *cs __attribute__((unused)),
-           char *s, size_t l, int fill)
+		   char *s, size_t l, int fill)
 {
   bfill((uchar*) s,l,fill);
 }
 
+
 size_t my_numchars_8bit(CHARSET_INFO *cs __attribute__((unused)),
-              const char *b, const char *e)
+		      const char *b, const char *e)
 {
   return (size_t) (e - b);
 }
 
+
 size_t my_numcells_8bit(CHARSET_INFO *cs __attribute__((unused)),
                         const char *b, const char *e)
 {
   return (size_t) (e - b);
 }
 
+
 size_t my_charpos_8bit(CHARSET_INFO *cs __attribute__((unused)),
                        const char *b  __attribute__((unused)),
                        const char *e  __attribute__((unused)),
@@ -1015,6 +1042,7 @@ size_t my_charpos_8bit(CHARSET_INFO *cs __attribute__((unused)),
   return pos;
 }
 
+
 size_t my_well_formed_len_8bit(CHARSET_INFO *cs __attribute__((unused)),
                                const char *start, const char *end,
                                size_t nchars, int *error)
@@ -1024,6 +1052,7 @@ size_t my_well_formed_len_8bit(CHARSET_INFO *cs __attribute__((unused)),
   return min(nbytes, nchars);
 }
 
+
 size_t my_lengthsp_8bit(CHARSET_INFO *cs __attribute__((unused)),
                         const char *ptr, size_t length)
 {
@@ -1032,13 +1061,14 @@ size_t my_lengthsp_8bit(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (end-ptr);
 }
 
+
 uint my_instr_simple(CHARSET_INFO *cs,
-                     const char *b, size_t b_length,
+                     const char *b, size_t b_length, 
                      const char *s, size_t s_length,
                      my_match_t *match, uint nmatch)
 {
   register const uchar *str, *search, *end, *search_end;
-
+  
   if (s_length <= b_length)
   {
     if (!s_length)
@@ -1051,46 +1081,47 @@ uint my_instr_simple(CHARSET_INFO *cs,
       }
       return 1;		/* Empty string is always found */
     }
-
+    
     str= (const uchar*) b;
     search= (const uchar*) s;
     end= (const uchar*) b+b_length-s_length+1;
     search_end= (const uchar*) s + s_length;
-
+    
 skip:
     while (str != end)
     {
       if (cs->sort_order[*str++] == cs->sort_order[*search])
       {
-    register const uchar *i,*j;
-
-    i= str;
-    j= search+1;
-
-    while (j != search_end)
-      if (cs->sort_order[*i++] != cs->sort_order[*j++])
+	register const uchar *i,*j;
+	
+	i= str; 
+	j= search+1;
+	
+	while (j != search_end)
+	  if (cs->sort_order[*i++] != cs->sort_order[*j++]) 
             goto skip;
-
-    if (nmatch > 0)
-    {
-      match[0].beg= 0;
-      match[0].end= (size_t) (str- (const uchar*)b-1);
-      match[0].mb_len= match[0].end;
-
-      if (nmatch > 1)
-      {
-        match[1].beg= match[0].end;
-        match[1].end= match[0].end+s_length;
-        match[1].mb_len= match[1].end-match[1].beg;
-      }
-    }
-    return 2;
+        
+	if (nmatch > 0)
+	{
+	  match[0].beg= 0;
+	  match[0].end= (size_t) (str- (const uchar*)b-1);
+	  match[0].mb_len= match[0].end;
+	  
+	  if (nmatch > 1)
+	  {
+	    match[1].beg= match[0].end;
+	    match[1].end= match[0].end+s_length;
+	    match[1].mb_len= match[1].end-match[1].beg;
+	  }
+	}
+	return 2;
       }
     }
   }
   return 0;
 }
 
+
 typedef struct
 {
   int		nchars;
@@ -1116,7 +1147,7 @@ static my_bool create_fromuni(CHARSET_INFO *cs, void *(*alloc)(size_t))
 {
   uni_idx	idx[PLANE_NUM];
   int		i,n;
-
+  
   /*
     Check that Unicode map is loaded.
     It can be not loaded when the collation is
@@ -1125,16 +1156,16 @@ static my_bool create_fromuni(CHARSET_INFO *cs, void *(*alloc)(size_t))
   */
   if (!cs->tab_to_uni)
     return TRUE;
-
+  
   /* Clear plane statistics */
   bzero(idx,sizeof(idx));
-
+  
   /* Count number of characters in each plane */
   for (i=0; i< 0x100; i++)
   {
     uint16 wc=cs->tab_to_uni[i];
     int pl= PLANE_NUMBER(wc);
-
+    
     if (wc || !i)
     {
       if (!idx[pl].nchars)
@@ -1149,24 +1180,24 @@ static my_bool create_fromuni(CHARSET_INFO *cs, void *(*alloc)(size_t))
       idx[pl].nchars++;
     }
   }
-
+  
   /* Sort planes in descending order */
   qsort(&idx,PLANE_NUM,sizeof(uni_idx),&pcmp);
-
+  
   for (i=0; i < PLANE_NUM; i++)
   {
     int ch,numchars;
-
+    
     /* Skip empty plane */
     if (!idx[i].nchars)
       break;
-
+    
     numchars=idx[i].uidx.to-idx[i].uidx.from+1;
     if (!(idx[i].uidx.tab=(uchar*) alloc(numchars * sizeof(*idx[i].uidx.tab))))
       return TRUE;
-
+    
     bzero(idx[i].uidx.tab,numchars*sizeof(*idx[i].uidx.tab));
-
+    
     for (ch=1; ch < PLANE_SIZE; ch++)
     {
       uint16 wc=cs->tab_to_uni[ch];
@@ -1177,7 +1208,7 @@ static my_bool create_fromuni(CHARSET_INFO *cs, void *(*alloc)(size_t))
       }
     }
   }
-
+  
   /* Allocate and fill reverse table for each plane */
   n=i;
   if (!(cs->tab_from_uni= (MY_UNI_IDX*) alloc(sizeof(MY_UNI_IDX)*(n+1))))
@@ -1185,7 +1216,7 @@ static my_bool create_fromuni(CHARSET_INFO *cs, void *(*alloc)(size_t))
 
   for (i=0; i< n; i++)
     cs->tab_from_uni[i]= idx[i].uidx;
-
+  
   /* Set end-of-list marker */
   bzero(&cs->tab_from_uni[i],sizeof(MY_UNI_IDX));
   return FALSE;
@@ -1203,10 +1234,10 @@ static void set_max_sort_char(CHARSET_INFO *cs)
 {
   uchar max_char;
   uint  i;
-
+  
   if (!cs->sort_order)
     return;
-
+  
   max_char=cs->sort_order[(uchar) cs->max_sort_char];
   for (i= 0; i < 256; i++)
   {
@@ -1225,12 +1256,14 @@ static my_bool my_coll_init_simple(CHARSET_INFO *cs,
   return FALSE;
 }
 
+
 longlong my_strtoll10_8bit(CHARSET_INFO *cs __attribute__((unused)),
                            const char *nptr, char **endptr, int *error)
 {
   return my_strtoll10(nptr, endptr, error);
 }
 
+
 int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
                    const uchar *s, const uchar *e)
 {
@@ -1243,6 +1276,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
   return 1;
 }
 
+
 #define CUTOFF  (ULONGLONG_MAX / 10)
 #define CUTLIM  (ULONGLONG_MAX % 10)
 #define DIGITS_IN_ULONGLONG 20
@@ -1271,11 +1305,12 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
   10000000000000000000ULL
 };
 
+
 /*
 
   Convert a string to unsigned long long integer value
   with rounding.
-
+  
   SYNOPSYS
     my_strntoull10_8bit()
       cs              in      pointer to character set
@@ -1307,7 +1342,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
                         <unsigned integer> [ <period> [ <unsigned integer> ] ]
                       | <period> <unsigned integer>
     <unsigned integer>   ::= <digit>...
-
+     
   RETURN VALUES
     Value of string as a signed/unsigned longlong integer
 
@@ -1322,7 +1357,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
     - 0 if unsigned_flag and the number was negative
     - LONGLONG_MAX if no unsigned_flag and the number is too big
     - LONGLONG_MIN if no unsigned_flag and the number it too big negative
-
+    
     EDOM If the string didn't contain any digits.
     In this case the return value is 0.
 */
@@ -1357,7 +1392,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
   {
     ul= ul * 10 + ch;
   }
-
+  
   if (str >= end) /* Small number without dots and expanents */
   {
     *endptr= (char*) str;
@@ -1380,7 +1415,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
       return (ulonglong) ul;
     }
   }
-
+  
   digits= str - beg;
 
   /* Continue to accumulate into ulonglong */
@@ -1423,7 +1458,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
       }
       goto exp;
     }
-
+    
     if (*str == '.')
     {
       if (dot)
@@ -1438,9 +1473,9 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
       }
       continue;
     }
-
+    
     /* Unknown character, exit the loop */
-    break;
+    break; 
   }
   shift= dot ? dot - str : 0; /* Right shift */
   addon= 0;
@@ -1452,7 +1487,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
     str= beg;
     goto ret_edom;
   }
-
+  
   if (str < end && (*str == 'e' || *str == 'E'))
   {
     str++;
@@ -1473,7 +1508,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
       shift+= negative_exp ? -exponent : exponent;
     }
   }
-
+  
   if (shift == 0) /* No shift, check addon digit */
   {
     if (addon)
@@ -1488,10 +1523,10 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
   if (shift < 0) /* Right shift */
   {
     ulonglong d, r;
-
+    
     if (-shift >= DIGITS_IN_ULONGLONG)
       goto ret_zero; /* Exponent is a big negative number, return 0 */
-
+    
     d= d10[-shift];
     r= (ull % d) * 2;
     ull /= d;
@@ -1558,7 +1593,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
   *endptr= (char*) str;
   *error= MY_ERRNO_EDOM;
   return 0;
-
+  
 ret_too_big:
   *endptr= (char*) str;
   *error= MY_ERRNO_ERANGE;
@@ -1567,6 +1602,7 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
          negative ? (ulonglong) LONGLONG_MIN : (ulonglong) LONGLONG_MAX;
 }
 
+
 /*
   Check if a constant can be propagated
 
@@ -1575,11 +1611,11 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
     cs		Character set information
     str		String to convert to double
     length	Optional length for string.
-
+    
   NOTES:
    Takes the string in the given charset and check
    if it can be safely propagated in the optimizer.
-
+   
    create table t1 (
      s char(5) character set latin1 collate latin1_german2_ci);
    insert into t1 values (0xf6); -- o-umlaut
@@ -1588,14 +1624,14 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
    The above query should return one row.
    We cannot convert this query into:
    select * from t1 where length('oe')=1 and s='oe';
-
+   
    Currently we don't check the constant itself,
    and decide not to propagate a constant
    just if the collation itself allows tricky things
    like expansions and contractions. In the future
    we can write a more sophisticated functions to
    check the constants. For example, 'oa' can always
-   be safety propagated in German2 because unlike
+   be safety propagated in German2 because unlike 
    'oe' it does not have any special meaning.
 
   RETURN
@@ -1603,6 +1639,8 @@ int my_mb_ctype_8bit(CHARSET_INFO *cs, int *ctype,
     0 if it is not safe to propagate the constant
 */
 
+
+
 my_bool my_propagate_simple(CHARSET_INFO *cs __attribute__((unused)),
                             const uchar *str __attribute__((unused)),
                             size_t length __attribute__((unused)))
@@ -1610,6 +1648,7 @@ my_bool my_propagate_simple(CHARSET_INFO *cs __attribute__((unused)),
   return 1;
 }
 
+
 my_bool my_propagate_complex(CHARSET_INFO *cs __attribute__((unused)),
                              const uchar *str __attribute__((unused)),
                              size_t length __attribute__((unused)))
@@ -1617,6 +1656,7 @@ my_bool my_propagate_complex(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
 MY_CHARSET_HANDLER my_charset_8bit_handler=
 {
     my_cset_init_8bit,
@@ -1661,4 +1701,4 @@ my_bool my_propagate_complex(CHARSET_INFO *cs __attribute__((unused)),
     my_instr_simple,
     my_hash_sort_simple,
     my_propagate_simple
-};
\ No newline at end of file
+};
diff --git a/dep/mysqllite/strings/ctype-tis620.c b/dep/mysqllite/strings/ctype-tis620.c
index a07d097..ed9d184 100644
--- a/dep/mysqllite/strings/ctype-tis620.c
+++ b/dep/mysqllite/strings/ctype-tis620.c
@@ -16,11 +16,11 @@
 /*
    Copyright (C) 2003  by Sathit Jittanupat
           <jsat66@hotmail.com,jsat66@yahoo.com>
-    * solving bug crash with long text field string
-    * sorting with different number of space or sign char. within string
+	* solving bug crash with long text field string
+	* sorting with different number of space or sign char. within string
 
    Copyright (C) 2001  by Korakot Chaovavanich <korakot@iname.com> and
-              Apisilp Trunganont <apisilp@pantip.inet.co.th>
+			  Apisilp Trunganont <apisilp@pantip.inet.co.th>
    Copyright (C) 1998, 1999 by Pruet Boonma <pruet@eng.cmu.ac.th>
    Copyright (C) 1998  by Theppitak Karoonboonyanan <thep@links.nectec.or.th>
    Copyright (C) 1989, 1991 by Samphan Raruenrom <samphan@thai.com>
@@ -34,6 +34,7 @@
    "as is" without express or implied warranty.
 */
 
+
 /*
    This file is basicly tis620 character sets with some extra functions
    for tis-620 handling
@@ -61,6 +62,7 @@
 #define UU L_UPRUPR
 #define X  L_MIDDLE
 
+
 static int t_ctype[][TOT_LEVELS] = {
     /*0x00*/ { IGNORE, IGNORE, IGNORE, IGNORE, X },
     /*0x01*/ { IGNORE, IGNORE, IGNORE, IGNORE, X },
@@ -450,6 +452,7 @@
   (uchar) '\370',(uchar) '\371',(uchar) '\372',(uchar) '\373',(uchar) '\374',(uchar) '\375',(uchar) '\376',(uchar) '\377',
 };
 
+
 /*
   Convert thai string to "Standard C String Function" sortable string
 
@@ -474,41 +477,42 @@ static size_t thai2sortable(uchar *tstr, size_t len)
     if (isthai(c))
     {
       int *t_ctype0= t_ctype[c];
-
+		    
       if (isconsnt(c))
-    l2bias	-= 8;
+	l2bias	-= 8;
       if (isldvowel(c) && tlen != 1 && isconsnt(p[1]))
       {
-    /* simply swap between leading-vowel and consonant */
-    *p= p[1];
-    p[1]= c;
-    tlen--;
-    p++;
-    continue;
+	/* simply swap between leading-vowel and consonant */
+	*p= p[1];
+	p[1]= c;
+	tlen--;
+	p++; 
+	continue;
       }
 
       /* if found level 2 char (L2_GARAN,L2_TONE*,L2_TYKHU) move to last */
       if (t_ctype0[1] >= L2_GARAN)
       {
-    /*
-      l2bias use to control position weight of l2char
-      example (*=l2char) XX*X must come before X*XX
-    */
-    memmove((char*) p, (char*) (p+1), tlen-1);
-    tstr[len-1]= l2bias + t_ctype0[1]- L2_GARAN +1;
-    p--;
-    continue;
+	/*
+	  l2bias use to control position weight of l2char
+	  example (*=l2char) XX*X must come before X*XX
+	*/
+	memmove((char*) p, (char*) (p+1), tlen-1);
+	tstr[len-1]= l2bias + t_ctype0[1]- L2_GARAN +1;
+	p--;
+	continue;
       }
     }
     else
     {
       l2bias-= 8;
-      *p= to_lower_tis620[c];
+      *p= to_lower_tis620[c]; 
     }
   }
   return len;
 }
 
+
 /*
   strncoll() replacement, compare 2 string, both are converted to sortable
   string
@@ -523,7 +527,7 @@ static size_t thai2sortable(uchar *tstr, size_t len)
 
 static
 int my_strnncoll_tis620(CHARSET_INFO *cs __attribute__((unused)),
-                        const uchar *s1, size_t len1,
+                        const uchar *s1, size_t len1, 
                         const uchar *s2, size_t len2,
                         my_bool s2_is_prefix)
 {
@@ -550,10 +554,11 @@ int my_strnncoll_tis620(CHARSET_INFO *cs __attribute__((unused)),
   return i;
 }
 
+
 static
 int my_strnncollsp_tis620(CHARSET_INFO * cs __attribute__((unused)),
-              const uchar *a0, size_t a_length,
-              const uchar *b0, size_t b_length,
+			  const uchar *a0, size_t a_length, 
+			  const uchar *b0, size_t b_length,
                           my_bool diff_if_only_endspace_difference)
 {
   uchar	buf[80], *end, *a, *b, *alloced= NULL;
@@ -563,11 +568,11 @@ int my_strnncollsp_tis620(CHARSET_INFO * cs __attribute__((unused)),
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
   diff_if_only_endspace_difference= 0;
 #endif
-
+  
   a= buf;
   if ((a_length + b_length +2) > (int) sizeof(buf))
     alloced= a= (uchar*) my_str_malloc(a_length+b_length+2);
-
+  
   b= a + a_length+1;
   memcpy((char*) a, (char*) a0, a_length);
   a[a_length]= 0;	/* if length(a0)> len1, need to put 'end of string' */
@@ -575,7 +580,7 @@ int my_strnncollsp_tis620(CHARSET_INFO * cs __attribute__((unused)),
   b[b_length]= 0;	/* put end of string */
   a_length= thai2sortable(a, a_length);
   b_length= thai2sortable(b, b_length);
-
+  
   end= a + (length= min(a_length, b_length));
   while (a < end)
   {
@@ -606,19 +611,20 @@ int my_strnncollsp_tis620(CHARSET_INFO * cs __attribute__((unused)),
     {
       if (*a != ' ')
       {
-    res= (*a < ' ') ? -swap : swap;
-    goto ret;
+	res= (*a < ' ') ? -swap : swap;
+	goto ret;
       }
     }
   }
-
+  
 ret:
-
+  
   if (alloced)
     my_str_free(alloced);
   return res;
 }
 
+
 /*
   strnxfrm replacment, convert Thai string to sortable string
 
@@ -640,6 +646,7 @@ size_t my_strnxfrm_tis620(CHARSET_INFO *cs __attribute__((unused)),
   return dstlen;
 }
 
+
 static unsigned short cs_to_uni[256]={
 0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,
 0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,
@@ -811,35 +818,37 @@ size_t my_strnxfrm_tis620(CHARSET_INFO *cs __attribute__((unused)),
 NULL,NULL,NULL,NULL,NULL,NULL,NULL,plFF
 };
 
+
 static
 int my_mb_wc_tis620(CHARSET_INFO *cs  __attribute__((unused)),
-          my_wc_t *wc,
-          const uchar *str,
-          const uchar *end __attribute__((unused)))
+		  my_wc_t *wc,
+		  const uchar *str,
+		  const uchar *end __attribute__((unused)))
 {
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   *wc=cs_to_uni[*str];
   return (!wc[0] && str[0]) ? -1 : 1;
 }
 
 static
 int my_wc_mb_tis620(CHARSET_INFO *cs  __attribute__((unused)),
-          my_wc_t wc,
-          uchar *str,
-          uchar *end __attribute__((unused)))
+		  my_wc_t wc,
+		  uchar *str,
+		  uchar *end __attribute__((unused)))
 {
   uchar *pl;
-
+  
   if (str >= end)
     return MY_CS_TOOSMALL;
-
+  
   pl= uni_to_cs[(wc>>8) & 0xFF];
   str[0]= pl ? pl[wc & 0xFF] : '\0';
   return (!str[0] && wc) ? MY_CS_ILUNI : 1;
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
     NULL,		/* init */
@@ -886,6 +895,8 @@ int my_wc_mb_tis620(CHARSET_INFO *cs  __attribute__((unused)),
     my_scan_8bit
 };
 
+
+
 CHARSET_INFO my_charset_tis620_thai_ci=
 {
     18,0,0,		/* number    */
@@ -950,4 +961,5 @@ int my_wc_mb_tis620(CHARSET_INFO *cs  __attribute__((unused)),
     &my_collation_8bit_bin_handler
 };
 
-#endif
\ No newline at end of file
+
+#endif
diff --git a/dep/mysqllite/strings/ctype-uca.c b/dep/mysqllite/strings/ctype-uca.c
index 02f9f50..a52f9e3 100644
--- a/dep/mysqllite/strings/ctype-uca.c
+++ b/dep/mysqllite/strings/ctype-uca.c
@@ -1,29 +1,29 @@
-/* Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.
-
+/* Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
    MA 02110-1301, USA */
 
-/*
-   UCA (Unicode Collation Algorithm) support.
+/* 
+   UCA (Unicode Collation Algorithm) support. 
    Written by Alexander Barkov <bar@mysql.com>
-
+   
    Currently supports only subset of the full UCA:
    - Only Primary level key comparison
    - Basic Latin letters contraction is implemented
    - Variable weighting is done for Non-ignorable option
-
+   
    Features that are not implemented yet:
    - No Normalization From D is done
      + No decomposition is done
@@ -31,6 +31,7 @@
    - No combining marks processing is done
 */
 
+
 #include <my_global.h>
 #include "m_string.h"
 #include "m_ctype.h"
@@ -41,6 +42,7 @@
 #define MY_UCA_NCHARS 256
 #define MY_UCA_CMASK  255
 #define MY_UCA_PSHIFT 8
+#define MAX_UCA_CHAR_WITH_EXPLICIT_WEIGHT 0xFFFF
 
 uint16 page000data[]= { /* 0000 (4 weights per char) */
 0x0000,0x0000,0x0000,0x0000, 0x0000,0x0000,0x0000,0x0000,
@@ -6565,6 +6567,7 @@
     "& S < \\u0161 <<< \\u0160 "
     "& Z < \\u017E <<< \\u017D ";
 
+
 static const char romanian[]=
     "& A < \\u0103 <<< \\u0102 < \\u00E2 <<< \\u00C2 "
     "& I < \\u00EE <<< \\u00CE "
@@ -6575,6 +6578,7 @@
     "& C < \\u010D <<< \\u010C "
     "& S < \\u0161 <<< \\u0160 "
     "& Z < \\u017E <<< \\u017D ";
+    
 
 static const char polish[]=
     "& A < \\u0105 <<< \\u0104 "
@@ -6601,7 +6605,7 @@
   Some sources treat V and W as similar on primary level.
   We'll treat V and W as different on primary level.
 */
-
+    
 static const char swedish[]=
     "& Y <<\\u00FC <<< \\u00DC "
     "& Z < \\u00E5 <<< \\u00C5 "
@@ -6615,6 +6619,7 @@
     "& O < \\u00F6 <<< \\u00D6 "
     "& S < \\u015F <<< \\u015E "
     "& U < \\u00FC <<< \\u00DC ";
+    
 
 static const char czech[]=
     "& C < \\u010D <<< \\u010C "
@@ -6654,17 +6659,17 @@
     "& V << u <<< U ";
 
 /*
-  Persian collation support was provided by
+  Persian collation support was provided by 
   Jody McIntyre <mysql@modernduck.com>
-
+  
   To: internals@lists.mysql.com
   Subject: Persian UTF8 collation support
   Date: 17.08.2004
-
+  
   Contraction is not implemented.  Some implementations do perform
   contraction but others do not, and it is able to sort all my test
   strings correctly.
-
+  
   Jody.
 */
 static const char persian[]=
@@ -6736,9 +6741,10 @@
               "< \\u0DDB < \\u0DDC < \\u0DDD < \\u0DDE < \\u0DCA";
 #endif
 
+
 /*
   Unicode Collation Algorithm:
-  Collation element (weight) scanner,
+  Collation element (weight) scanner, 
   for consequent scan of collations
   weights from a string.
 */
@@ -6760,15 +6766,16 @@
   Charset dependent scanner part, to optimize
   some character sets.
 */
-typedef struct my_uca_scanner_handler_st
+typedef struct my_uca_scanner_handler_st 
 {
-  void (*init)(my_uca_scanner *scanner, CHARSET_INFO *cs,
+  void (*init)(my_uca_scanner *scanner, CHARSET_INFO *cs, 
                const uchar *str, size_t length);
   int (*next)(my_uca_scanner *scanner);
 } my_uca_scanner_handler;
 
 static uint16 nochar[]= {0,0};
 
+
 #ifdef HAVE_CHARSET_ucs2
 /*
   Initialize collation weight scanner
@@ -6779,7 +6786,7 @@
     cs		Character set + collation information
     str		Beginning of the string
     length	Length of the string.
-
+    
   NOTES:
     Optimized for UCS2
 
@@ -6791,7 +6798,7 @@ static void my_uca_scanner_init_ucs2(my_uca_scanner *scanner,
                                      CHARSET_INFO *cs __attribute__((unused)),
                                      const uchar *str, size_t length)
 {
-  scanner->wbeg= nochar;
+  scanner->wbeg= nochar; 
   if (length)
   {
     scanner->sbeg= str;
@@ -6806,11 +6813,11 @@ static void my_uca_scanner_init_ucs2(my_uca_scanner *scanner,
     Sometimes this function is called with
     str=NULL and length=0, which should be
     considered as an empty string.
-
+    
     The above initialization is unsafe for such cases,
     because scanner->send is initialized to (NULL-2), which is 0xFFFFFFFE.
     Then we fall into an endless loop in my_uca_scanner_next_ucs2().
-
+      
     Do special initialization for the case when length=0.
     Initialize scanner->sbeg to an address greater than scanner->send.
     Next call of my_uca_scanner_next_ucs2() will correctly return with -1.
@@ -6819,26 +6826,27 @@ static void my_uca_scanner_init_ucs2(my_uca_scanner *scanner,
   scanner->send= (uchar*) &nochar[0];
 }
 
+
 /*
   Read next collation element (weight), i.e. converts
   a stream of characters into a stream of their weights.
-
+  
   SYNOPSIS:
     my_uca_scanner_next()
     scanner	Address of a previously initialized scanner strucuture
-
+    
   NOTES:
     Optimized for UCS2
-
+    
     Checks if the current character's weight string has been fully scanned,
     if no, then returns the next weight for this character,
     else scans the next character and returns its first weight.
 
     Each character can have number weights from 0 to 8.
-
-    Some characters do not have weights at all, 0 weights.
+    
+    Some characters do not have weights at all, 0 weights. 
     It means they are ignored during comparison.
-
+    
     Examples:
     1. 0x0001 START OF HEADING, has no weights, ignored, does
        not produce any weights.
@@ -6848,13 +6856,13 @@ static void my_uca_scanner_init_ucs2(my_uca_scanner *scanner,
        has two weights. It will return 0x0FEA twice for two
        consequent calls.
     4. 0x247D PATENTHESIZED NUMBER TEN, has four weights,
-       this function will return these numbers in four
+       this function will return these numbers in four 
        consequent calls: 0x0288, 0x0E2A, 0x0E29, 0x0289
     5. A string consisting of the above characters:
        0x0001 0x0061 0x00DF 0x247D
        will return the following weights, one weight per call:
        0x0E33 0x0FEA 0x0FEA 0x0288, 0x0E2A, 0x0E29, 0x0289
-
+    
   RETURN
     Next weight, a number between 0x0000 and 0xFFFF
     Or -1 on error (END-OF-STRING or ILLEGAL MULTIBYTE SEQUENCE)
@@ -6862,31 +6870,32 @@ static void my_uca_scanner_init_ucs2(my_uca_scanner *scanner,
 
 static int my_uca_scanner_next_ucs2(my_uca_scanner *scanner)
 {
-  /*
+  
+  /* 
     Check if the weights for the previous character have been
-    already fully scanned. If yes, then get the next character and
+    already fully scanned. If yes, then get the next character and 
     initialize wbeg and wlength to its weight string.
   */
-
+  
   if (scanner->wbeg[0])
     return *scanner->wbeg++;
-
-  do
+  
+  do 
   {
     uint16 **ucaw= scanner->uca_weight;
     uchar *ucal= scanner->uca_length;
-
+    
     if (scanner->sbeg > scanner->send)
       return -1;
-
+    
     scanner->page= (uchar)scanner->sbeg[0];
     scanner->code= (uchar)scanner->sbeg[1];
     scanner->sbeg+= 2;
-
+    
     if (scanner->contractions && (scanner->sbeg <= scanner->send))
     {
       int cweight;
-
+      
       if (!scanner->page && !scanner->sbeg[0] &&
           (scanner->sbeg[1] > 0x40) && (scanner->sbeg[1] < 0x80) &&
           (scanner->code > 0x40) && (scanner->code < 0x80) &&
@@ -6898,30 +6907,30 @@ static int my_uca_scanner_next_ucs2(my_uca_scanner *scanner)
           return cweight;
         }
     }
-
+    
     if (!ucaw[scanner->page])
       goto implicit;
     scanner->wbeg= ucaw[scanner->page] + scanner->code * ucal[scanner->page];
   } while (!scanner->wbeg[0]);
-
+  
   return *scanner->wbeg++;
-
+  
 implicit:
-
+  
   scanner->code= (scanner->page << 8) + scanner->code;
   scanner->implicit[0]= (scanner->code & 0x7FFF) | 0x8000;
   scanner->implicit[1]= 0;
   scanner->wbeg= scanner->implicit;
-
+  
   scanner->page= scanner->page >> 7;
-
+  
   if (scanner->code >= 0x3400 && scanner->code <= 0x4DB5)
     scanner->page+= 0xFB80;
   else if (scanner->code >= 0x4E00 && scanner->code <= 0x9FA5)
     scanner->page+= 0xFB40;
   else
     scanner->page+= 0xFBC0;
-
+  
   return scanner->page;
 }
 
@@ -6933,17 +6942,18 @@ static int my_uca_scanner_next_ucs2(my_uca_scanner *scanner)
 
 #endif
 
+
 /*
   The same two functions for any character set
 */
 static void my_uca_scanner_init_any(my_uca_scanner *scanner,
-                    CHARSET_INFO *cs __attribute__((unused)),
-                    const uchar *str, size_t length)
+				    CHARSET_INFO *cs __attribute__((unused)),
+				    const uchar *str, size_t length)
 {
   /* Note, no needs to initialize scanner->wbeg */
   scanner->sbeg= str;
   scanner->send= str + length;
-  scanner->wbeg= nochar;
+  scanner->wbeg= nochar; 
   scanner->uca_length= cs->sort_order;
   scanner->uca_weight= cs->sort_order_big;
   scanner->contractions= cs->contractions;
@@ -6952,29 +6962,30 @@ static void my_uca_scanner_init_any(my_uca_scanner *scanner,
 
 static int my_uca_scanner_next_any(my_uca_scanner *scanner)
 {
-  /*
+  
+  /* 
     Check if the weights for the previous character have been
-    already fully scanned. If yes, then get the next character and
+    already fully scanned. If yes, then get the next character and 
     initialize wbeg and wlength to its weight string.
   */
-
+  
   if (scanner->wbeg[0])
     return *scanner->wbeg++;
-
-  do
+  
+  do 
   {
     uint16 **ucaw= scanner->uca_weight;
     uchar *ucal= scanner->uca_length;
     my_wc_t wc;
     int mb_len;
-
-    if (((mb_len= scanner->cs->cset->mb_wc(scanner->cs, &wc,
+    
+    if (((mb_len= scanner->cs->cset->mb_wc(scanner->cs, &wc, 
                                           scanner->sbeg,
                                           scanner->send)) <= 0))
       return -1;
-
+    
     scanner->sbeg+= mb_len;
-    if (wc > 0xFFFF)
+    if (wc > MAX_UCA_CHAR_WITH_EXPLICIT_WEIGHT)
     {
       /* Return 0xFFFD as weight for all characters outside BMP */
       scanner->wbeg= nochar;
@@ -6985,18 +6996,18 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
       scanner->page= wc >> 8;
       scanner->code= wc & 0xFF;
     }
-
+    
     if (scanner->contractions && !scanner->page &&
         (scanner->code > 0x40) && (scanner->code < 0x80))
     {
       uint page1, code1, cweight;
-
+      
       if (((mb_len= scanner->cs->cset->mb_wc(scanner->cs, &wc,
-                                            scanner->sbeg,
+                                            scanner->sbeg, 
                                             scanner->send)) >=0) &&
            (!(page1= (wc >> 8))) &&
            ((code1= (wc & 0xFF)) > 0x40) &&
-           (code1 < 0x80) &&
+           (code1 < 0x80) && 
            (cweight= scanner->contractions[(scanner->code-0x40)*0x40 + code1-0x40]))
       {
         scanner->implicit[0]= 0;
@@ -7005,33 +7016,34 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
         return cweight;
       }
     }
-
+    
     if (!ucaw[scanner->page])
       goto implicit;
     scanner->wbeg= ucaw[scanner->page] + scanner->code * ucal[scanner->page];
   } while (!scanner->wbeg[0]);
-
+  
   return *scanner->wbeg++;
-
+  
 implicit:
-
+  
   scanner->code= (scanner->page << 8) + scanner->code;
   scanner->implicit[0]= (scanner->code & 0x7FFF) | 0x8000;
   scanner->implicit[1]= 0;
   scanner->wbeg= scanner->implicit;
-
+  
   scanner->page= scanner->page >> 7;
-
+  
   if (scanner->code >= 0x3400 && scanner->code <= 0x4DB5)
     scanner->page+= 0xFB80;
   else if (scanner->code >= 0x4E00 && scanner->code <= 0x9FA5)
     scanner->page+= 0xFB40;
   else
     scanner->page+= 0xFBC0;
-
+  
   return scanner->page;
 }
 
+
 static my_uca_scanner_handler my_any_uca_scanner_handler=
 {
   my_uca_scanner_init_any,
@@ -7048,12 +7060,12 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
     slen	First string length
     t		Second string
     tlen	Seconf string length
-
+  
   NOTES:
     Initializes two weight scanners and gets weights
     corresponding to two strings in a loop. If weights are not
     the same at some step then returns their difference.
-
+    
     In the while() comparison these situations are possible:
     1. (s_res>0) and (t_res>0) and (s_res == t_res)
        Weights are the same so far, continue comparison
@@ -7063,7 +7075,7 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
        We have reached the end of the second string, or found
        an illegal multibyte sequence in the second string.
        Return a positive number, i.e. the first string is bigger.
-    4. (s_res<0) and (t_res>0)
+    4. (s_res<0) and (t_res>0)   
        We have reached the end of the first string, or found
        an illegal multibyte sequence in the first string.
        Return a negative number, i.e. the second string is bigger.
@@ -7071,7 +7083,7 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
        Both scanners returned -1. It means we have riched
        the end-of-string of illegal-sequence in both strings
        at the same time. Return 0, strings are equal.
-
+    
   RETURN
     Difference between two strings, according to the collation:
     0               - means strings are equal
@@ -7079,9 +7091,9 @@ static int my_uca_scanner_next_any(my_uca_scanner *scanner)
     positive number - means the first string is bigger
 */
 
-static int my_strnncoll_uca(CHARSET_INFO *cs,
+static int my_strnncoll_uca(CHARSET_INFO *cs, 
                             my_uca_scanner_handler *scanner_handler,
-                const uchar *s, size_t slen,
+			    const uchar *s, size_t slen,
                             const uchar *t, size_t tlen,
                             my_bool t_is_prefix)
 {
@@ -7089,16 +7101,16 @@ static int my_strnncoll_uca(CHARSET_INFO *cs,
   my_uca_scanner tscanner;
   int s_res;
   int t_res;
-
+  
   scanner_handler->init(&sscanner, cs, s, slen);
   scanner_handler->init(&tscanner, cs, t, tlen);
-
+  
   do
   {
     s_res= scanner_handler->next(&sscanner);
     t_res= scanner_handler->next(&tscanner);
   } while ( s_res == t_res && s_res >0);
-
+  
   return  (t_is_prefix && t_res < 0) ? 0 : (s_res - t_res);
 }
 
@@ -7114,9 +7126,9 @@ static int my_strnncoll_uca(CHARSET_INFO *cs,
     t		Second string
     tlen	Seconf string length
     diff_if_only_endspace_difference
-                Set to 1 if the strings should be regarded as different
+		        Set to 1 if the strings should be regarded as different
                         if they only difference in end space
-
+  
   NOTES:
     Works exactly the same with my_strnncoll_uca(),
     but ignores trailing spaces.
@@ -7132,7 +7144,7 @@ static int my_strnncoll_uca(CHARSET_INFO *cs,
        Compare the first string to an infinite array of
        space characters until difference is found, or until
        the end of the first string.
-    4. (s_res<0) and (t_res>0)
+    4. (s_res<0) and (t_res>0)   
        We have reached the end of the first string, or found
        an illegal multibyte sequence in the first string.
        Compare the second string to an infinite array of
@@ -7142,7 +7154,7 @@ static int my_strnncoll_uca(CHARSET_INFO *cs,
        Both scanners returned -1. It means we have riched
        the end-of-string of illegal-sequence in both strings
        at the same time. Return 0, strings are equal.
-
+  
   RETURN
     Difference between two strings, according to the collation:
     0               - means strings are equal
@@ -7150,7 +7162,7 @@ static int my_strnncoll_uca(CHARSET_INFO *cs,
     positive number - means the first string is bigger
 */
 
-static int my_strnncollsp_uca(CHARSET_INFO *cs,
+static int my_strnncollsp_uca(CHARSET_INFO *cs, 
                               my_uca_scanner_handler *scanner_handler,
                               const uchar *s, size_t slen,
                               const uchar *t, size_t tlen,
@@ -7158,14 +7170,14 @@ static int my_strnncollsp_uca(CHARSET_INFO *cs,
 {
   my_uca_scanner sscanner, tscanner;
   int s_res, t_res;
-
+  
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
   diff_if_only_endspace_difference= 0;
 #endif
 
   scanner_handler->init(&sscanner, cs, s, slen);
   scanner_handler->init(&tscanner, cs, t, tlen);
-
+  
   do
   {
     s_res= scanner_handler->next(&sscanner);
@@ -7173,10 +7185,10 @@ static int my_strnncollsp_uca(CHARSET_INFO *cs,
   } while ( s_res == t_res && s_res >0);
 
   if (s_res > 0 && t_res < 0)
-  {
+  { 
     /* Calculate weight for SPACE character */
     t_res= cs->sort_order_big[0][0x20 * cs->sort_order[0]];
-
+      
     /* compare the first string to spaces */
     do
     {
@@ -7186,12 +7198,12 @@ static int my_strnncollsp_uca(CHARSET_INFO *cs,
     } while (s_res > 0);
     return diff_if_only_endspace_difference ? 1 : 0;
   }
-
+    
   if (s_res < 0 && t_res > 0)
   {
     /* Calculate weight for SPACE character */
     s_res= cs->sort_order_big[0][0x20 * cs->sort_order[0]];
-
+      
     /* compare the second string to spaces */
     do
     {
@@ -7201,14 +7213,14 @@ static int my_strnncollsp_uca(CHARSET_INFO *cs,
     } while (t_res > 0);
     return diff_if_only_endspace_difference ? -1 : 0;
   }
-
+  
   return ( s_res - t_res );
 }
 
 /*
   Calculates hash value for the given string,
   according to the collation, and ignoring trailing spaces.
-
+  
   SYNOPSIS:
     my_hash_sort_uca()
     cs		Character set information
@@ -7216,29 +7228,29 @@ static int my_strnncollsp_uca(CHARSET_INFO *cs,
     slen	String's length
     n1		First hash parameter
     n2		Second hash parameter
-
+  
   NOTES:
     Scans consequently weights and updates
     hash parameters n1 and n2. In a case insensitive collation,
     upper and lower case of the same letter will return the same
     weight sequence, and thus will produce the same hash values
     in n1 and n2.
-
+  
   RETURN
     N/A
 */
 
 static void my_hash_sort_uca(CHARSET_INFO *cs,
                              my_uca_scanner_handler *scanner_handler,
-                 const uchar *s, size_t slen,
-                 ulong *n1, ulong *n2)
+			     const uchar *s, size_t slen,
+			     ulong *n1, ulong *n2)
 {
   int   s_res;
   my_uca_scanner scanner;
-
+  
   slen= cs->cset->lengthsp(cs, (char*) s, slen);
   scanner_handler->init(&scanner, cs, s, slen);
-
+  
   while ((s_res= scanner_handler->next(&scanner)) >0)
   {
     n1[0]^= (((n1[0] & 63)+n2[0])*(s_res >> 8))+ (n1[0] << 8);
@@ -7248,10 +7260,11 @@ static void my_hash_sort_uca(CHARSET_INFO *cs,
   }
 }
 
+
 /*
   For the given string creates its "binary image", suitable
-  to be used in binary comparison, i.e. in memcmp().
-
+  to be used in binary comparison, i.e. in memcmp(). 
+  
   SYNOPSIS:
     my_strnxfrm_uca()
     cs		Character set information
@@ -7259,7 +7272,7 @@ static void my_hash_sort_uca(CHARSET_INFO *cs,
     dstlen	Space available for the image, in bytes
     src		The source string
     srclen	Length of the source string, in bytes
-
+  
   NOTES:
     In a loop, scans weights from the source string and writes
     them into the binary image. In a case insensitive collation,
@@ -7268,18 +7281,18 @@ static void my_hash_sort_uca(CHARSET_INFO *cs,
     or found an illegal multibyte sequence, the loop stops.
 
     It is impossible to restore the original string using its
-    binary image.
-
+    binary image. 
+    
     Binary images are used for bulk comparison purposes,
     e.g. in ORDER BY, when it is more efficient to create
     a binary image and use it instead of weight scanner
     for the original strings for every comparison.
-
+  
   RETURN
     Number of bytes that have been written into the binary image.
 */
 
-static size_t my_strnxfrm_uca(CHARSET_INFO *cs,
+static size_t my_strnxfrm_uca(CHARSET_INFO *cs, 
                               my_uca_scanner_handler *scanner_handler,
                               uchar *dst, size_t dstlen,
                               const uchar *src, size_t srclen)
@@ -7288,7 +7301,7 @@ static size_t my_strnxfrm_uca(CHARSET_INFO *cs,
   int   s_res;
   my_uca_scanner scanner;
   scanner_handler->init(&scanner, cs, src, srclen);
-
+  
   while (dst < de && (s_res= scanner_handler->next(&scanner)) >0)
   {
     dst[0]= s_res >> 8;
@@ -7304,10 +7317,39 @@ static size_t my_strnxfrm_uca(CHARSET_INFO *cs,
   }
   if (dstlen & 1) /* if odd number then fill the last char */
     *dst= '\0';
-
+  
   return dstlen;
 }
 
+
+
+/**
+  Helper function:
+  Find address of weights of the given character.
+  
+  @param weights  UCA weight array
+  @param lengths  UCA length array
+  @param ch       character Unicode code point
+  
+  @return Weight array
+    @retval  pointer to weight array for the given character,
+             or NULL if this page does not have implicit weights.
+*/
+
+static inline uint16 *
+my_char_weight_addr(CHARSET_INFO *cs, uint wc)
+{
+  uint page, ofst;
+  uchar *ucal= cs->sort_order;
+  uint16 **ucaw= cs->sort_order_big;
+
+  return wc > MAX_UCA_CHAR_WITH_EXPLICIT_WEIGHT ? NULL :
+         (ucaw[page= (wc >> 8)] ?
+          ucaw[page] + (ofst= (wc & 0xFF)) * ucal[page] :
+          NULL);
+}
+
+
 /*
   This function compares if two characters are the same.
   The sign +1 or -1 does not matter. The only
@@ -7318,26 +7360,29 @@ static size_t my_strnxfrm_uca(CHARSET_INFO *cs,
 
 static int my_uca_charcmp(CHARSET_INFO *cs, my_wc_t wc1, my_wc_t wc2)
 {
-  size_t page1= wc1 >> MY_UCA_PSHIFT;
-  size_t page2= wc2 >> MY_UCA_PSHIFT;
-  uchar *ucal= cs->sort_order;
-  uint16 **ucaw= cs->sort_order_big;
-  size_t length1= ucal[page1];
-  size_t length2= ucal[page2];
-  uint16 *weight1= ucaw[page1] + (wc1 & MY_UCA_CMASK) * ucal[page1];
-  uint16 *weight2= ucaw[page2] + (wc2 & MY_UCA_CMASK) * ucal[page2];
-
+  size_t length1, length2;
+  uint16 *weight1= my_char_weight_addr(cs, wc1);
+  uint16 *weight2= my_char_weight_addr(cs, wc2);
+  
   if (!weight1 || !weight2)
     return wc1 != wc2;
 
+  /* Quickly compare first weights */
+  if (weight1[0] != weight2[0])
+    return 1;
+
+  /* Thoroughly compare all weights */
+  length1= cs->sort_order[wc1 >> MY_UCA_PSHIFT];
+  length2= cs->sort_order[wc2 >> MY_UCA_PSHIFT];
+  
   if (length1 > length2)
     return memcmp((const void*)weight1, (const void*)weight2, length2*2) ?
            1: weight1[length2];
-
+  
   if (length1 < length2)
     return memcmp((const void*)weight1, (const void*)weight2, length1*2) ?
            1 : weight2[length1];
-
+  
   return memcmp((const void*)weight1, (const void*)weight2, length1*2);
 }
 
@@ -7350,9 +7395,9 @@ static int my_uca_charcmp(CHARSET_INFO *cs, my_wc_t wc1, my_wc_t wc2)
 
 static
 int my_wildcmp_uca(CHARSET_INFO *cs,
-           const char *str,const char *str_end,
-           const char *wildstr,const char *wildend,
-           int escape, int w_one, int w_many)
+		   const char *str,const char *str_end,
+		   const char *wildstr,const char *wildend,
+		   int escape, int w_one, int w_many)
 {
   int result= -1;			/* Not found, using wildcards */
   my_wc_t s_wc, w_wc;
@@ -7360,15 +7405,15 @@ int my_wildcmp_uca(CHARSET_INFO *cs,
   int (*mb_wc)(struct charset_info_st *, my_wc_t *,
                const uchar *, const uchar *);
   mb_wc= cs->cset->mb_wc;
-
+  
   while (wildstr != wildend)
   {
     while (1)
     {
       my_bool escaped= 0;
       if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
-               (const uchar*)wildend)) <= 0)
-    return 1;
+		       (const uchar*)wildend)) <= 0)
+	return 1;
 
       if (w_wc == (my_wc_t)w_many)
       {
@@ -7380,17 +7425,17 @@ int my_wildcmp_uca(CHARSET_INFO *cs,
       if (w_wc ==  (my_wc_t)escape)
       {
         if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
-            (const uchar*)wildend)) <= 0)
+			(const uchar*)wildend)) <= 0)
           return 1;
         wildstr+= scan;
         escaped= 1;
       }
-
+      
       if ((scan= mb_wc(cs, &s_wc, (const uchar*)str,
-                   (const uchar*)str_end)) <= 0)
+      		       (const uchar*)str_end)) <= 0)
         return 1;
       str+= scan;
-
+      
       if (!escaped && w_wc == (my_wc_t)w_one)
       {
         result= 1;				/* Found an anchor char */
@@ -7401,115 +7446,118 @@ int my_wildcmp_uca(CHARSET_INFO *cs,
           return 1;
       }
       if (wildstr == wildend)
-    return (str != str_end);		/* Match if both are at end */
+	return (str != str_end);		/* Match if both are at end */
     }
-
+    
+    
     if (w_wc == (my_wc_t)w_many)
     {						/* Found w_many */
-
+    
       /* Remove any '%' and '_' from the wild search string */
       for ( ; wildstr != wildend ; )
       {
         if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
-             (const uchar*)wildend)) <= 0)
+			 (const uchar*)wildend)) <= 0)
           return 1;
-
-    if (w_wc == (my_wc_t)w_many)
-    {
-      wildstr+= scan;
-      continue;
-    }
-
-    if (w_wc == (my_wc_t)w_one)
-    {
-      wildstr+= scan;
-      if ((scan= mb_wc(cs, &s_wc, (const uchar*)str,
-               (const uchar*)str_end)) <= 0)
+        
+	if (w_wc == (my_wc_t)w_many)
+	{
+	  wildstr+= scan;
+	  continue;
+	} 
+	
+	if (w_wc == (my_wc_t)w_one)
+	{
+	  wildstr+= scan;
+	  if ((scan= mb_wc(cs, &s_wc, (const uchar*)str,
+			   (const uchar*)str_end)) <= 0)
             return 1;
           str+= scan;
-      continue;
-    }
-    break;					/* Not a wild character */
+	  continue;
+	}
+	break;					/* Not a wild character */
       }
-
+      
       if (wildstr == wildend)
-    return 0;				/* Ok if w_many is last */
-
+	return 0;				/* Ok if w_many is last */
+      
       if (str == str_end)
-    return -1;
-
+	return -1;
+      
       if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
-               (const uchar*)wildend)) <= 0)
+		       (const uchar*)wildend)) <= 0)
         return 1;
-
+      
       if (w_wc ==  (my_wc_t)escape)
       {
         wildstr+= scan;
         if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
-             (const uchar*)wildend)) <= 0)
+			 (const uchar*)wildend)) <= 0)
           return 1;
       }
-
+      
       while (1)
       {
         /* Skip until the first character from wildstr is found */
         while (str != str_end)
         {
           if ((scan= mb_wc(cs, &s_wc, (const uchar*)str,
-               (const uchar*)str_end)) <= 0)
+			   (const uchar*)str_end)) <= 0)
             return 1;
-
+          
           if (!my_uca_charcmp(cs,s_wc,w_wc))
             break;
           str+= scan;
         }
         if (str == str_end)
           return -1;
-
+        
         result= my_wildcmp_uca(cs, str, str_end, wildstr, wildend,
-                       escape, w_one, w_many);
-
+        		       escape, w_one, w_many);
+        
         if (result <= 0)
           return result;
-
+        
         str+= scan;
-      }
+      } 
     }
   }
   return (str != str_end ? 1 : 0);
 }
 
+
 /*
   Collation language is implemented according to
   subset of ICU Collation Customization (tailorings):
   http://oss.software.ibm.com/icu/userguide/Collate_Customization.html
-
+  
   Collation language elements:
   Delimiters:
     space   - skipped
-
+  
   <char> :=  A-Z | a-z | \uXXXX
-
+  
   Shift command:
-    <shift>  := &       - reset at this letter.
-
+    <shift>  := &       - reset at this letter. 
+  
   Diff command:
     <d1> :=  <     - Identifies a primary difference.
     <d2> :=  <<    - Identifies a secondary difference.
     <d3> := <<<    - Idenfifies a tertiary difference.
-
+  
+  
   Collation rules:
     <ruleset> :=  <rule>  { <ruleset> }
-
+    
     <rule> :=   <d1>    <string>
               | <d2>    <string>
               | <d3>    <string>
               | <shift> <char>
-
+    
     <string> := <char> [ <string> ]
 
   An example, Polish collation:
-
+  
     &A < \u0105 <<< \u0104
     &C < \u0107 <<< \u0106
     &E < \u0119 <<< \u0118
@@ -7517,18 +7565,20 @@ int my_wildcmp_uca(CHARSET_INFO *cs,
     &N < \u0144 <<< \u0143
     &O < \u00F3 <<< \u00D3
     &S < \u015B <<< \u015A
-    &Z < \u017A <<< \u017B
+    &Z < \u017A <<< \u017B    
 */
 
+
 typedef enum my_coll_lexem_num_en
 {
   MY_COLL_LEXEM_EOF	= 0,
-  MY_COLL_LEXEM_DIFF	= 1,
+  MY_COLL_LEXEM_DIFF	= 1, 
   MY_COLL_LEXEM_SHIFT	= 4,
   MY_COLL_LEXEM_CHAR	= 5,
   MY_COLL_LEXEM_ERROR	= 6
 } my_coll_lexem_num;
 
+
 typedef struct my_coll_lexem_st
 {
   const char *beg;
@@ -7538,16 +7588,17 @@ int my_wildcmp_uca(CHARSET_INFO *cs,
   int   code;
 } MY_COLL_LEXEM;
 
+
 /*
   Initialize collation rule lexical anilizer
-
+  
   SYNOPSIS
     my_coll_lexem_init
     lexem                Lex analizer to init
     str                  Const string to parse
     str_end               End of the string
   USAGE
-
+  
   RETURN VALUES
     N/A
 */
@@ -7562,9 +7613,10 @@ static void my_coll_lexem_init(MY_COLL_LEXEM *lexem,
   lexem->code= 0;
 }
 
+
 /*
   Print collation customization expression parse error, with context.
-
+  
   SYNOPSIS
     my_coll_lexem_print_error
     lexem                Lex analizer to take context from
@@ -7572,7 +7624,7 @@ static void my_coll_lexem_init(MY_COLL_LEXEM *lexem,
     errsize              errstr size
     txt                  error message
   USAGE
-
+  
   RETURN VALUES
     N/A
 */
@@ -7588,14 +7640,15 @@ static void my_coll_lexem_print_error(MY_COLL_LEXEM *lexem,
   my_snprintf(errstr,errsize-1,"%s at '%s'", txt, tail);
 }
 
+
 /*
   Convert a hex digit into its numeric value
-
+  
   SYNOPSIS
     ch2x
     ch                   hex digit to convert
   USAGE
-
+  
   RETURN VALUES
     an integer value in the range 0..15
     -1 on error
@@ -7605,27 +7658,28 @@ static int ch2x(int ch)
 {
   if (ch >= '0' && ch <= '9')
     return ch - '0';
-
+  
   if (ch >= 'a' && ch <= 'f')
     return 10 + ch - 'a';
-
+  
   if (ch >= 'A' && ch <= 'F')
     return 10 + ch - 'A';
-
+  
   return -1;
 }
 
+
 /*
   Collation language lexical parser:
   Scans the next lexem.
-
+  
   SYNOPSIS
     my_coll_lexem_next
-    lexem                Lex analizer, previously initialized by
+    lexem                Lex analizer, previously initialized by 
                          my_coll_lexem_init.
   USAGE
     Call this function in a loop
-
+    
   RETURN VALUES
     Lexem number: eof, diff, shift, char or error.
 */
@@ -7634,69 +7688,70 @@ static my_coll_lexem_num my_coll_lexem_next(MY_COLL_LEXEM *lexem)
 {
   const char *beg;
   my_coll_lexem_num rc;
-
+  
   for (beg= lexem->beg ; beg < lexem->end ; beg++)
   {
     if (*beg == ' ' || *beg == '\t' || *beg == '\r' || *beg == '\n')
       continue;
-
+    
     if (*beg == '&')
     {
       beg++;
       rc= MY_COLL_LEXEM_SHIFT;
       goto ex;
     }
-
+    
     if (beg[0] == '=')
     {
       beg++;
       rc= MY_COLL_LEXEM_DIFF;
       goto ex;
     }
-
+    
     if (beg[0] == '<')
     {
       for (beg++, lexem->diff= 1;
-           (beg < lexem->end) &&
+           (beg < lexem->end) && 
            (*beg == '<') && (lexem->diff<3);
            beg++, lexem->diff++);
       rc= MY_COLL_LEXEM_DIFF;
       goto ex;
     }
-
+    
     if ((*beg >= 'a' && *beg <= 'z') || (*beg >= 'A' && *beg <= 'Z'))
     {
       lexem->code= *beg++;
       rc= MY_COLL_LEXEM_CHAR;
       goto ex;
     }
-
+    
     if ((*beg == '\\') && (beg+2 < lexem->end) && (beg[1] == 'u'))
     {
       int ch;
-
+      
       beg+= 2;
       lexem->code= 0;
       while ((beg < lexem->end) && ((ch= ch2x(beg[0])) >= 0))
-      {
+      { 
         lexem->code= (lexem->code << 4) + ch;
         beg++;
       }
       rc= MY_COLL_LEXEM_CHAR;
       goto ex;
     }
-
+    
     rc= MY_COLL_LEXEM_ERROR;
     goto ex;
   }
   rc= MY_COLL_LEXEM_EOF;
-
+  
 ex:
   lexem->prev= lexem->beg;
   lexem->beg= beg;
-  return rc;
+  return rc;  
 }
 
+
 /*
   Collation rule item
 */
@@ -7708,17 +7763,18 @@ static my_coll_lexem_num my_coll_lexem_next(MY_COLL_LEXEM *lexem)
   int diff[3];   /* Primary, Secondary and Tertiary difference */
 } MY_COLL_RULE;
 
+
 /*
   Collation language syntax parser.
   Uses lexical parser.
-
+  
   SYNOPSIS
     my_coll_rule_parse
     rule                 Collation rule list to load to.
     str                  A string containin collation language expression.
     str_end              End of the string.
   USAGE
-
+    
   RETURN VALUES
     A positive number means the number of rules loaded.
    -1 means ERROR, e.g. too many items, syntax error, etc.
@@ -7731,15 +7787,15 @@ static int my_coll_rule_parse(MY_COLL_RULE *rule, size_t mitems,
   MY_COLL_LEXEM lexem;
   my_coll_lexem_num lexnum;
   my_coll_lexem_num prevlexnum= MY_COLL_LEXEM_ERROR;
-  MY_COLL_RULE item;
+  MY_COLL_RULE item; 
   int state= 0;
   size_t nitems= 0;
-
+  
   /* Init all variables */
   errstr[0]= '\0';
   bzero(&item, sizeof(item));
   my_coll_lexem_init(&lexem, str, str_end);
-
+  
   while ((lexnum= my_coll_lexem_next(&lexem)))
   {
     if (lexnum == MY_COLL_LEXEM_ERROR)
@@ -7747,7 +7803,7 @@ static int my_coll_rule_parse(MY_COLL_RULE *rule, size_t mitems,
       my_coll_lexem_print_error(&lexem,errstr,errsize-1,"Unknown character");
       return -1;
     }
-
+    
     switch (state) {
     case 0:
       if (lexnum != MY_COLL_LEXEM_SHIFT)
@@ -7758,7 +7814,7 @@ static int my_coll_rule_parse(MY_COLL_RULE *rule, size_t mitems,
       prevlexnum= lexnum;
       state= 2;
       continue;
-
+      
     case 1:
       if (lexnum != MY_COLL_LEXEM_SHIFT && lexnum != MY_COLL_LEXEM_DIFF)
       {
@@ -7768,14 +7824,14 @@ static int my_coll_rule_parse(MY_COLL_RULE *rule, size_t mitems,
       prevlexnum= lexnum;
       state= 2;
       continue;
-
+      
     case 2:
       if (lexnum != MY_COLL_LEXEM_CHAR)
       {
         my_coll_lexem_print_error(&lexem,errstr,errsize-1,"character expected");
         return -1;
       }
-
+      
       if (prevlexnum == MY_COLL_LEXEM_SHIFT)
       {
         item.base= lexem.code;
@@ -7841,14 +7897,14 @@ static int my_coll_rule_parse(MY_COLL_RULE *rule, size_t mitems,
   This function copies an UCS2 collation from
   the default Unicode Collation Algorithm (UCA)
   weights applying tailorings, i.e. a set of
-  alternative weights for some characters.
-
+  alternative weights for some characters. 
+  
   The default UCA weights are stored in uca_weight/uca_length.
   They consist of 256 pages, 256 character each.
-
+  
   If a page is not overwritten by tailoring rules,
   it is copies as is from UCA as is.
-
+  
   If a page contains some overwritten characters, it is
   allocated. Untouched characters are copied from the
   default weights.
@@ -7864,71 +7920,76 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
   uint16     **defweights= uca_weight;
   int rc, i;
   int ncontractions= 0;
-
+  
   if (!cs->tailoring)
     return 1;
-
+  
   /* Parse ICU Collation Customization expression */
   if ((rc= my_coll_rule_parse(rule, MY_MAX_COLL_RULE,
                               cs->tailoring,
                               cs->tailoring + strlen(cs->tailoring),
                               errstr, sizeof(errstr))) < 0)
   {
-    /*
+    /* 
       TODO: add error message reporting.
       printf("Error: %d '%s'\n", rc, errstr);
     */
     return 1;
   }
-
+  
   if (!cs->caseinfo)
     cs->caseinfo= my_unicase_default;
-
+  
   if (!(newweights= (uint16**) (*alloc)(256*sizeof(uint16*))))
     return 1;
   bzero(newweights, 256*sizeof(uint16*));
-
+  
   if (!(newlengths= (uchar*) (*alloc)(256)))
     return 1;
-
+  
   memcpy(newlengths, deflengths, 256);
-
+  
   /*
     Calculate maximum lenghts for the pages
     which will be overwritten.
   */
   for (i=0; i < rc; i++)
   {
+    /* check if the shift or the reset characters are out of range */
+    if (rule[i].curr[0] > MAX_UCA_CHAR_WITH_EXPLICIT_WEIGHT ||
+        rule[i].base > MAX_UCA_CHAR_WITH_EXPLICIT_WEIGHT)
+      return 1;
+
     if (!rule[i].curr[1]) /* If not a contraction */
     {
       uint pageb= (rule[i].base >> 8) & 0xFF;
       uint pagec= (rule[i].curr[0] >> 8) & 0xFF;
-
+    
       if (newlengths[pagec] < deflengths[pageb])
         newlengths[pagec]= deflengths[pageb];
     }
     else
       ncontractions++;
   }
-
+  
   for (i=0; i < rc;  i++)
   {
     uint pageb= (rule[i].base >> 8) & 0xFF;
     uint pagec= (rule[i].curr[0] >> 8) & 0xFF;
     uint chb, chc;
-
+    
     if (rule[i].curr[1]) /* Skip contraction */
       continue;
-
+    
     if (!newweights[pagec])
     {
       /* Alloc new page and copy the default UCA weights */
       uint size= 256*newlengths[pagec]*sizeof(uint16);
-
+      
       if (!(newweights[pagec]= (uint16*) (*alloc)(size)))
         return 1;
       bzero((void*) newweights[pagec], size);
-
+      
       for (chc=0 ; chc < 256; chc++)
       {
         memcpy(newweights[pagec] + chc*newlengths[pagec],
@@ -7936,8 +7997,8 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
                deflengths[pagec]*sizeof(uint16));
       }
     }
-
-    /*
+    
+    /* 
       Aply the alternative rule:
       shift to the base character and primary difference.
     */
@@ -7949,18 +8010,18 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
     /* Apply primary difference */
     newweights[pagec][chc*newlengths[pagec]]+= rule[i].diff[0];
   }
-
+  
   /* Copy non-overwritten pages from the default UCA weights */
   for (i= 0; i < 256 ; i++)
   {
     if (!newweights[i])
       newweights[i]= defweights[i];
   }
-
+  
   cs->sort_order= newlengths;
   cs->sort_order_big= newweights;
   cs->contractions= NULL;
-
+  
   /* Now process contractions */
   if (ncontractions)
   {
@@ -7982,12 +8043,12 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
         uint chb= rule[i].base & 0xFF;
         uint16 *offsb= defweights[pageb] + chb*deflengths[pageb];
         uint offsc;
-
-        if (offsb[1] ||
+        
+        if (offsb[1] || 
             rule[i].curr[0] < 0x40 || rule[i].curr[0] > 0x7f ||
             rule[i].curr[1] < 0x40 || rule[i].curr[1] > 0x7f)
         {
-          /*
+          /* 
            TODO: add error reporting;
            We support only basic latin letters contractions at this point.
            Also, We don't support contractions with weight longer than one.
@@ -7996,7 +8057,7 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
           return 1;
         }
         offsc= (rule[i].curr[0]-0x40)*0x40+(rule[i].curr[1]-0x40);
-
+        
         /* Copy base weight applying primary difference */
         cs->contractions[offsc]= offsb[0] + rule[i].diff[0];
         /* Mark both letters as "is contraction part */
@@ -8008,6 +8069,7 @@ static my_bool create_tailoring(CHARSET_INFO *cs, void *(*alloc)(size_t))
   return 0;
 }
 
+
 /*
   Universal CHARSET_INFO compatible wrappers
   for the above internal functions.
@@ -8038,16 +8100,16 @@ static int my_strnncollsp_any_uca(CHARSET_INFO *cs,
   return my_strnncollsp_uca(cs, &my_any_uca_scanner_handler,
                             s, slen, t, tlen,
                             diff_if_only_endspace_difference);
-}
+}   
 
 static void my_hash_sort_any_uca(CHARSET_INFO *cs,
                                  const uchar *s, size_t slen,
                                  ulong *n1, ulong *n2)
 {
-  my_hash_sort_uca(cs, &my_any_uca_scanner_handler, s, slen, n1, n2);
+  my_hash_sort_uca(cs, &my_any_uca_scanner_handler, s, slen, n1, n2); 
 }
 
-static size_t my_strnxfrm_any_uca(CHARSET_INFO *cs,
+static size_t my_strnxfrm_any_uca(CHARSET_INFO *cs, 
                                   uchar *dst, size_t dstlen,
                                   const uchar *src, size_t srclen)
 {
@@ -8055,6 +8117,7 @@ static size_t my_strnxfrm_any_uca(CHARSET_INFO *cs,
                          dst, dstlen, src, srclen);
 }
 
+
 #ifdef HAVE_CHARSET_ucs2
 /*
   UCS2 optimized CHARSET_INFO compatible wrappers.
@@ -8076,16 +8139,16 @@ static int my_strnncollsp_ucs2_uca(CHARSET_INFO *cs,
   return my_strnncollsp_uca(cs, &my_ucs2_uca_scanner_handler,
                             s, slen, t, tlen,
                             diff_if_only_endspace_difference);
-}
+}   
 
 static void my_hash_sort_ucs2_uca(CHARSET_INFO *cs,
                                   const uchar *s, size_t slen,
                                   ulong *n1, ulong *n2)
 {
-  my_hash_sort_uca(cs, &my_ucs2_uca_scanner_handler, s, slen, n1, n2);
+  my_hash_sort_uca(cs, &my_ucs2_uca_scanner_handler, s, slen, n1, n2); 
 }
 
-static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
+static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs, 
                                    uchar *dst, size_t dstlen,
                                    const uchar *src, size_t srclen)
 {
@@ -8460,6 +8523,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_danish_uca_ci=
 {
     139,0,0,		/* number       */
@@ -8588,6 +8652,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_roman_uca_ci=
 {
     143,0,0,		/* number       */
@@ -8620,6 +8685,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_persian_uca_ci=
 {
     144,0,0,		/* number       */
@@ -8652,6 +8718,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_esperanto_uca_ci=
 {
     145,0,0,		/* number       */
@@ -8684,6 +8751,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_hungarian_uca_ci=
 {
     146,0,0,		/* number       */
@@ -8716,6 +8784,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 CHARSET_INFO my_charset_ucs2_sinhala_uca_ci=
 {
     147,0,0,             /* number       */
@@ -8748,8 +8817,10 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_ucs2_uca_handler
 };
 
+
 #endif
 
+
 #ifdef HAVE_CHARSET_utf8
 MY_COLLATION_HANDLER my_collation_any_uca_handler =
 {
@@ -8766,7 +8837,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     my_propagate_complex
 };
 
-/*
+/* 
   We consider bytes with code more than 127 as a letter.
   This garantees that word boundaries work fine with regular
   expressions. Note, there is no need to mark byte 255  as a
@@ -8826,6 +8897,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_any_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf8_icelandic_uca_ci=
 {
     193,0,0,		/* number       */
@@ -9146,6 +9218,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_any_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf8_danish_uca_ci=
 {
     203,0,0,		/* number       */
@@ -9436,6 +9509,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
 
 #endif /* HAVE_CHARSET_utf8 */
 
+
 #ifdef HAVE_CHARSET_utf8mb4
 
 extern MY_CHARSET_HANDLER my_charset_utf8mb4_handler;
@@ -9474,6 +9548,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_any_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf8mb4_icelandic_uca_ci=
 {
     225,0,0,             /* number       */
@@ -9794,6 +9869,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_any_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf8mb4_danish_uca_ci=
 {
     235,0,0,             /* number       */
@@ -10084,6 +10160,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
 
 #endif /* HAVE_CHARSET_utf8mb4 */
 
+
 #ifdef HAVE_CHARSET_utf32
 
 MY_COLLATION_HANDLER my_collation_utf32_uca_handler =
@@ -10137,6 +10214,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_utf32_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf32_icelandic_uca_ci=
 {
     161,0,0,             /* number       */
@@ -10457,6 +10535,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_utf32_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf32_danish_uca_ci=
 {
     171,0,0,             /* number       */
@@ -10747,8 +10826,10 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
 
 #endif /* HAVE_CHARSET_utf32 */
 
+
 #ifdef HAVE_CHARSET_utf16
 
+
 MY_COLLATION_HANDLER my_collation_utf16_uca_handler =
 {
     my_coll_init_uca,        /* init */
@@ -10800,6 +10881,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_utf16_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf16_icelandic_uca_ci=
 {
     102,0,0,             /* number       */
@@ -11120,6 +11202,7 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
     &my_collation_utf16_uca_handler
 };
 
+
 CHARSET_INFO my_charset_utf16_danish_uca_ci=
 {
     112,0,0,             /* number       */
@@ -11410,4 +11493,6 @@ static size_t my_strnxfrm_ucs2_uca(CHARSET_INFO *cs,
 
 #endif /* HAVE_CHARSET_utf16 */
 
-#endif /* HAVE_UCA_COLLATIONS */
\ No newline at end of file
+
+
+#endif /* HAVE_UCA_COLLATIONS */
diff --git a/dep/mysqllite/strings/ctype-ucs2.c b/dep/mysqllite/strings/ctype-ucs2.c
index 3131f6c..cecd442 100644
--- a/dep/mysqllite/strings/ctype-ucs2.c
+++ b/dep/mysqllite/strings/ctype-ucs2.c
@@ -1,15 +1,15 @@
-/* Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
-
+/* Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
@@ -24,14 +24,17 @@
 #include <errno.h>
 #include <stdarg.h>
 
+
 #if defined(HAVE_CHARSET_utf16) || defined(HAVE_CHARSET_ucs2)
 #define HAVE_CHARSET_mb2
 #endif
 
+
 #if defined(HAVE_CHARSET_mb2) || defined(HAVE_CHARSET_utf32)
 #define HAVE_CHARSET_mb2_or_mb4
 #endif
 
+
 #ifndef EILSEQ
 #define EILSEQ ENOENT
 #endif
@@ -47,6 +50,8 @@
 static unsigned long lfactor[9]=
 { 1L, 10L, 100L, 1000L, 10000L, 100000L, 1000000L, 10000000L, 100000000L };
 
+
+
 #ifdef HAVE_CHARSET_mb2_or_mb4
 static inline int
 my_bincmp(const uchar *s, const uchar *se,
@@ -58,22 +63,25 @@
   return cmp ? cmp : slen - tlen;
 }
 
+
 static size_t
-my_caseup_str_mb2_or_mb4(CHARSET_INFO * cs  __attribute__((unused)),
+my_caseup_str_mb2_or_mb4(CHARSET_INFO * cs  __attribute__((unused)), 
                          char * s __attribute__((unused)))
 {
   DBUG_ASSERT(0);
   return 0;
 }
 
+
 static size_t
-my_casedn_str_mb2_or_mb4(CHARSET_INFO *cs __attribute__((unused)),
+my_casedn_str_mb2_or_mb4(CHARSET_INFO *cs __attribute__((unused)), 
                          char * s __attribute__((unused)))
 {
   DBUG_ASSERT(0);
   return 0;
 }
 
+
 static int
 my_strcasecmp_mb2_or_mb4(CHARSET_INFO *cs __attribute__((unused)),
                          const char *s __attribute__((unused)),
@@ -83,6 +91,7 @@
   return 0;
 }
 
+
 static long
 my_strntol_mb2_or_mb4(CHARSET_INFO *cs,
                       const char *nptr, size_t l, int base,
@@ -98,7 +107,7 @@
   register const uchar *s= (const uchar*) nptr;
   register const uchar *e= (const uchar*) nptr+l;
   const uchar *save;
-
+  
   *err= 0;
   do
   {
@@ -112,17 +121,17 @@
         case '+' : break;
         default  : goto bs;
       }
-    }
+    } 
     else /* No more characters or bad multibyte sequence */
     {
       if (endptr != NULL )
         *endptr= (char*) s;
       err[0]= (cnv==MY_CS_ILSEQ) ? EILSEQ : EDOM;
       return 0;
-    }
+    } 
     s+= cnv;
   } while (1);
-
+  
 bs:
 
   overflow= 0;
@@ -130,7 +139,7 @@
   save= s;
   cutoff= ((uint32)~0L) / (uint32) base;
   cutlim= (uint) (((uint32)~0L) % (uint32) base);
-
+  
   do {
     if ((cnv= cs->cset->mb_wc(cs, &wc, s, e)) > 0)
     {
@@ -159,23 +168,23 @@
         *endptr = (char*) s;
       err[0]= EILSEQ;
       return 0;
-    }
+    } 
     else
     {
       /* No more characters */
       break;
     }
   } while(1);
-
+  
   if (endptr != NULL)
     *endptr = (char *) s;
-
+  
   if (s == save)
   {
     err[0]= EDOM;
     return 0L;
   }
-
+  
   if (negative)
   {
     if (res > (uint32) INT_MIN32)
@@ -183,19 +192,20 @@
   }
   else if (res > INT_MAX32)
     overflow= 1;
-
+  
   if (overflow)
   {
     err[0]= ERANGE;
     return negative ? INT_MIN32 : INT_MAX32;
   }
-
+  
   return (negative ? -((long) res) : (long) res);
 }
 
+
 static ulong
 my_strntoul_mb2_or_mb4(CHARSET_INFO *cs,
-                       const char *nptr, size_t l, int base,
+                       const char *nptr, size_t l, int base, 
                        char **endptr, int *err)
 {
   int      negative= 0;
@@ -208,7 +218,7 @@
   register const uchar *s= (const uchar*) nptr;
   register const uchar *e= (const uchar*) nptr + l;
   const uchar *save;
-
+  
   *err= 0;
   do
   {
@@ -222,17 +232,17 @@
         case '+' : break;
         default  : goto bs;
       }
-    }
+    } 
     else /* No more characters or bad multibyte sequence */
     {
       if (endptr !=NULL )
         *endptr= (char*)s;
       err[0]= (cnv == MY_CS_ILSEQ) ? EILSEQ : EDOM;
       return 0;
-    }
+    } 
     s+= cnv;
   } while (1);
-
+  
 bs:
 
   overflow= 0;
@@ -240,7 +250,7 @@
   save= s;
   cutoff= ((uint32)~0L) / (uint32) base;
   cutlim= (uint) (((uint32)~0L) % (uint32) base);
-
+  
   do
   {
     if ((cnv= cs->cset->mb_wc(cs, &wc, s, e)) > 0)
@@ -270,33 +280,34 @@
         *endptr= (char*)s;
       err[0]= EILSEQ;
       return 0;
-    }
+    } 
     else
     {
       /* No more characters */
       break;
     }
   } while(1);
-
+  
   if (endptr != NULL)
     *endptr= (char *) s;
-
+  
   if (s == save)
   {
     err[0]= EDOM;
     return 0L;
   }
-
+  
   if (overflow)
   {
     err[0]= (ERANGE);
     return (~(uint32) 0);
   }
-
+  
   return (negative ? -((long) res) : (long) res);
 }
 
-static longlong
+
+static longlong 
 my_strntoll_mb2_or_mb4(CHARSET_INFO *cs,
                        const char *nptr, size_t l, int base,
                        char **endptr, int *err)
@@ -311,7 +322,7 @@
   register const uchar *s= (const uchar*) nptr;
   register const uchar *e= (const uchar*) nptr+l;
   const uchar *save;
-
+  
   *err= 0;
   do
   {
@@ -325,17 +336,17 @@
         case '+' : break;
         default  : goto bs;
       }
-    }
+    } 
     else /* No more characters or bad multibyte sequence */
     {
       if (endptr !=NULL )
         *endptr = (char*)s;
       err[0] = (cnv==MY_CS_ILSEQ) ? EILSEQ : EDOM;
       return 0;
-    }
+    } 
     s+=cnv;
   } while (1);
-
+  
 bs:
 
   overflow = 0;
@@ -372,23 +383,23 @@
         *endptr = (char*)s;
       err[0]=EILSEQ;
       return 0;
-    }
+    } 
     else
     {
       /* No more characters */
       break;
     }
   } while(1);
-
+  
   if (endptr != NULL)
     *endptr = (char *) s;
-
+  
   if (s == save)
   {
     err[0]=EDOM;
     return 0L;
   }
-
+  
   if (negative)
   {
     if (res  > (ulonglong) LONGLONG_MIN)
@@ -396,16 +407,17 @@
   }
   else if (res > (ulonglong) LONGLONG_MAX)
     overflow = 1;
-
+  
   if (overflow)
   {
     err[0]=ERANGE;
     return negative ? LONGLONG_MIN : LONGLONG_MAX;
   }
-
+  
   return (negative ? -((longlong)res) : (longlong)res);
 }
 
+
 static ulonglong
 my_strntoull_mb2_or_mb4(CHARSET_INFO *cs,
                         const char *nptr, size_t l, int base,
@@ -421,7 +433,7 @@
   register const uchar *s= (const uchar*) nptr;
   register const uchar *e= (const uchar*) nptr + l;
   const uchar *save;
-
+  
   *err= 0;
   do
   {
@@ -435,17 +447,17 @@
         case '+' : break;
         default  : goto bs;
       }
-    }
+    } 
     else /* No more characters or bad multibyte sequence */
     {
       if (endptr !=NULL )
         *endptr = (char*)s;
       err[0]= (cnv==MY_CS_ILSEQ) ? EILSEQ : EDOM;
       return 0;
-    }
+    } 
     s+=cnv;
   } while (1);
-
+  
 bs:
 
   overflow = 0;
@@ -483,23 +495,23 @@
         *endptr = (char*)s;
       err[0]= EILSEQ;
       return 0;
-    }
+    } 
     else
     {
       /* No more characters */
       break;
     }
   } while(1);
-
+  
   if (endptr != NULL)
     *endptr = (char *) s;
-
+  
   if (s == save)
   {
     err[0]= EDOM;
     return 0L;
   }
-
+  
   if (overflow)
   {
     err[0]= ERANGE;
@@ -509,9 +521,10 @@
   return (negative ? -((longlong) res) : (longlong) res);
 }
 
+
 static double
 my_strntod_mb2_or_mb4(CHARSET_INFO *cs,
-                      char *nptr, size_t length,
+                      char *nptr, size_t length, 
                       char **endptr, int *err)
 {
   char     buf[256];
@@ -542,6 +555,7 @@
   return res;
 }
 
+
 static ulonglong
 my_strntoull10rnd_mb2_or_mb4(CHARSET_INFO *cs,
                              const char *nptr, size_t length,
@@ -572,6 +586,7 @@
   return res;
 }
 
+
 /*
   This is a fast version optimized for the case of radix 10 / -10
 */
@@ -585,10 +600,10 @@
   long int new_val;
   int  sl= 0;
   unsigned long int uval = (unsigned long int) val;
-
+  
   p= &buffer[sizeof(buffer) - 1];
   *p= '\0';
-
+  
   if (radix < 0)
   {
     if (val < 0)
@@ -598,23 +613,23 @@
       uval  = (unsigned long int)0 - uval;
     }
   }
-
+  
   new_val = (long) (uval / 10);
   *--p    = '0'+ (char) (uval - (unsigned long) new_val * 10);
   val= new_val;
-
+  
   while (val != 0)
   {
     new_val= val / 10;
     *--p= '0' + (char) (val - new_val * 10);
     val= new_val;
   }
-
+  
   if (sl)
   {
     *--p= '-';
   }
-
+  
   for ( db= dst, de= dst + len ; (dst < de) && *p ; p++)
   {
     int cnvres= cs->cset->wc_mb(cs,(my_wc_t)p[0],(uchar*) dst, (uchar*) de);
@@ -626,6 +641,7 @@
   return (int) (dst - db);
 }
 
+
 static size_t
 my_ll10tostr_mb2_or_mb4(CHARSET_INFO *cs,
                         char *dst, size_t len, int radix, longlong val)
@@ -635,7 +651,7 @@
   long long_val;
   int sl= 0;
   ulonglong uval= (ulonglong) val;
-
+  
   if (radix < 0)
   {
     if (val < 0)
@@ -645,16 +661,16 @@
       uval = (ulonglong)0 - uval;
     }
   }
-
+  
   p= &buffer[sizeof(buffer)-1];
   *p='\0';
-
+  
   if (uval == 0)
   {
     *--p= '0';
     goto cnv;
   }
-
+  
   while (uval > (ulonglong) LONG_MAX)
   {
     ulonglong quo= uval/(uint) 10;
@@ -662,7 +678,7 @@
     *--p= '0' + rem;
     uval= quo;
   }
-
+  
   long_val= (long) uval;
   while (long_val != 0)
   {
@@ -670,13 +686,13 @@
     *--p= (char) ('0' + (long_val - quo*10));
     long_val= quo;
   }
-
+  
 cnv:
   if (sl)
   {
     *--p= '-';
   }
-
+  
   for ( db= dst, de= dst + len ; (dst < de) && *p ; p++)
   {
     int cnvres= cs->cset->wc_mb(cs, (my_wc_t) p[0], (uchar*) dst, (uchar*) de);
@@ -690,6 +706,7 @@
 
 #endif /* HAVE_CHARSET_mb2_or_mb4 */
 
+
 #ifdef HAVE_CHARSET_mb2
 static longlong
 my_strtoll10_mb2(CHARSET_INFO *cs __attribute__((unused)),
@@ -859,13 +876,14 @@
   return 0;
 }
 
+
 static size_t
 my_scan_mb2(CHARSET_INFO *cs __attribute__((unused)),
             const char *str, const char *end, int sequence_type)
 {
   const char *str0= str;
   end--; /* for easier loop condition, because of two bytes per character */
-
+  
   switch (sequence_type)
   {
   case MY_SEQ_SPACES:
@@ -880,6 +898,7 @@
   }
 }
 
+
 static void
 my_fill_mb2(CHARSET_INFO *cs __attribute__((unused)),
             char *s, size_t l, int fill)
@@ -888,6 +907,7 @@
   for ( ; l >= 2; s[0]= (fill >> 8), s[1]= (fill & 0xFF), s+= 2, l-= 2);
 }
 
+
 static int
 my_vsnprintf_mb2(char *dst, size_t n, const char* fmt, va_list ap)
 {
@@ -898,21 +918,21 @@
     {
       if (dst == end)                     /* End of buffer */
         break;
-
+      
       *dst++='\0';
       *dst++= *fmt;          /* Copy ordinary char */
       continue;
     }
-
+    
     fmt++;
-
+    
     /* Skip if max size is used (to be compatible with printf) */
     while ( (*fmt >= '0' && *fmt <= '9') || *fmt == '.' || *fmt == '-')
       fmt++;
-
+    
     if (*fmt == 'l')
       fmt++;
-
+    
     if (*fmt == 's')                      /* String parameter */
     {
       char *par= va_arg(ap, char *);
@@ -936,7 +956,7 @@
       int iarg;
       char nbuf[16];
       char *pbuf= nbuf;
-
+      
       if ((size_t) (end - dst) < 32)
         break;
       iarg= va_arg(ap, int);
@@ -952,19 +972,20 @@
       }
       continue;
     }
-
+    
     /* We come here on '%%', unknown code or too long parameter */
     if (dst == end)
       break;
     *dst++= '\0';
     *dst++= '%';                            /* % used as % or unknown code */
   }
-
+  
   DBUG_ASSERT(dst <= end);
   *dst='\0';                                /* End of errmessage */
   return (size_t) (dst - start);
 }
 
+
 static size_t
 my_snprintf_mb2(CHARSET_INFO *cs __attribute__((unused)),
                 char* to, size_t n, const char* fmt, ...)
@@ -974,6 +995,7 @@
   return my_vsnprintf_mb2(to, n, fmt, args);
 }
 
+
 static size_t
 my_lengthsp_mb2(CHARSET_INFO *cs __attribute__((unused)),
                 const char *ptr, size_t length)
@@ -986,6 +1008,9 @@
 
 #endif /* HAVE_CHARSET_mb2*/
 
+
+
+
 #ifdef HAVE_CHARSET_utf16
 
 /*
@@ -1004,7 +1029,7 @@
 {
   if (s + 2 > e)
     return MY_CS_TOOSMALL2;
-
+  
   /*
     High bytes: 0xD[89AB] = B'110110??'
     Low bytes:  0xD[CDEF] = B'110111??'
@@ -1024,7 +1049,7 @@
       s[1]= ????????  (<< 10)
       s[2]= 110111??  (<<  8)
       s[3]= ????????  (<<  0)
-    */
+    */ 
 
     *pwc= ((s[0] & 3) << 18) + (s[1] << 10) +
           ((s[2] & 3) << 8) + s[3] + 0x10000;
@@ -1034,11 +1059,12 @@
 
   if (MY_UTF16_LOW_HEAD(*s)) /* Low surrogate part without high part */
     return MY_CS_ILSEQ;
-
+  
   *pwc= (s[0] << 8) + s[1];
   return 2;
 }
 
+
 static int
 my_uni_utf16(CHARSET_INFO *cs __attribute__((unused)),
              my_wc_t wc, uchar *s, uchar *e)
@@ -1068,6 +1094,7 @@
   return MY_CS_ILUNI;
 }
 
+
 static inline void
 my_tolower_utf16(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1076,6 +1103,7 @@
     *wc= uni_plane[page][*wc & 0xFF].tolower;
 }
 
+
 static inline void
 my_toupper_utf16(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1084,6 +1112,7 @@
     *wc= uni_plane[page][*wc & 0xFF].toupper;
 }
 
+
 static inline void
 my_tosort_utf16(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1099,6 +1128,7 @@
   }
 }
 
+
 static size_t
 my_caseup_utf16(CHARSET_INFO *cs, char *src, size_t srclen,
                 char *dst __attribute__((unused)),
@@ -1109,7 +1139,7 @@
   char *srcend= src + srclen;
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   DBUG_ASSERT(src == dst && srclen == dstlen);
-
+  
   while ((src < srcend) &&
          (res= my_utf16_uni(cs, &wc, (uchar *)src, (uchar*) srcend)) > 0)
   {
@@ -1121,6 +1151,7 @@
   return srclen;
 }
 
+
 static void
 my_hash_sort_utf16(CHARSET_INFO *cs, const uchar *s, size_t slen,
                    ulong *n1, ulong *n2)
@@ -1144,6 +1175,7 @@
   }
 }
 
+
 static size_t
 my_casedn_utf16(CHARSET_INFO *cs, char *src, size_t srclen,
                 char *dst __attribute__((unused)),
@@ -1166,9 +1198,10 @@
   return srclen;
 }
 
+
 static int
-my_strnncoll_utf16(CHARSET_INFO *cs,
-                   const uchar *s, size_t slen,
+my_strnncoll_utf16(CHARSET_INFO *cs, 
+                   const uchar *s, size_t slen, 
                    const uchar *t, size_t tlen,
                    my_bool t_is_prefix)
 {
@@ -1203,6 +1236,7 @@
   return (int) (t_is_prefix ? (t - te) : ((se - s) - (te - t)));
 }
 
+
 /**
   Compare strings, discarding end space
 
@@ -1260,7 +1294,7 @@
 
     my_tosort_utf16(uni_plane, &s_wc);
     my_tosort_utf16(uni_plane, &t_wc);
-
+    
     if (s_wc != t_wc)
     {
       return s_wc > t_wc ? 1 : -1;
@@ -1302,6 +1336,7 @@
   return res;
 }
 
+
 static uint
 my_ismbchar_utf16(CHARSET_INFO *cs __attribute__((unused)),
                   const char *b __attribute__((unused)),
@@ -1309,18 +1344,19 @@
 {
   if (b + 2 > e)
     return 0;
-
+  
   if (MY_UTF16_HIGH_HEAD(*b))
   {
     return (b + 4 <= e) && MY_UTF16_LOW_HEAD(b[2]) ? 4 : 0;
   }
-
+  
   if (MY_UTF16_LOW_HEAD(*b))
     return 0;
-
+  
   return 2;
 }
 
+
 static uint
 my_mbcharlen_utf16(CHARSET_INFO *cs  __attribute__((unused)),
                    uint c __attribute__((unused)))
@@ -1328,6 +1364,7 @@
   return MY_UTF16_HIGH_HEAD(c) ? 4 : 2;
 }
 
+
 static size_t
 my_numchars_utf16(CHARSET_INFO *cs,
                   const char *b, const char *e)
@@ -1343,13 +1380,14 @@
   return nchars;
 }
 
+
 static size_t
 my_charpos_utf16(CHARSET_INFO *cs,
                  const char *b, const char *e, size_t pos)
 {
   const char *b0= b;
   uint charlen;
-
+  
   for ( ; pos; b+= charlen, pos--)
   {
     if (!(charlen= my_ismbchar(cs, b, e)))
@@ -1358,6 +1396,7 @@
   return (size_t) (pos ? (e + 2 - b0) : (b - b0));
 }
 
+
 static size_t
 my_well_formed_len_utf16(CHARSET_INFO *cs,
                          const char *b, const char *e,
@@ -1366,7 +1405,7 @@
   const char *b0= b;
   uint charlen;
   *error= 0;
-
+  
   for ( ; nchars; b+= charlen, nchars--)
   {
     if (!(charlen= my_ismbchar(cs, b, e)))
@@ -1378,6 +1417,7 @@
   return (size_t) (b - b0);
 }
 
+
 static int
 my_wildcmp_utf16_ci(CHARSET_INFO *cs,
                     const char *str,const char *str_end,
@@ -1386,9 +1426,10 @@
 {
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   return my_wildcmp_unicode(cs, str, str_end, wildstr, wildend,
-                            escape, w_one, w_many, uni_plane);
+                            escape, w_one, w_many, uni_plane); 
 }
 
+
 static int
 my_wildcmp_utf16_bin(CHARSET_INFO *cs,
                      const char *str,const char *str_end,
@@ -1396,11 +1437,12 @@
                      int escape, int w_one, int w_many)
 {
   return my_wildcmp_unicode(cs, str, str_end, wildstr, wildend,
-                            escape, w_one, w_many, NULL);
+                            escape, w_one, w_many, NULL); 
 }
 
+
 static int
-my_strnncoll_utf16_bin(CHARSET_INFO *cs,
+my_strnncoll_utf16_bin(CHARSET_INFO *cs, 
                        const uchar *s, size_t slen,
                        const uchar *t, size_t tlen,
                        my_bool t_is_prefix)
@@ -1431,6 +1473,7 @@
   return (int) (t_is_prefix ? (t - te) : ((se - s) - (te - t)));
 }
 
+
 static int
 my_strnncollsp_utf16_bin(CHARSET_INFO *cs,
                          const uchar *s, size_t slen,
@@ -1500,12 +1543,13 @@
   return res;
 }
 
+
 static void
 my_hash_sort_utf16_bin(CHARSET_INFO *cs __attribute__((unused)),
                        const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
-
+  
   key+= len;
 
   while (key > pos + 1 && key[-1] == ' ' && key[-2] == '\0')
@@ -1513,12 +1557,13 @@
 
   for (; pos < (uchar*) key ; pos++)
   {
-    nr1[0]^= (ulong) ((((uint) nr1[0] & 63) + nr2[0]) *
+    nr1[0]^= (ulong) ((((uint) nr1[0] & 63) + nr2[0]) * 
               ((uint)*pos)) + (nr1[0] << 8);
     nr2[0]+= 3;
   }
 }
 
+
 static MY_COLLATION_HANDLER my_collation_utf16_general_ci_handler =
 {
   NULL,                /* init */
@@ -1534,6 +1579,7 @@
   my_propagate_simple
 };
 
+
 static MY_COLLATION_HANDLER my_collation_utf16_bin_handler =
 {
   NULL,                /* init */
@@ -1549,6 +1595,7 @@
   my_propagate_simple
 };
 
+
 MY_CHARSET_HANDLER my_charset_utf16_handler=
 {
   NULL,                /* init         */
@@ -1580,6 +1627,7 @@
   my_scan_mb2
 };
 
+
 CHARSET_INFO my_charset_utf16_general_ci=
 {
   54,0,0,              /* number       */
@@ -1612,6 +1660,7 @@
   &my_collation_utf16_general_ci_handler
 };
 
+
 CHARSET_INFO my_charset_utf16_bin=
 {
   55,0,0,              /* number       */
@@ -1646,6 +1695,7 @@
 
 #endif /* HAVE_CHARSET_utf16 */
 
+
 #ifdef HAVE_CHARSET_utf32
 
 static int
@@ -1658,13 +1708,14 @@
   return 4;
 }
 
+
 static int
 my_uni_utf32(CHARSET_INFO *cs __attribute__((unused)),
              my_wc_t wc, uchar *s, uchar *e)
 {
-  if (s + 4 > e)
+  if (s + 4 > e) 
     return MY_CS_TOOSMALL4;
-
+  
   s[0]= (uchar) (wc >> 24);
   s[1]= (uchar) (wc >> 16) & 0xFF;
   s[2]= (uchar) (wc >> 8)  & 0xFF;
@@ -1672,6 +1723,7 @@
   return 4;
 }
 
+
 static inline void
 my_tolower_utf32(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1680,6 +1732,7 @@
     *wc= uni_plane[page][*wc & 0xFF].tolower;
 }
 
+
 static inline void
 my_toupper_utf32(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1688,6 +1741,7 @@
     *wc= uni_plane[page][*wc & 0xFF].toupper;
 }
 
+
 static inline void
 my_tosort_utf32(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1703,6 +1757,7 @@
   }
 }
 
+
 static size_t
 my_caseup_utf32(CHARSET_INFO *cs, char *src, size_t srclen,
                 char *dst __attribute__((unused)),
@@ -1713,7 +1768,7 @@
   char *srcend= src + srclen;
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   DBUG_ASSERT(src == dst && srclen == dstlen);
-
+  
   while ((src < srcend) &&
          (res= my_utf32_uni(cs, &wc, (uchar *)src, (uchar*) srcend)) > 0)
   {
@@ -1725,6 +1780,7 @@
   return srclen;
 }
 
+
 static inline void
 my_hash_add(ulong *n1, ulong *n2, uint ch)
 {
@@ -1732,6 +1788,7 @@
   n2[0]+= 3;
 }
 
+
 static void
 my_hash_sort_utf32(CHARSET_INFO *cs, const uchar *s, size_t slen,
                    ulong *n1, ulong *n2)
@@ -1756,6 +1813,7 @@
   }
 }
 
+
 static size_t
 my_casedn_utf32(CHARSET_INFO *cs, char *src, size_t srclen,
                 char *dst __attribute__((unused)),
@@ -1777,9 +1835,10 @@
   return srclen;
 }
 
+
 static int
-my_strnncoll_utf32(CHARSET_INFO *cs,
-                   const uchar *s, size_t slen,
+my_strnncoll_utf32(CHARSET_INFO *cs, 
+                   const uchar *s, size_t slen, 
                    const uchar *t, size_t tlen,
                    my_bool t_is_prefix)
 {
@@ -1792,27 +1851,28 @@
   {
     int s_res= my_utf32_uni(cs, &s_wc, s, se);
     int t_res= my_utf32_uni(cs, &t_wc, t, te);
-
+    
     if ( s_res <= 0 || t_res <= 0)
     {
       /* Incorrect string, compare by char value */
       return my_bincmp(s, se, t, te);
     }
-
+    
     my_tosort_utf32(uni_plane, &s_wc);
     my_tosort_utf32(uni_plane, &t_wc);
-
+    
     if (s_wc != t_wc)
     {
       return s_wc > t_wc ? 1 : -1;
     }
-
+    
     s+= s_res;
     t+= t_res;
   }
   return (int) (t_is_prefix ? (t - te) : ((se - s) - (te - t)));
 }
 
+
 /**
   Compare strings, discarding end space
 
@@ -1839,6 +1899,7 @@
     @retval Positive number, if a > b
 */
 
+
 static int
 my_strnncollsp_utf32(CHARSET_INFO *cs,
                      const uchar *s, size_t slen,
@@ -1870,7 +1931,7 @@
 
     my_tosort_utf32(uni_plane, &s_wc);
     my_tosort_utf32(uni_plane, &t_wc);
-
+    
     if ( s_wc != t_wc )
     {
       return s_wc > t_wc ? 1 : -1;
@@ -1912,12 +1973,14 @@
   return res;
 }
 
+
 static size_t
 my_strnxfrmlen_utf32(CHARSET_INFO *cs __attribute__((unused)), size_t len)
 {
   return len / 2;
 }
 
+
 static uint
 my_ismbchar_utf32(CHARSET_INFO *cs __attribute__((unused)),
                   const char *b __attribute__((unused)),
@@ -1926,13 +1989,15 @@
   return 4;
 }
 
+
 static uint
-my_mbcharlen_utf32(CHARSET_INFO *cs  __attribute__((unused)) ,
+my_mbcharlen_utf32(CHARSET_INFO *cs  __attribute__((unused)) , 
                    uint c __attribute__((unused)))
 {
   return 4;
 }
 
+
 static int
 my_vsnprintf_utf32(char *dst, size_t n, const char* fmt, va_list ap)
 {
@@ -1944,23 +2009,23 @@
     {
       if (dst >= end)                        /* End of buffer */
         break;
-
+      
       *dst++= '\0';
       *dst++= '\0';
       *dst++= '\0';
       *dst++= *fmt;        /* Copy ordinary char */
       continue;
     }
-
+    
     fmt++;
-
+    
     /* Skip if max size is used (to be compatible with printf) */
     while ( (*fmt>='0' && *fmt<='9') || *fmt == '.' || *fmt == '-')
       fmt++;
-
+    
     if (*fmt == 'l')
       fmt++;
-
+    
     if (*fmt == 's')                                /* String parameter */
     {
       reg2 char *par= va_arg(ap, char *);
@@ -1985,7 +2050,7 @@
       register int iarg;
       char nbuf[16];
       char *pbuf= nbuf;
-
+      
       if ((size_t) (end - dst) < 64)
         break;
       iarg= va_arg(ap, int);
@@ -2003,7 +2068,7 @@
       }
       continue;
     }
-
+    
     /* We come here on '%%', unknown code or too long parameter */
     if (dst == end)
       break;
@@ -2012,7 +2077,7 @@
     *dst++= '\0';
     *dst++= '%';    /* % used as % or unknown code */
   }
-
+  
   DBUG_ASSERT(dst < end);
   *dst++= '\0';
   *dst++= '\0';
@@ -2021,6 +2086,7 @@
   return (size_t) (dst - start - 4);
 }
 
+
 static size_t
 my_snprintf_utf32(CHARSET_INFO *cs __attribute__((unused)),
                   char* to, size_t n, const char* fmt, ...)
@@ -2030,6 +2096,7 @@
   return my_vsnprintf_utf32(to, n, fmt, args);
 }
 
+
 static longlong
 my_strtoll10_utf32(CHARSET_INFO *cs __attribute__((unused)),
                    const char *nptr, char **endptr, int *error)
@@ -2199,6 +2266,7 @@
   return 0;
 }
 
+
 static size_t
 my_numchars_utf32(CHARSET_INFO *cs __attribute__((unused)),
                   const char *b, const char *e)
@@ -2206,6 +2274,7 @@
   return (size_t) (e - b) / 4;
 }
 
+
 static size_t
 my_charpos_utf32(CHARSET_INFO *cs __attribute__((unused)),
                  const char *b, const char *e, size_t pos)
@@ -2214,6 +2283,7 @@
   return pos * 4 > string_length ? string_length + 4 : pos * 4;
 }
 
+
 static size_t
 my_well_formed_len_utf32(CHARSET_INFO *cs __attribute__((unused)),
                          const char *b, const char *e,
@@ -2242,6 +2312,7 @@
   return length;
 }
 
+
 static
 void my_fill_utf32(CHARSET_INFO *cs,
                    char *s, size_t slen, int fill)
@@ -2249,7 +2320,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   char buf[10];
   uint buflen;
   char *e= s + slen;
-
+  
   DBUG_ASSERT((slen % 4) == 0);
 
   buflen= cs->cset->wc_mb(cs, (my_wc_t) fill, (uchar*) buf,
@@ -2262,6 +2333,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   }
 }
 
+
 static size_t
 my_lengthsp_utf32(CHARSET_INFO *cs __attribute__((unused)),
                   const char *ptr, size_t length)
@@ -2273,6 +2345,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   return (size_t) (end - ptr);
 }
 
+
 static int
 my_wildcmp_utf32_ci(CHARSET_INFO *cs,
                     const char *str, const char *str_end,
@@ -2281,9 +2354,10 @@ void my_fill_utf32(CHARSET_INFO *cs,
 {
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   return my_wildcmp_unicode(cs, str, str_end, wildstr, wildend,
-                            escape, w_one, w_many, uni_plane);
+                            escape, w_one, w_many, uni_plane); 
 }
 
+
 static int
 my_wildcmp_utf32_bin(CHARSET_INFO *cs,
                      const char *str,const char *str_end,
@@ -2291,11 +2365,12 @@ void my_fill_utf32(CHARSET_INFO *cs,
                      int escape, int w_one, int w_many)
 {
   return my_wildcmp_unicode(cs, str, str_end, wildstr, wildend,
-                            escape, w_one, w_many, NULL);
+                            escape, w_one, w_many, NULL); 
 }
 
+
 static int
-my_strnncoll_utf32_bin(CHARSET_INFO *cs,
+my_strnncoll_utf32_bin(CHARSET_INFO *cs, 
                        const uchar *s, size_t slen,
                        const uchar *t, size_t tlen,
                        my_bool t_is_prefix)
@@ -2308,7 +2383,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   {
     int s_res= my_utf32_uni(cs, &s_wc, s, se);
     int t_res= my_utf32_uni(cs, &t_wc, t, te);
-
+    
     if (s_res <= 0 || t_res <= 0)
     {
       /* Incorrect string, compare by char value */
@@ -2318,13 +2393,14 @@ void my_fill_utf32(CHARSET_INFO *cs,
     {
       return  s_wc > t_wc ? 1 : -1;
     }
-
+    
     s+= s_res;
     t+= t_res;
   }
   return (int) (t_is_prefix ? (t-te) : ((se - s) - (te - t)));
 }
 
+
 static inline my_wc_t
 my_utf32_get(const uchar *s)
 {
@@ -2335,9 +2411,10 @@ void my_fill_utf32(CHARSET_INFO *cs,
     s[3];
 }
 
+
 static int
-my_strnncollsp_utf32_bin(CHARSET_INFO *cs __attribute__((unused)),
-                         const uchar *s, size_t slen,
+my_strnncollsp_utf32_bin(CHARSET_INFO *cs __attribute__((unused)), 
+                         const uchar *s, size_t slen, 
                          const uchar *t, size_t tlen,
                          my_bool diff_if_only_endspace_difference
                          __attribute__((unused)))
@@ -2382,12 +2459,13 @@ void my_fill_utf32(CHARSET_INFO *cs,
   return 0;
 }
 
+
 static size_t
 my_scan_utf32(CHARSET_INFO *cs,
               const char *str, const char *end, int sequence_type)
 {
   const char *str0= str;
-
+  
   switch (sequence_type)
   {
   case MY_SEQ_SPACES:
@@ -2405,6 +2483,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   }
 }
 
+
 static MY_COLLATION_HANDLER my_collation_utf32_general_ci_handler =
 {
   NULL, /* init */
@@ -2420,6 +2499,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   my_propagate_simple
 };
 
+
 static MY_COLLATION_HANDLER my_collation_utf32_bin_handler =
 {
   NULL, /* init */
@@ -2435,6 +2515,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   my_propagate_simple
 };
 
+
 MY_CHARSET_HANDLER my_charset_utf32_handler=
 {
   NULL, /* init */
@@ -2466,6 +2547,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   my_scan_utf32
 };
 
+
 CHARSET_INFO my_charset_utf32_general_ci=
 {
   60,0,0,              /* number       */
@@ -2498,6 +2580,7 @@ void my_fill_utf32(CHARSET_INFO *cs,
   &my_collation_utf32_general_ci_handler
 };
 
+
 CHARSET_INFO my_charset_utf32_bin=
 {
   61,0,0,              /* number       */
@@ -2530,8 +2613,10 @@ void my_fill_utf32(CHARSET_INFO *cs,
   &my_collation_utf32_bin_handler
 };
 
+
 #endif /* HAVE_CHARSET_utf32 */
 
+
 #ifdef HAVE_CHARSET_ucs2
 
 static uchar ctype_ucs2[] = {
@@ -2592,20 +2677,21 @@ void my_fill_utf32(CHARSET_INFO *cs,
   240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
 };
 
+
 static int my_ucs2_uni(CHARSET_INFO *cs __attribute__((unused)),
-               my_wc_t * pwc, const uchar *s, const uchar *e)
+		       my_wc_t * pwc, const uchar *s, const uchar *e)
 {
   if (s+2 > e) /* Need 2 characters */
     return MY_CS_TOOSMALL2;
-
+  
   *pwc= ((uchar)s[0]) * 256  + ((uchar)s[1]);
   return 2;
 }
 
 static int my_uni_ucs2(CHARSET_INFO *cs __attribute__((unused)) ,
-               my_wc_t wc, uchar *r, uchar *e)
+		       my_wc_t wc, uchar *r, uchar *e)
 {
-  if ( r+2 > e )
+  if ( r+2 > e ) 
     return MY_CS_TOOSMALL2;
 
   if (wc > 0xFFFF) /* UCS2 does not support characters outside BMP */
@@ -2616,6 +2702,7 @@ static int my_uni_ucs2(CHARSET_INFO *cs __attribute__((unused)) ,
   return 2;
 }
 
+
 static size_t my_caseup_ucs2(CHARSET_INFO *cs, char *src, size_t srclen,
                            char *dst __attribute__((unused)),
                            size_t dstlen __attribute__((unused)))
@@ -2625,7 +2712,7 @@ static size_t my_caseup_ucs2(CHARSET_INFO *cs, char *src, size_t srclen,
   char *srcend= src + srclen;
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   DBUG_ASSERT(src == dst && srclen == dstlen);
-
+  
   while ((src < srcend) &&
          (res= my_ucs2_uni(cs, &wc, (uchar *)src, (uchar*) srcend)) > 0)
   {
@@ -2638,8 +2725,9 @@ static size_t my_caseup_ucs2(CHARSET_INFO *cs, char *src, size_t srclen,
   return srclen;
 }
 
+
 static void my_hash_sort_ucs2(CHARSET_INFO *cs, const uchar *s, size_t slen,
-                  ulong *n1, ulong *n2)
+			      ulong *n1, ulong *n2)
 {
   my_wc_t wc;
   int res;
@@ -2661,6 +2749,7 @@ static void my_hash_sort_ucs2(CHARSET_INFO *cs, const uchar *s, size_t slen,
   }
 }
 
+
 static size_t my_casedn_ucs2(CHARSET_INFO *cs, char *src, size_t srclen,
                            char *dst __attribute__((unused)),
                            size_t dstlen __attribute__((unused)))
@@ -2683,8 +2772,9 @@ static size_t my_casedn_ucs2(CHARSET_INFO *cs, char *src, size_t srclen,
   return srclen;
 }
 
-static int my_strnncoll_ucs2(CHARSET_INFO *cs,
-                 const uchar *s, size_t slen,
+
+static int my_strnncoll_ucs2(CHARSET_INFO *cs, 
+			     const uchar *s, size_t slen, 
                              const uchar *t, size_t tlen,
                              my_bool t_is_prefix)
 {
@@ -2699,13 +2789,13 @@ static int my_strnncoll_ucs2(CHARSET_INFO *cs,
     int plane;
     s_res=my_ucs2_uni(cs,&s_wc, s, se);
     t_res=my_ucs2_uni(cs,&t_wc, t, te);
-
+    
     if ( s_res <= 0 || t_res <= 0 )
     {
       /* Incorrect string, compare by char value */
-      return ((int)s[0]-(int)t[0]);
+      return ((int)s[0]-(int)t[0]); 
     }
-
+    
     plane=(s_wc>>8) & 0xFF;
     s_wc = uni_plane[plane] ? uni_plane[plane][s_wc & 0xFF].sort : s_wc;
     plane=(t_wc>>8) & 0xFF;
@@ -2714,7 +2804,7 @@ static int my_strnncoll_ucs2(CHARSET_INFO *cs,
     {
       return  s_wc > t_wc ? 1 : -1;
     }
-
+    
     s+=s_res;
     t+=t_res;
   }
@@ -2752,7 +2842,7 @@ static int my_strnncollsp_ucs2(CHARSET_INFO *cs __attribute__((unused)),
                                const uchar *s, size_t slen,
                                const uchar *t, size_t tlen,
                                my_bool diff_if_only_endspace_difference
-                   __attribute__((unused)))
+			       __attribute__((unused)))
 {
   const uchar *se, *te;
   size_t minlen;
@@ -2770,7 +2860,7 @@ static int my_strnncollsp_ucs2(CHARSET_INFO *cs __attribute__((unused)),
     int s_wc = uni_plane[s[0]] ? (int) uni_plane[s[0]][s[1]].sort :
                                  (((int) s[0]) << 8) + (int) s[1];
 
-    int t_wc = uni_plane[t[0]] ? (int) uni_plane[t[0]][t[1]].sort :
+    int t_wc = uni_plane[t[0]] ? (int) uni_plane[t[0]][t[1]].sort : 
                                  (((int) t[0]) << 8) + (int) t[1];
     if ( s_wc != t_wc )
       return  s_wc > t_wc ? 1 : -1;
@@ -2798,6 +2888,7 @@ static int my_strnncollsp_ucs2(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
 static uint my_ismbchar_ucs2(CHARSET_INFO *cs __attribute__((unused)),
                              const char *b __attribute__((unused)),
                              const char *e __attribute__((unused)))
@@ -2805,12 +2896,14 @@ static uint my_ismbchar_ucs2(CHARSET_INFO *cs __attribute__((unused)),
   return 2;
 }
 
-static uint my_mbcharlen_ucs2(CHARSET_INFO *cs  __attribute__((unused)) ,
+
+static uint my_mbcharlen_ucs2(CHARSET_INFO *cs  __attribute__((unused)) , 
                               uint c __attribute__((unused)))
 {
   return 2;
 }
 
+
 static
 size_t my_numchars_ucs2(CHARSET_INFO *cs __attribute__((unused)),
                         const char *b, const char *e)
@@ -2818,6 +2911,7 @@ size_t my_numchars_ucs2(CHARSET_INFO *cs __attribute__((unused)),
   return (size_t) (e-b)/2;
 }
 
+
 static
 size_t my_charpos_ucs2(CHARSET_INFO *cs __attribute__((unused)),
                        const char *b  __attribute__((unused)),
@@ -2828,6 +2922,7 @@ size_t my_charpos_ucs2(CHARSET_INFO *cs __attribute__((unused)),
   return pos > string_length ? string_length + 2 : pos * 2;
 }
 
+
 static
 size_t my_well_formed_len_ucs2(CHARSET_INFO *cs __attribute__((unused)),
                                const char *b, const char *e,
@@ -2840,29 +2935,32 @@ size_t my_well_formed_len_ucs2(CHARSET_INFO *cs __attribute__((unused)),
   return min(nbytes, nchars);
 }
 
+
 static
 int my_wildcmp_ucs2_ci(CHARSET_INFO *cs,
-            const char *str,const char *str_end,
-            const char *wildstr,const char *wildend,
-            int escape, int w_one, int w_many)
+		    const char *str,const char *str_end,
+		    const char *wildstr,const char *wildend,
+		    int escape, int w_one, int w_many)
 {
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   return my_wildcmp_unicode(cs,str,str_end,wildstr,wildend,
-                            escape,w_one,w_many,uni_plane);
+                            escape,w_one,w_many,uni_plane); 
 }
 
+
 static
 int my_wildcmp_ucs2_bin(CHARSET_INFO *cs,
-            const char *str,const char *str_end,
-            const char *wildstr,const char *wildend,
-            int escape, int w_one, int w_many)
+		    const char *str,const char *str_end,
+		    const char *wildstr,const char *wildend,
+		    int escape, int w_one, int w_many)
 {
   return my_wildcmp_unicode(cs,str,str_end,wildstr,wildend,
-                            escape,w_one,w_many,NULL);
+                            escape,w_one,w_many,NULL); 
 }
 
+
 static
-int my_strnncoll_ucs2_bin(CHARSET_INFO *cs,
+int my_strnncoll_ucs2_bin(CHARSET_INFO *cs, 
                           const uchar *s, size_t slen,
                           const uchar *t, size_t tlen,
                           my_bool t_is_prefix)
@@ -2876,25 +2974,25 @@ int my_strnncoll_ucs2_bin(CHARSET_INFO *cs,
   {
     s_res=my_ucs2_uni(cs,&s_wc, s, se);
     t_res=my_ucs2_uni(cs,&t_wc, t, te);
-
+    
     if ( s_res <= 0 || t_res <= 0 )
     {
       /* Incorrect string, compare by char value */
-      return ((int)s[0]-(int)t[0]);
+      return ((int)s[0]-(int)t[0]); 
     }
     if ( s_wc != t_wc )
     {
       return  s_wc > t_wc ? 1 : -1;
     }
-
+    
     s+=s_res;
     t+=t_res;
   }
   return (int) (t_is_prefix ? t-te : ((se-s) - (te-t)));
 }
 
-static int my_strnncollsp_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
-                                   const uchar *s, size_t slen,
+static int my_strnncollsp_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)), 
+                                   const uchar *s, size_t slen, 
                                    const uchar *t, size_t tlen,
                                    my_bool diff_if_only_endspace_difference
                                    __attribute__((unused)))
@@ -2939,12 +3037,13 @@ static int my_strnncollsp_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
 static
 void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
-               const uchar *key, size_t len,ulong *nr1, ulong *nr2)
+			   const uchar *key, size_t len,ulong *nr1, ulong *nr2)
 {
   const uchar *pos = key;
-
+  
   key+= len;
 
   while (key > pos+1 && key[-1] == ' ' && key[-2] == '\0')
@@ -2952,12 +3051,13 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
 
   for (; pos < (uchar*) key ; pos++)
   {
-    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) *
-         ((uint)*pos)) + (nr1[0] << 8);
+    nr1[0]^=(ulong) ((((uint) nr1[0] & 63)+nr2[0]) * 
+	     ((uint)*pos)) + (nr1[0] << 8);
     nr2[0]+=3;
   }
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ucs2_general_ci_handler =
 {
     NULL,		/* init */
@@ -2973,6 +3073,7 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
     my_propagate_simple
 };
 
+
 static MY_COLLATION_HANDLER my_collation_ucs2_bin_handler =
 {
     NULL,		/* init */
@@ -2988,6 +3089,7 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
     my_propagate_simple
 };
 
+
 MY_CHARSET_HANDLER my_charset_ucs2_handler=
 {
     NULL,		/* init */
@@ -3019,6 +3121,7 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
     my_scan_mb2
 };
 
+
 CHARSET_INFO my_charset_ucs2_general_ci=
 {
     35,0,0,		/* number       */
@@ -3051,6 +3154,40 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_ucs2_general_ci_handler
 };
 
+
+CHARSET_INFO my_charset_ucs2_general_mysql500_ci=
+{
+  159, 0, 0,                                       /* number           */
+  MY_CS_COMPILED|MY_CS_STRNXFRM|MY_CS_UNICODE|MY_CS_NONASCII, /* state */
+  "ucs2",                                          /* cs name          */
+  "ucs2_general_mysql500_ci",                      /* name             */
+  "",                                              /* comment          */
+  NULL,                                            /* tailoring        */
+  ctype_ucs2,                                      /* ctype            */
+  to_lower_ucs2,                                   /* to_lower         */
+  to_upper_ucs2,                                   /* to_upper         */
+  to_upper_ucs2,                                   /* sort_order       */
+  NULL,                                            /* contractions     */
+  NULL,                                            /* sort_order_big   */
+  NULL,                                            /* tab_to_uni       */
+  NULL,                                            /* tab_from_uni     */
+  my_unicase_mysql500,                             /* caseinfo         */
+  NULL,                                            /* state_map        */
+  NULL,                                            /* ident_map        */
+  1,                                               /* strxfrm_multiply */
+  1,                                               /* caseup_multiply  */
+  1,                                               /* casedn_multiply  */
+  2,                                               /* mbminlen         */
+  2,                                               /* mbmaxlen         */
+  0,                                               /* min_sort_char    */
+  0xFFFF,                                          /* max_sort_char    */
+  ' ',                                             /* pad char         */
+  0,                          /* escape_with_backslash_is_dangerous    */
+  &my_charset_ucs2_handler,
+  &my_collation_ucs2_general_ci_handler
+};
+
+
 CHARSET_INFO my_charset_ucs2_bin=
 {
     90,0,0,		/* number       */
@@ -3083,4 +3220,5 @@ void my_hash_sort_ucs2_bin(CHARSET_INFO *cs __attribute__((unused)),
     &my_collation_ucs2_bin_handler
 };
 
-#endif /* HAVE_CHARSET_ucs2 */
\ No newline at end of file
+
+#endif /* HAVE_CHARSET_ucs2 */
diff --git a/dep/mysqllite/strings/ctype-utf8.c b/dep/mysqllite/strings/ctype-utf8.c
index 793ba69..234898e 100644
--- a/dep/mysqllite/strings/ctype-utf8.c
+++ b/dep/mysqllite/strings/ctype-utf8.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -27,6 +27,7 @@
 #define EILSEQ ENOENT
 #endif
 
+
 #define MY_UTF8MB3_GENERAL_CI MY_UTF8MB3 "_general_ci"
 #define MY_UTF8MB3_GENERAL_CS MY_UTF8MB3 "_general_cs"
 #define MY_UTF8MB3_BIN        MY_UTF8MB3 "_bin"
@@ -34,6 +35,8 @@
 #define MY_UTF8MB4_GENERAL_CS MY_UTF8MB4 "_general_cs"
 #define MY_UTF8MB4_BIN        MY_UTF8MB4 "_bin"
 
+
+
 #ifndef HAVE_CHARSET_utf8
 #define HAVE_CHARSET_utf8
 #endif
@@ -189,6 +192,143 @@
   {0x00DE,0x00FE,0x00DE},  {0x0178,0x00FF,0x0059}
 };
 
+
+/*
+  Almost similar to plane00, but maps sorting order
+  for U+00DF to 0x00DF instead of 0x0053.
+*/
+static MY_UNICASE_INFO plane00_mysql500[]={
+  {0x0000,0x0000,0x0000},  {0x0001,0x0001,0x0001},
+  {0x0002,0x0002,0x0002},  {0x0003,0x0003,0x0003},
+  {0x0004,0x0004,0x0004},  {0x0005,0x0005,0x0005},
+  {0x0006,0x0006,0x0006},  {0x0007,0x0007,0x0007},
+  {0x0008,0x0008,0x0008},  {0x0009,0x0009,0x0009},
+  {0x000A,0x000A,0x000A},  {0x000B,0x000B,0x000B},
+  {0x000C,0x000C,0x000C},  {0x000D,0x000D,0x000D},
+  {0x000E,0x000E,0x000E},  {0x000F,0x000F,0x000F},
+  {0x0010,0x0010,0x0010},  {0x0011,0x0011,0x0011},
+  {0x0012,0x0012,0x0012},  {0x0013,0x0013,0x0013},
+  {0x0014,0x0014,0x0014},  {0x0015,0x0015,0x0015},
+  {0x0016,0x0016,0x0016},  {0x0017,0x0017,0x0017},
+  {0x0018,0x0018,0x0018},  {0x0019,0x0019,0x0019},
+  {0x001A,0x001A,0x001A},  {0x001B,0x001B,0x001B},
+  {0x001C,0x001C,0x001C},  {0x001D,0x001D,0x001D},
+  {0x001E,0x001E,0x001E},  {0x001F,0x001F,0x001F},
+  {0x0020,0x0020,0x0020},  {0x0021,0x0021,0x0021},
+  {0x0022,0x0022,0x0022},  {0x0023,0x0023,0x0023},
+  {0x0024,0x0024,0x0024},  {0x0025,0x0025,0x0025},
+  {0x0026,0x0026,0x0026},  {0x0027,0x0027,0x0027},
+  {0x0028,0x0028,0x0028},  {0x0029,0x0029,0x0029},
+  {0x002A,0x002A,0x002A},  {0x002B,0x002B,0x002B},
+  {0x002C,0x002C,0x002C},  {0x002D,0x002D,0x002D},
+  {0x002E,0x002E,0x002E},  {0x002F,0x002F,0x002F},
+  {0x0030,0x0030,0x0030},  {0x0031,0x0031,0x0031},
+  {0x0032,0x0032,0x0032},  {0x0033,0x0033,0x0033},
+  {0x0034,0x0034,0x0034},  {0x0035,0x0035,0x0035},
+  {0x0036,0x0036,0x0036},  {0x0037,0x0037,0x0037},
+  {0x0038,0x0038,0x0038},  {0x0039,0x0039,0x0039},
+  {0x003A,0x003A,0x003A},  {0x003B,0x003B,0x003B},
+  {0x003C,0x003C,0x003C},  {0x003D,0x003D,0x003D},
+  {0x003E,0x003E,0x003E},  {0x003F,0x003F,0x003F},
+  {0x0040,0x0040,0x0040},  {0x0041,0x0061,0x0041},
+  {0x0042,0x0062,0x0042},  {0x0043,0x0063,0x0043},
+  {0x0044,0x0064,0x0044},  {0x0045,0x0065,0x0045},
+  {0x0046,0x0066,0x0046},  {0x0047,0x0067,0x0047},
+  {0x0048,0x0068,0x0048},  {0x0049,0x0069,0x0049},
+  {0x004A,0x006A,0x004A},  {0x004B,0x006B,0x004B},
+  {0x004C,0x006C,0x004C},  {0x004D,0x006D,0x004D},
+  {0x004E,0x006E,0x004E},  {0x004F,0x006F,0x004F},
+  {0x0050,0x0070,0x0050},  {0x0051,0x0071,0x0051},
+  {0x0052,0x0072,0x0052},  {0x0053,0x0073,0x0053},
+  {0x0054,0x0074,0x0054},  {0x0055,0x0075,0x0055},
+  {0x0056,0x0076,0x0056},  {0x0057,0x0077,0x0057},
+  {0x0058,0x0078,0x0058},  {0x0059,0x0079,0x0059},
+  {0x005A,0x007A,0x005A},  {0x005B,0x005B,0x005B},
+  {0x005C,0x005C,0x005C},  {0x005D,0x005D,0x005D},
+  {0x005E,0x005E,0x005E},  {0x005F,0x005F,0x005F},
+  {0x0060,0x0060,0x0060},  {0x0041,0x0061,0x0041},
+  {0x0042,0x0062,0x0042},  {0x0043,0x0063,0x0043},
+  {0x0044,0x0064,0x0044},  {0x0045,0x0065,0x0045},
+  {0x0046,0x0066,0x0046},  {0x0047,0x0067,0x0047},
+  {0x0048,0x0068,0x0048},  {0x0049,0x0069,0x0049},
+  {0x004A,0x006A,0x004A},  {0x004B,0x006B,0x004B},
+  {0x004C,0x006C,0x004C},  {0x004D,0x006D,0x004D},
+  {0x004E,0x006E,0x004E},  {0x004F,0x006F,0x004F},
+  {0x0050,0x0070,0x0050},  {0x0051,0x0071,0x0051},
+  {0x0052,0x0072,0x0052},  {0x0053,0x0073,0x0053},
+  {0x0054,0x0074,0x0054},  {0x0055,0x0075,0x0055},
+  {0x0056,0x0076,0x0056},  {0x0057,0x0077,0x0057},
+  {0x0058,0x0078,0x0058},  {0x0059,0x0079,0x0059},
+  {0x005A,0x007A,0x005A},  {0x007B,0x007B,0x007B},
+  {0x007C,0x007C,0x007C},  {0x007D,0x007D,0x007D},
+  {0x007E,0x007E,0x007E},  {0x007F,0x007F,0x007F},
+  {0x0080,0x0080,0x0080},  {0x0081,0x0081,0x0081},
+  {0x0082,0x0082,0x0082},  {0x0083,0x0083,0x0083},
+  {0x0084,0x0084,0x0084},  {0x0085,0x0085,0x0085},
+  {0x0086,0x0086,0x0086},  {0x0087,0x0087,0x0087},
+  {0x0088,0x0088,0x0088},  {0x0089,0x0089,0x0089},
+  {0x008A,0x008A,0x008A},  {0x008B,0x008B,0x008B},
+  {0x008C,0x008C,0x008C},  {0x008D,0x008D,0x008D},
+  {0x008E,0x008E,0x008E},  {0x008F,0x008F,0x008F},
+  {0x0090,0x0090,0x0090},  {0x0091,0x0091,0x0091},
+  {0x0092,0x0092,0x0092},  {0x0093,0x0093,0x0093},
+  {0x0094,0x0094,0x0094},  {0x0095,0x0095,0x0095},
+  {0x0096,0x0096,0x0096},  {0x0097,0x0097,0x0097},
+  {0x0098,0x0098,0x0098},  {0x0099,0x0099,0x0099},
+  {0x009A,0x009A,0x009A},  {0x009B,0x009B,0x009B},
+  {0x009C,0x009C,0x009C},  {0x009D,0x009D,0x009D},
+  {0x009E,0x009E,0x009E},  {0x009F,0x009F,0x009F},
+  {0x00A0,0x00A0,0x00A0},  {0x00A1,0x00A1,0x00A1},
+  {0x00A2,0x00A2,0x00A2},  {0x00A3,0x00A3,0x00A3},
+  {0x00A4,0x00A4,0x00A4},  {0x00A5,0x00A5,0x00A5},
+  {0x00A6,0x00A6,0x00A6},  {0x00A7,0x00A7,0x00A7},
+  {0x00A8,0x00A8,0x00A8},  {0x00A9,0x00A9,0x00A9},
+  {0x00AA,0x00AA,0x00AA},  {0x00AB,0x00AB,0x00AB},
+  {0x00AC,0x00AC,0x00AC},  {0x00AD,0x00AD,0x00AD},
+  {0x00AE,0x00AE,0x00AE},  {0x00AF,0x00AF,0x00AF},
+  {0x00B0,0x00B0,0x00B0},  {0x00B1,0x00B1,0x00B1},
+  {0x00B2,0x00B2,0x00B2},  {0x00B3,0x00B3,0x00B3},
+  {0x00B4,0x00B4,0x00B4},  {0x039C,0x00B5,0x039C},
+  {0x00B6,0x00B6,0x00B6},  {0x00B7,0x00B7,0x00B7},
+  {0x00B8,0x00B8,0x00B8},  {0x00B9,0x00B9,0x00B9},
+  {0x00BA,0x00BA,0x00BA},  {0x00BB,0x00BB,0x00BB},
+  {0x00BC,0x00BC,0x00BC},  {0x00BD,0x00BD,0x00BD},
+  {0x00BE,0x00BE,0x00BE},  {0x00BF,0x00BF,0x00BF},
+  {0x00C0,0x00E0,0x0041},  {0x00C1,0x00E1,0x0041},
+  {0x00C2,0x00E2,0x0041},  {0x00C3,0x00E3,0x0041},
+  {0x00C4,0x00E4,0x0041},  {0x00C5,0x00E5,0x0041},
+  {0x00C6,0x00E6,0x00C6},  {0x00C7,0x00E7,0x0043},
+  {0x00C8,0x00E8,0x0045},  {0x00C9,0x00E9,0x0045},
+  {0x00CA,0x00EA,0x0045},  {0x00CB,0x00EB,0x0045},
+  {0x00CC,0x00EC,0x0049},  {0x00CD,0x00ED,0x0049},
+  {0x00CE,0x00EE,0x0049},  {0x00CF,0x00EF,0x0049},
+  {0x00D0,0x00F0,0x00D0},  {0x00D1,0x00F1,0x004E},
+  {0x00D2,0x00F2,0x004F},  {0x00D3,0x00F3,0x004F},
+  {0x00D4,0x00F4,0x004F},  {0x00D5,0x00F5,0x004F},
+  {0x00D6,0x00F6,0x004F},  {0x00D7,0x00D7,0x00D7},
+  {0x00D8,0x00F8,0x00D8},  {0x00D9,0x00F9,0x0055},
+  {0x00DA,0x00FA,0x0055},  {0x00DB,0x00FB,0x0055},
+  {0x00DC,0x00FC,0x0055},  {0x00DD,0x00FD,0x0059},
+  {0x00DE,0x00FE,0x00DE},  {0x00DF,0x00DF,0x00DF},
+  {0x00C0,0x00E0,0x0041},  {0x00C1,0x00E1,0x0041},
+  {0x00C2,0x00E2,0x0041},  {0x00C3,0x00E3,0x0041},
+  {0x00C4,0x00E4,0x0041},  {0x00C5,0x00E5,0x0041},
+  {0x00C6,0x00E6,0x00C6},  {0x00C7,0x00E7,0x0043},
+  {0x00C8,0x00E8,0x0045},  {0x00C9,0x00E9,0x0045},
+  {0x00CA,0x00EA,0x0045},  {0x00CB,0x00EB,0x0045},
+  {0x00CC,0x00EC,0x0049},  {0x00CD,0x00ED,0x0049},
+  {0x00CE,0x00EE,0x0049},  {0x00CF,0x00EF,0x0049},
+  {0x00D0,0x00F0,0x00D0},  {0x00D1,0x00F1,0x004E},
+  {0x00D2,0x00F2,0x004F},  {0x00D3,0x00F3,0x004F},
+  {0x00D4,0x00F4,0x004F},  {0x00D5,0x00F5,0x004F},
+  {0x00D6,0x00F6,0x004F},  {0x00F7,0x00F7,0x00F7},
+  {0x00D8,0x00F8,0x00D8},  {0x00D9,0x00F9,0x0055},
+  {0x00DA,0x00FA,0x0055},  {0x00DB,0x00FB,0x0055},
+  {0x00DC,0x00FC,0x0055},  {0x00DD,0x00FD,0x0059},
+  {0x00DE,0x00FE,0x00DE},  {0x0178,0x00FF,0x0059}
+};
+
+
 static MY_UNICASE_INFO plane01[]={
   {0x0100,0x0101,0x0041},  {0x0100,0x0101,0x0041},
   {0x0102,0x0103,0x0041},  {0x0102,0x0103,0x0041},
@@ -1532,13 +1672,56 @@
     NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
     NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
     NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL, planeFF
+
+};
+
+
+/*
+  Reproduce old utf8_general_ci behaviour before we fixed Bug#27877.
+*/
+MY_UNICASE_INFO *my_unicase_mysql500[256]={
+ plane00_mysql500,
+          plane01, plane02, plane03, plane04, plane05,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL, plane1E, plane1F,
+    NULL, plane21,    NULL,    NULL, plane24,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,
+    NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL, planeFF
+
 };
 
+
 /*
   Turkish lower/upper mapping:
-  1. LOWER(0x0049 LATIN CAPITAL LETTER I) ->
+  1. LOWER(0x0049 LATIN CAPITAL LETTER I) -> 
            0x0131 LATIN SMALL   LETTER DOTLESS I
-  2. UPPER(0x0069 LATIN SMALL   LETTER I) ->
+  2. UPPER(0x0069 LATIN SMALL   LETTER I) -> 
            0x0130 LATIN CAPITAL LETTER I WITH DOT ABOVE
 */
 
@@ -1674,6 +1857,8 @@
   {0x00DE,0x00FE,0x00DE},  {0x0178,0x00FF,0x0059}
 };
 
+
+
 MY_UNICASE_INFO *my_unicase_turkish[256]=
 {
   turk00, plane01, plane02, plane03, plane04, plane05,    NULL,    NULL,
@@ -1710,6 +1895,7 @@
     NULL,    NULL,    NULL,    NULL,    NULL,    NULL,    NULL, planeFF
 };
 
+
 static inline void
 my_tosort_unicode(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -1725,6 +1911,7 @@
   }
 }
 
+
 /*
 ** Compare string against string with wildcard
 ** This function is used in UTF8 and UCS2
@@ -1747,7 +1934,7 @@
   int (*mb_wc)(struct charset_info_st *, my_wc_t *,
                const uchar *, const uchar *);
   mb_wc= cs->cset->mb_wc;
-
+  
   while (wildstr != wildend)
   {
     while (1)
@@ -1772,12 +1959,12 @@
         wildstr+= scan;
         escaped= 1;
       }
-
+      
       if ((scan= mb_wc(cs, &s_wc, (const uchar*)str,
                        (const uchar*)str_end)) <= 0)
         return 1;
       str+= scan;
-
+      
       if (!escaped && w_wc == (my_wc_t) w_one)
       {
         result= 1;                                /* Found an anchor char */
@@ -1795,23 +1982,24 @@
       if (wildstr == wildend)
         return (str != str_end);                  /* Match if both are at end */
     }
-
+    
+    
     if (w_wc == (my_wc_t) w_many)
     {                                             /* Found w_many */
-
+    
       /* Remove any '%' and '_' from the wild search string */
       for ( ; wildstr != wildend ; )
       {
         if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
                          (const uchar*)wildend)) <= 0)
           return 1;
-
+        
         if (w_wc == (my_wc_t)w_many)
         {
           wildstr+= scan;
           continue;
-        }
-
+        } 
+        
         if (w_wc == (my_wc_t)w_one)
         {
           wildstr+= scan;
@@ -1823,18 +2011,18 @@
         }
         break;                                        /* Not a wild character */
       }
-
+      
       if (wildstr == wildend)
         return 0;                                /* Ok if w_many is last */
-
+      
       if (str == str_end)
         return -1;
-
+      
       if ((scan= mb_wc(cs, &w_wc, (const uchar*)wildstr,
                        (const uchar*)wildend)) <=0)
         return 1;
       wildstr+= scan;
-
+      
       if (w_wc ==  (my_wc_t)escape)
       {
         if (wildstr < wildend)
@@ -1845,7 +2033,7 @@
           wildstr+= scan;
         }
       }
-
+      
       while (1)
       {
         /* Skip until the first character from wildstr is found */
@@ -1859,26 +2047,27 @@
             my_tosort_unicode(weights, &s_wc);
             my_tosort_unicode(weights, &w_wc);
           }
-
+          
           if (s_wc == w_wc)
             break;
           str+= scan;
         }
         if (str == str_end)
           return -1;
-
+        
         str+= scan;
         result= my_wildcmp_unicode(cs, str, str_end, wildstr, wildend,
                                    escape, w_one, w_many,
                                    weights);
         if (result <= 0)
           return result;
-      }
+      } 
     }
   }
   return (str != str_end ? 1 : 0);
 }
 
+
 /*
   Store sorting weights using 2 bytes per character.
 
@@ -1902,7 +2091,7 @@
                                 NULL : cs->caseinfo;
   LINT_INIT(wc);
   DBUG_ASSERT(src);
-
+  
   while (dst < de_beg)
   {
     if ((res= cs->cset->mb_wc(cs,&wc, src, se)) <= 0)
@@ -1916,19 +2105,20 @@
     if (dst < de)
       *dst++= (uchar) (wc & 0xFF);
   }
-
+  
   while (dst < de_beg) /* Fill the tail with keys for space character */
   {
     *dst++= 0x00;
     *dst++= 0x20;
   }
-
+  
   if (dst < de)  /* Clear the last byte, if "dstlen" was an odd number */
     *dst= 0x00;
-
+  
   return dstlen;
 }
 
+
 /*
   Store sorting weights using 3 bytes per character.
   This function is shared between utf8mb4_bin, utf16_bin, utf32_bin.
@@ -1976,6 +2166,7 @@
   return dstlen;
 }
 
+
 size_t
 my_strnxfrmlen_unicode_full_bin(CHARSET_INFO *cs, size_t len)
 {
@@ -1983,6 +2174,7 @@
 }
 #endif /* HAVE_UNIDATA */
 
+
 #ifdef HAVE_CHARSET_utf8
 
 /*
@@ -2060,6 +2252,7 @@ static inline int bincmp(const uchar *s, const uchar *se,
   return cmp ? cmp : slen-tlen;
 }
 
+
 static int my_utf8_uni(CHARSET_INFO *cs __attribute__((unused)),
                        my_wc_t * pwc, const uchar *s, const uchar *e)
 {
@@ -2165,6 +2358,7 @@ static int my_utf8_uni(CHARSET_INFO *cs __attribute__((unused)),
   return MY_CS_ILSEQ;
 }
 
+
 /*
   The same as above, but without range check
   for example, for a null-terminated string
@@ -2192,7 +2386,7 @@ static int my_utf8_uni_no_range(CHARSET_INFO *cs __attribute__((unused)),
     *pwc = ((my_wc_t) (c & 0x1f) << 6) | (my_wc_t) (s[1] ^ 0x80);
     return 2;
   }
-
+  
   if (c < 0xf0)
   {
     if (!((s[1] ^ 0x80) < 0x40 &&
@@ -2209,6 +2403,7 @@ static int my_utf8_uni_no_range(CHARSET_INFO *cs __attribute__((unused)),
   return MY_CS_ILSEQ;
 }
 
+
 static int my_uni_utf8 (CHARSET_INFO *cs __attribute__((unused)),
                         my_wc_t wc, uchar *r, uchar *e)
 {
@@ -2254,6 +2449,7 @@ static int my_uni_utf8 (CHARSET_INFO *cs __attribute__((unused)),
   return count;
 }
 
+
 /*
   The same as above, but without range check.
 */
@@ -2281,6 +2477,7 @@ static int my_uni_utf8_no_range(CHARSET_INFO *cs __attribute__((unused)),
   return count;
 }
 
+
 static size_t my_caseup_utf8(CHARSET_INFO *cs, char *src, size_t srclen,
                              char *dst, size_t dstlen)
 {
@@ -2303,6 +2500,7 @@ static size_t my_caseup_utf8(CHARSET_INFO *cs, char *src, size_t srclen,
   return (size_t) (dst - dst0);
 }
 
+
 static void my_hash_sort_utf8(CHARSET_INFO *cs, const uchar *s, size_t slen,
                               ulong *n1, ulong *n2)
 {
@@ -2330,6 +2528,7 @@ static void my_hash_sort_utf8(CHARSET_INFO *cs, const uchar *s, size_t slen,
   }
 }
 
+
 static size_t my_caseup_str_utf8(CHARSET_INFO *cs, char *src)
 {
   my_wc_t wc;
@@ -2352,6 +2551,7 @@ static size_t my_caseup_str_utf8(CHARSET_INFO *cs, char *src)
   return (size_t) (dst - dst0);
 }
 
+
 static size_t my_casedn_utf8(CHARSET_INFO *cs, char *src, size_t srclen,
                              char *dst, size_t dstlen)
 {
@@ -2374,6 +2574,7 @@ static size_t my_casedn_utf8(CHARSET_INFO *cs, char *src, size_t srclen,
   return (size_t) (dst - dst0);
 }
 
+
 static size_t my_casedn_str_utf8(CHARSET_INFO *cs, char *src)
 {
   my_wc_t wc;
@@ -2412,6 +2613,7 @@ static size_t my_casedn_str_utf8(CHARSET_INFO *cs, char *src)
   return (size_t) (dst - dst0);
 }
 
+
 static int my_strnncoll_utf8(CHARSET_INFO *cs,
                              const uchar *s, size_t slen,
                              const uchar *t, size_t tlen,
@@ -2450,6 +2652,8 @@ static int my_strnncoll_utf8(CHARSET_INFO *cs,
   return (int) (t_is_prefix ? t-te : ((se-s) - (te-t)));
 }
 
+
+
 /*
   Compare strings, discarding end space
 
@@ -2461,7 +2665,7 @@ static int my_strnncoll_utf8(CHARSET_INFO *cs,
     b                   Second string to compare
     b_length            Length of 'b'
     diff_if_only_endspace_difference
-                Set to 1 if the strings should be regarded as different
+		        Set to 1 if the strings should be regarded as different
                         if they only difference in end space
 
   IMPLEMENTATION
@@ -2549,12 +2753,13 @@ static int my_strnncollsp_utf8(CHARSET_INFO *cs,
     for ( ; s < se; s++)
     {
       if (*s != ' ')
-    return (*s < ' ') ? -swap : swap;
+	return (*s < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 /*
   Compare 0-terminated UTF8 strings.
 
@@ -2579,10 +2784,10 @@ int my_strcasecmp_utf8(CHARSET_INFO *cs, const char *s, const char *t)
   while (s[0] && t[0])
   {
     my_wc_t s_wc,t_wc;
-
+    
     if ((uchar) s[0] < 128)
     {
-      /*
+      /* 
         s[0] is between 0 and 127.
         It represents a single byte character.
         Convert it into weight according to collation.
@@ -2593,7 +2798,7 @@ int my_strcasecmp_utf8(CHARSET_INFO *cs, const char *s, const char *t)
     else
     {
       int plane, res;
-
+      
       /*
         Scan a multibyte character.
 
@@ -2608,24 +2813,25 @@ int my_strcasecmp_utf8(CHARSET_INFO *cs, const char *s, const char *t)
         then my_utf8_uni will always return a negative number, so the
         loop with finish.
       */
-
+      
       res= my_utf8_uni(cs,&s_wc, (const uchar*)s, (const uchar*) s + 3);
-
-      /*
+      
+      /* 
          In the case of wrong multibyte sequence we will
          call strcmp() for byte-to-byte comparison.
       */
       if (res <= 0)
         return strcmp(s, t);
       s+= res;
-
+      
       /* Convert Unicode code into weight according to collation */
       plane=(s_wc>>8) & 0xFF;
       s_wc = uni_plane[plane] ? uni_plane[plane][s_wc & 0xFF].tolower : s_wc;
     }
-
+    
+    
     /* Do the same for the second string */
-
+    
     if ((uchar) t[0] < 128)
     {
       /* Convert single byte character into weight */
@@ -2639,12 +2845,12 @@ int my_strcasecmp_utf8(CHARSET_INFO *cs, const char *s, const char *t)
       if (res <= 0)
         return strcmp(s, t);
       t+= res;
-
+      
       /* Convert code into weight */
       plane=(t_wc>>8) & 0xFF;
       t_wc = uni_plane[plane] ? uni_plane[plane][t_wc & 0xFF].tolower : t_wc;
     }
-
+    
     /* Now we have two weights, let's compare them */
     if ( s_wc != t_wc )
       return  ((int) s_wc) - ((int) t_wc);
@@ -2652,17 +2858,19 @@ int my_strcasecmp_utf8(CHARSET_INFO *cs, const char *s, const char *t)
   return ((int)(uchar)s[0]) - ((int) (uchar) t[0]);
 }
 
+
 static
 int my_wildcmp_utf8(CHARSET_INFO *cs,
-            const char *str,const char *str_end,
-            const char *wildstr,const char *wildend,
-            int escape, int w_one, int w_many)
+		    const char *str,const char *str_end,
+		    const char *wildstr,const char *wildend,
+		    int escape, int w_one, int w_many)
 {
   MY_UNICASE_INFO **uni_plane= cs->caseinfo;
   return my_wildcmp_unicode(cs,str,str_end,wildstr,wildend,
-                            escape,w_one,w_many,uni_plane);
+                            escape,w_one,w_many,uni_plane); 
 }
 
+
 static
 size_t my_strnxfrmlen_utf8(CHARSET_INFO *cs __attribute__((unused)),
                            size_t len)
@@ -2670,6 +2878,7 @@ size_t my_strnxfrmlen_utf8(CHARSET_INFO *cs __attribute__((unused)),
   return (len * 2 + 2) / 3;
 }
 
+
 static uint my_ismbchar_utf8(CHARSET_INFO *cs,const char *b, const char *e)
 {
   my_wc_t wc;
@@ -2699,6 +2908,7 @@ static uint my_mbcharlen_utf8(CHARSET_INFO *cs  __attribute__((unused)),
   return 0; /* Illegal mb head */;
 }
 
+
 static MY_COLLATION_HANDLER my_collation_ci_handler =
 {
     NULL,               /* init */
@@ -2745,6 +2955,8 @@ static uint my_mbcharlen_utf8(CHARSET_INFO *cs  __attribute__((unused)),
     my_scan_8bit
 };
 
+
+
 CHARSET_INFO my_charset_utf8_general_ci=
 {
     33,0,0,             /* number       */
@@ -2777,6 +2989,40 @@ static uint my_mbcharlen_utf8(CHARSET_INFO *cs  __attribute__((unused)),
     &my_collation_ci_handler
 };
 
+
+CHARSET_INFO my_charset_utf8_general_mysql500_ci=
+{
+  223,0,0,                                      /* number           */
+  MY_CS_COMPILED|MY_CS_STRNXFRM|MY_CS_UNICODE,  /* state            */
+  "utf8",                                       /* cs name          */
+  "utf8_general_mysql500_ci",                   /* name             */
+  "",                                           /* comment          */
+  NULL,                                         /* tailoring        */
+  ctype_utf8,                                   /* ctype            */
+  to_lower_utf8,                                /* to_lower         */
+  to_upper_utf8,                                /* to_upper         */
+  to_upper_utf8,                                /* sort_order       */
+  NULL,                                         /* contractions     */
+  NULL,                                         /* sort_order_big   */
+  NULL,                                         /* tab_to_uni       */
+  NULL,                                         /* tab_from_uni     */
+  my_unicase_mysql500,                          /* caseinfo         */
+  NULL,                                         /* state_map        */
+  NULL,                                         /* ident_map        */
+  1,                                            /* strxfrm_multiply */
+  1,                                            /* caseup_multiply  */
+  1,                                            /* casedn_multiply  */
+  1,                                            /* mbminlen         */
+  3,                                            /* mbmaxlen         */
+  0,                                            /* min_sort_char    */
+  0xFFFF,                                       /* max_sort_char    */
+  ' ',                                          /* pad char         */
+  0,                          /* escape_with_backslash_is_dangerous */
+  &my_charset_utf8_handler,
+  &my_collation_ci_handler
+};
+
+
 CHARSET_INFO my_charset_utf8_bin=
 {
     83,0,0,             /* number       */
@@ -2818,7 +3064,7 @@ static uint my_mbcharlen_utf8(CHARSET_INFO *cs  __attribute__((unused)),
  * variable to what they actually do.
  */
 
-static int my_strnncoll_utf8_cs(CHARSET_INFO *cs,
+static int my_strnncoll_utf8_cs(CHARSET_INFO *cs, 
                                 const uchar *s, size_t slen,
                                 const uchar *t, size_t tlen,
                                 my_bool t_is_prefix)
@@ -2836,14 +3082,14 @@ static int my_strnncoll_utf8_cs(CHARSET_INFO *cs,
     int plane;
     s_res=my_utf8_uni(cs,&s_wc, s, se);
     t_res=my_utf8_uni(cs,&t_wc, t, te);
-
+    
     if ( s_res <= 0 || t_res <= 0 )
 
     {
       /* Incorrect string, compare by char value */
-      return ((int)s[0]-(int)t[0]);
+      return ((int)s[0]-(int)t[0]); 
     }
-
+    
     if ( save_diff == 0 )
     {
       save_diff = ((int)s_wc) - ((int)t_wc);
@@ -2856,7 +3102,7 @@ static int my_strnncoll_utf8_cs(CHARSET_INFO *cs,
     {
       return  ((int) s_wc) - ((int) t_wc);
     }
-
+    
     s+=s_res;
     t+=t_res;
   }
@@ -2864,7 +3110,7 @@ static int my_strnncoll_utf8_cs(CHARSET_INFO *cs,
   return t_is_prefix ? t-te : ((diff == 0) ? save_diff : diff);
 }
 
-static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
+static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs, 
                                   const uchar *s, size_t slen,
                                   const uchar *t, size_t tlen,
                                   my_bool diff_if_only_endspace_difference)
@@ -2879,19 +3125,19 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
 #ifndef VARCHAR_WITH_DIFF_ENDSPACE_ARE_DIFFERENT_FOR_UNIQUE
   diff_if_only_endspace_difference= 0;
 #endif
-
+    
   while ( s < se && t < te )
   {
     int plane;
     s_res=my_utf8_uni(cs,&s_wc, s, se);
     t_res=my_utf8_uni(cs,&t_wc, t, te);
-
+    
     if ( s_res <= 0 || t_res <= 0 )
     {
       /* Incorrect string, compare by char value */
-      return ((int)s[0]-(int)t[0]);
+      return ((int)s[0]-(int)t[0]); 
     }
-
+    
     if ( save_diff == 0 )
     {
       save_diff = ((int)s_wc) - ((int)t_wc);
@@ -2904,15 +3150,15 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
     {
       return  ((int) s_wc) - ((int) t_wc);
     }
-
+    
     s+=s_res;
     t+=t_res;
   }
-
+  
   slen= se-s;
   tlen= te-t;
   res= 0;
-
+  
   if (slen != tlen)
   {
     int swap= 1;
@@ -2993,6 +3239,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
 };
 #endif	/* Cybozu Hack */
 
+
 /*
   File system encoding components:
 
@@ -3016,6 +3263,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
 
 */
 
+
 static uint16 touni[5994]=
 {
   0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
@@ -3770,6 +4018,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x1FD1,0x1FF4
 };
 
+
 /* 00C0-05FF */
 static uint16 uni_0C00_05FF[1344]=
 {
@@ -3943,6 +4192,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
 };
 
+
 /* 1E00-1FFF */
 static uint16 uni_1E00_1FFF[512]=
 {
@@ -4012,6 +4262,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x0B36,0x0B86,0x0C76,0x0CC6,0x0D19,0x0000,0x0000,0x0000
 };
 
+
 /* 2160-217F */
 static uint16 uni_2160_217F[32]=
 {
@@ -4021,6 +4272,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x13B9,0x1409,0x1459,0x14A9,0x14F9,0x1549,0x1599,0x15E9
 };
 
+
 /* 24B0-24EF */
 static uint16 uni_24B0_24EF[64]=
 {
@@ -4034,6 +4286,7 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x0549,0x054A,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000
 };
 
+
 /* FF20-FF5F */
 static uint16 uni_FF20_FF5F[64]=
 {
@@ -4047,6 +4300,10 @@ static int my_strnncollsp_utf8_cs(CHARSET_INFO *cs,
   0x1690,0x16E0,0x1730,0x0000,0x0000,0x0000,0x0000,0x0000
 };
 
+
+
+
+
 /*
   Returns
    a number 0..15, if a valid HEX digit in lower case,
@@ -4077,6 +4334,7 @@ static int hexlo(int x)
   return hex_lo_digit[(unsigned int) x];
 }
 
+
 /*
   Safe characters:
    '\0'  NULL
@@ -4107,21 +4365,21 @@ static int hexlo(int x)
   if (s >= e)
     return MY_CS_TOOSMALL;
 
-  if (*s < 128 && filename_safe_char[*s])
+  if (*s < 128 && filename_safe_char[*s])  
   {
     *pwc= *s;
     return 1;
   }
-
+  
   if (*s != MY_FILENAME_ESCAPE)
     return MY_CS_ILSEQ;
-
+  
   if (s + 3 > e)
     return MY_CS_TOOSMALL3;
-
+  
   byte1= s[1];
   byte2= s[2];
-
+  
   if (byte1 >= 0x30 && byte1 <= 0x7F &&
       byte2 >= 0x30 && byte2 <= 0x7F)
   {
@@ -4137,7 +4395,7 @@ static int hexlo(int x)
       return 3;
     }
   }
-
+  
   if (s + 4 > e)
     return MY_CS_TOOSMALL4;
 
@@ -4152,22 +4410,27 @@ static int hexlo(int x)
       return 5;
     }
   }
-
+  
   return MY_CS_ILSEQ;
 }
 
+
 static int
 my_wc_mb_filename(CHARSET_INFO *cs __attribute__((unused)),
                   my_wc_t wc, uchar *s, uchar *e)
 {
   int code;
   char hex[]= "0123456789abcdef";
+
+  if (s >= e)
+    return MY_CS_TOOSMALL;
+
   if (wc < 128 && filename_safe_char[wc])
   {
     *s= (uchar) wc;
     return 1;
   }
-
+  
   if (s + 3 > e)
     return MY_CS_TOOSMALL3;
 
@@ -4194,6 +4457,7 @@ static int hexlo(int x)
   return 5;
 }
 
+
 static MY_COLLATION_HANDLER my_collation_filename_handler =
 {
     NULL,               /* init */
@@ -4240,6 +4504,8 @@ static int hexlo(int x)
     my_scan_8bit
 };
 
+
+
 CHARSET_INFO my_charset_filename=
 {
     17,0,0,             /* number       */
@@ -4272,6 +4538,7 @@ static int hexlo(int x)
     &my_collation_filename_handler
 };
 
+
 #ifdef MY_TEST_UTF8
 #include <stdio.h>
 
@@ -4325,6 +4592,8 @@ int main()
 
 #endif /* HAVE_CHARSET_UTF8 */
 
+
+
 #ifdef HAVE_CHARSET_utf8mb4
 
 /*
@@ -4354,6 +4623,7 @@ int main()
     3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  0
 };
 
+
 static uchar to_lower_utf8mb4[]=
 {
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
@@ -4374,6 +4644,7 @@ int main()
   240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
 };
 
+
 static uchar to_upper_utf8mb4[]=
 {
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
@@ -4394,6 +4665,7 @@ int main()
   240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
 };
 
+
 static inline int
 bincmp_utf8mb4(const uchar *s, const uchar *se,
                const uchar *t, const uchar *te)
@@ -4404,6 +4676,7 @@ int main()
   return cmp ? cmp : slen - tlen;
 }
 
+
 static int
 my_mb_wc_utf8mb4(CHARSET_INFO *cs __attribute__((unused)),
                  my_wc_t * pwc, const uchar *s, const uchar *e)
@@ -4455,13 +4728,13 @@ int main()
       UTF-8 quick four-byte mask:
       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
       Encoding allows to encode U+00010000..U+001FFFFF
-
+      
       The maximum character defined in the Unicode standard is U+0010FFFF.
       Higher characters U+00110000..U+001FFFFF are not used.
-
+      
       11110000.10010000.10xxxxxx.10xxxxxx == F0.90.80.80 == U+00010000 (min)
       11110100.10001111.10111111.10111111 == F4.8F.BF.BF == U+0010FFFF (max)
-
+      
       Valid codes:
       [F0][90..BF][80..BF][80..BF]
       [F1][80..BF][80..BF][80..BF]
@@ -4485,6 +4758,7 @@ int main()
   return MY_CS_ILSEQ;
 }
 
+
 /*
   The same as above, but without range check
   for example, for a null-terminated string
@@ -4513,7 +4787,7 @@ int main()
     *pwc = ((my_wc_t) (c & 0x1f) << 6) | (my_wc_t) (s[1] ^ 0x80);
     return 2;
   }
-
+  
   if (c < 0xf0)
   {
     if (!((s[1] ^ 0x80) < 0x40 &&
@@ -4543,6 +4817,7 @@ int main()
   return MY_CS_ILSEQ;
 }
 
+
 static int
 my_wc_mb_utf8mb4(CHARSET_INFO *cs __attribute__((unused)),
                  my_wc_t wc, uchar *r, uchar *e)
@@ -4575,6 +4850,7 @@ int main()
   return count;
 }
 
+
 /*
   The same as above, but without range check.
 */
@@ -4606,6 +4882,7 @@ int main()
   return count;
 }
 
+
 static inline void
 my_tolower_utf8mb4(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -4614,6 +4891,7 @@ int main()
     *wc= uni_plane[page][*wc & 0xFF].tolower;
 }
 
+
 static inline void
 my_toupper_utf8mb4(MY_UNICASE_INFO **uni_plane, my_wc_t *wc)
 {
@@ -4622,6 +4900,7 @@ int main()
     *wc= uni_plane[page][*wc & 0xFF].toupper;
 }
 
+
 static size_t
 my_caseup_utf8mb4(CHARSET_INFO *cs, char *src, size_t srclen,
                   char *dst, size_t dstlen)
@@ -4645,6 +4924,7 @@ int main()
   return (size_t) (dst - dst0);
 }
 
+
 static inline void
 my_hash_add(ulong *n1, ulong *n2, uint ch)
 {
@@ -4652,6 +4932,7 @@ int main()
   n2[0]+= 3;
 }
 
+
 static void
 my_hash_sort_utf8mb4(CHARSET_INFO *cs, const uchar *s, size_t slen,
                      ulong *n1, ulong *n2)
@@ -4688,6 +4969,7 @@ int main()
   }
 }
 
+
 static size_t
 my_caseup_str_utf8mb4(CHARSET_INFO *cs, char *src)
 {
@@ -4710,6 +4992,7 @@ int main()
   return (size_t) (dst - dst0);
 }
 
+
 static size_t
 my_casedn_utf8mb4(CHARSET_INFO *cs,
                   char *src, size_t srclen,
@@ -4734,6 +5017,7 @@ int main()
   return (size_t) (dst - dst0);
 }
 
+
 static size_t
 my_casedn_str_utf8mb4(CHARSET_INFO *cs, char *src)
 {
@@ -4772,6 +5056,7 @@ int main()
   return (size_t) (dst - dst0);
 }
 
+
 static int
 my_strnncoll_utf8mb4(CHARSET_INFO *cs,
                      const uchar *s, size_t slen,
@@ -4798,7 +5083,7 @@ int main()
 
     my_tosort_unicode(uni_plane, &s_wc);
     my_tosort_unicode(uni_plane, &t_wc);
-
+    
     if ( s_wc != t_wc )
     {
       return s_wc > t_wc ? 1 : -1;
@@ -4810,8 +5095,9 @@ int main()
   return (int) (t_is_prefix ? (t - te) : ((se - s) - (te - t)));
 }
 
-/**
 
+/**
+  
   Compare strings, discarding end space
 
   If one string is shorter as the other, then we space extend the other
@@ -4908,12 +5194,13 @@ int main()
     for ( ; s < se; s++)
     {
       if (*s != ' ')
-    return (*s < ' ') ? -swap : swap;
+	return (*s < ' ') ? -swap : swap;
     }
   }
   return res;
 }
 
+
 /**
   Compare 0-terminated UTF8 strings.
 
@@ -4934,10 +5221,10 @@ int main()
   while (s[0] && t[0])
   {
     my_wc_t s_wc,t_wc;
-
+    
     if ((uchar) s[0] < 128)
     {
-      /*
+      /* 
         s[0] is between 0 and 127.
         It represents a single byte character.
         Convert it into weight according to collation.
@@ -4948,20 +5235,21 @@ int main()
     else
     {
       int res= my_mb_wc_utf8mb4_no_range(cs, &s_wc, (const uchar*) s);
-
-      /*
+      
+      /* 
          In the case of wrong multibyte sequence we will
          call strcmp() for byte-to-byte comparison.
       */
       if (res <= 0)
         return strcmp(s, t);
       s+= res;
-
+      
       my_tolower_utf8mb4(uni_plane, &s_wc);
     }
-
+    
+    
     /* Do the same for the second string */
-
+    
     if ((uchar) t[0] < 128)
     {
       /* Convert single byte character into weight */
@@ -4974,10 +5262,10 @@ int main()
       if (res <= 0)
         return strcmp(s, t);
       t+= res;
-
+      
       my_tolower_utf8mb4(uni_plane, &t_wc);
     }
-
+    
     /* Now we have two weights, let's compare them */
     if ( s_wc != t_wc )
       return  ((int) s_wc) - ((int) t_wc);
@@ -4985,6 +5273,7 @@ int main()
   return ((int) (uchar) s[0]) - ((int) (uchar) t[0]);
 }
 
+
 static int
 my_wildcmp_utf8mb4(CHARSET_INFO *cs,
                    const char *str, const char *strend,
@@ -4992,9 +5281,10 @@ int main()
                    int escape, int w_one, int w_many)
 {
   return my_wildcmp_unicode(cs, str, strend, wildstr, wildend,
-                            escape, w_one, w_many, cs->caseinfo);
+                            escape, w_one, w_many, cs->caseinfo); 
 }
 
+
 static size_t
 my_strnxfrmlen_utf8mb4(CHARSET_INFO *cs __attribute__((unused)), size_t len)
 {
@@ -5002,6 +5292,7 @@ int main()
   return (len * 2 + 2) / 4;
 }
 
+
 static uint
 my_ismbchar_utf8mb4(CHARSET_INFO *cs, const char *b, const char *e)
 {
@@ -5010,6 +5301,7 @@ int main()
   return (res > 1) ? res : 0;
 }
 
+
 static uint
 my_mbcharlen_utf8mb4(CHARSET_INFO *cs  __attribute__((unused)), uint c)
 {
@@ -5026,6 +5318,7 @@ int main()
   return 0; /* Illegal mb head */;
 }
 
+
 static MY_COLLATION_HANDLER my_collation_utf8mb4_general_ci_handler=
 {
   NULL,               /* init */
@@ -5041,6 +5334,7 @@ int main()
   my_propagate_complex
 };
 
+
 static MY_COLLATION_HANDLER my_collation_utf8mb4_bin_handler =
 {
     NULL,		/* init */
@@ -5056,6 +5350,7 @@ int main()
     my_propagate_simple
 };
 
+
 MY_CHARSET_HANDLER my_charset_utf8mb4_handler=
 {
   NULL,               /* init */
@@ -5087,6 +5382,8 @@ int main()
   my_scan_8bit
 };
 
+
+
 CHARSET_INFO my_charset_utf8mb4_general_ci=
 {
   45,0,0,              /* number       */
@@ -5119,6 +5416,7 @@ int main()
   &my_collation_utf8mb4_general_ci_handler
 };
 
+
 CHARSET_INFO my_charset_utf8mb4_bin=
 {
   46,0,0,             /* number       */
@@ -5151,4 +5449,4 @@ int main()
   &my_collation_utf8mb4_bin_handler
 };
 
-#endif /* HAVE_CHARSET_utf8mb4 */
\ No newline at end of file
+#endif /* HAVE_CHARSET_utf8mb4 */
diff --git a/dep/mysqllite/strings/ctype-win1250ch.c b/dep/mysqllite/strings/ctype-win1250ch.c
index cb416c0..cbb1ad5 100644
--- a/dep/mysqllite/strings/ctype-win1250ch.c
+++ b/dep/mysqllite/strings/ctype-win1250ch.c
@@ -52,6 +52,7 @@
 
 #ifdef HAVE_CHARSET_cp1250
 
+
 static uint16 tab_cp1250_uni[256]={
      0,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,
 0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,
@@ -87,6 +88,7 @@
 0x0159,0x016F,0x00FA,0x0171,0x00FC,0x00FD,0x0163,0x02D9
 };
 
+
 /* 0000-00FD , 254 chars */
 static uchar tab_uni_cp1250_plane00[]={
 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
@@ -139,6 +141,7 @@
 static uchar tab_uni_cp1250_plane21[]={
 0x99};
 
+
 static MY_UNI_IDX idx_uni_cp1250[]={
   {0x0000,0x00FD,tab_uni_cp1250_plane00},
   {0x0102,0x017E,tab_uni_cp1250_plane01},
@@ -148,6 +151,7 @@
   {0,0,NULL}
 };
 
+
 static uchar ctype_win1250ch[] = {
 0x00,
 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
@@ -254,6 +258,8 @@
 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xff
 };
 
+
+
 static uchar sort_order_win1250ch[] = {
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
@@ -284,34 +290,34 @@
 /* 0 ord 48 0x30 */
 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
 0x9a, 0x9b,
-        /* colon ord 58 0x3a */
-        0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1,
+	    /* colon ord 58 0x3a */
+	    0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1,
 0xa2,
       /* A ord 65 0x41 */
       0xa4, 0xa5,
-          /* C ord 67 0x43 */
-          0xff, 0xa8, 0xa9, 0xaa, 0xab,
+		  /* C ord 67 0x43 */
+		  0xff, 0xa8, 0xa9, 0xaa, 0xab,
 0xac, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4,
 0xb5, 0xb6,
-        /* R ord 82 0x52 */
-        0xb7,
-          /* S ord 83 0x53 */
-          0xb9, 0xbc, 0xbd, 0xbe, 0xbf,
+	    /* R ord 82 0x52 */
+	    0xb7, 
+		  /* S ord 83 0x53 */
+		  0xb9, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2,
-          /* [ ord 91 0x5b */
-          0xc4, 0xc5, 0xc6, 0xc7, 0xc8,
+		  /* [ ord 91 0x5b */
+		  0xc4, 0xc5, 0xc6, 0xc7, 0xc8,
 0xc9,
       /* a ord 97 0x61 */
       0xa4, 0xa5, 0xff, 0xa8, 0xa9, 0xaa, 0xab,
 0xac, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4,
 0xb5, 0xb6, 0xb7, 0xb9, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2,
-          /* { ord 123 0x7b */
-          0xca, 0xcb, 0xcc, 0xcd, 0x81,
+		  /* { ord 123 0x7b */
+		  0xca, 0xcb, 0xcc, 0xcd, 0x81,
 0x81, 0x81, 0xce, 0x81, 0xcf, 0xd0, 0xd1, 0xd2,
 0x81, 0xd3,
-        /* Scaron ord 138 0x8a */
-        0xba, 0xd4, 0xb9, 0xbc, 0xc3, 0xc2,
+	    /* Scaron ord 138 0x8a */
+	    0xba, 0xd4, 0xb9, 0xbc, 0xc3, 0xc2,
 0x81, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
 0x81, 0xdc, 0xba, 0xdd, 0xb9, 0xbc, 0xc3, 0xc2,
 /* nobreakspace ord 160 0xa0 */
@@ -344,34 +350,34 @@
 /* 0 ord 48 0x30 */
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x01, 0x01,
-        /* colon ord 58 0x3a */
-        0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
+	    /* colon ord 58 0x3a */
+	    0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x01,
       /* A ord 65 0x41 */
       0x01, 0x01,
-          /* C ord 67 0x43 */
-          0xff, 0x01, 0x01, 0x01, 0x01,
+		  /* C ord 67 0x43 */
+		  0xff, 0x01, 0x01, 0x01, 0x01,
 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x01, 0x01,
-        /* R ord 82 0x52 */
-        0x01,
-          /* S ord 83 0x53 */
-          0x01, 0x01, 0x01, 0x01, 0x01,
+	    /* R ord 82 0x52 */
+	    0x01, 
+		  /* S ord 83 0x53 */
+		  0x01, 0x01, 0x01, 0x01, 0x01,
 0x01, 0x01, 0x01,
-          /* [ ord 91 0x5b */
-          0x01, 0x01, 0x01, 0x01, 0x01,
+		  /* [ ord 91 0x5b */
+		  0x01, 0x01, 0x01, 0x01, 0x01,
 0x01,
       /* a ord 97 0x61 */
       0x02, 0x02, 0xff, 0x02, 0x02, 0x02, 0x02,
 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
 0x02, 0x02, 0x02,
-          /* { ord 123 0x7b */
-          0x01, 0x01, 0x01, 0x01, 0x22,
+		  /* { ord 123 0x7b */
+		  0x01, 0x01, 0x01, 0x01, 0x22,
 0x23, 0x24, 0x01, 0x25, 0x01, 0x01, 0x01, 0x01,
 0x26, 0x01,
-        /* Scaron ord 138 0x8a */
-        0x01, 0x01, 0x03, 0x03, 0x01, 0x05,
+	    /* Scaron ord 138 0x8a */
+	    0x01, 0x01, 0x03, 0x03, 0x01, 0x05,
 0x27, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
 0x28, 0x01, 0x02, 0x01, 0x04, 0x04, 0x02, 0x06,
 /* nobreakspace ord 160 0xa0 */
@@ -394,53 +400,53 @@
 };
 
 struct wordvalue {
-    const uchar *word;
-    uchar pass1;
-    uchar pass2;
+	const uchar *word;
+	uchar pass1;
+	uchar pass2;
 };
 static struct wordvalue doubles[] = {
-    { (uchar*) "ch", 0xad, 0x03 },
-    { (uchar*) "c",  0xa6, 0x02 },
-    { (uchar*) "Ch", 0xad, 0x02 },
-    { (uchar*) "CH", 0xad, 0x01 },
-    { (uchar*) "C",  0xa6, 0x01 },
+	{ (uchar*) "ch", 0xad, 0x03 },
+	{ (uchar*) "c",  0xa6, 0x02 },
+	{ (uchar*) "Ch", 0xad, 0x02 },
+	{ (uchar*) "CH", 0xad, 0x01 },
+	{ (uchar*) "C",  0xa6, 0x01 },
 };
 
 #define NEXT_CMP_VALUE(src, p, pass, value, len)			\
-    while (1) {							\
-        if (IS_END(p, src, len)) {				\
-            if (pass == 0 && len > 0) { p= src; pass++; }	\
-            else { value = 0; break; }			\
-        }							\
-        value = ((pass == 0) ? _sort_order_win1250ch1[*p]	\
-            : _sort_order_win1250ch2[*p]);			\
-        if (value == 0xff) {					\
-            int i;						\
-            for (i = 0; i < (int) sizeof(doubles); i++) {	\
-                const uchar *patt = doubles[i].word;	\
-                const uchar *q = (const uchar *) p;	\
-                while (*patt				\
-                    && !(IS_END(q, src, len))	\
-                    && (*patt == *q)) {		\
-                    patt++; q++;			\
-                }					\
-                if (!(*patt)) {				\
-                    value = (int)((pass == 0)	\
-                        ? doubles[i].pass1	\
-                        : doubles[i].pass2);	\
-                    p = (const uchar *) q - 1;	\
-                    break;				\
-                }					\
-            }						\
-        }							\
-        p++;							\
-        break;							\
-    }
+	while (1) {							\
+		if (IS_END(p, src, len)) {				\
+			if (pass == 0 && len > 0) { p= src; pass++; }	\
+			else { value = 0; break; }			\
+		}							\
+		value = ((pass == 0) ? _sort_order_win1250ch1[*p]	\
+			: _sort_order_win1250ch2[*p]);			\
+		if (value == 0xff) {					\
+			int i;						\
+			for (i = 0; i < (int) sizeof(doubles); i++) {	\
+				const uchar *patt = doubles[i].word;	\
+				const uchar *q = (const uchar *) p;	\
+				while (*patt				\
+					&& !(IS_END(q, src, len))	\
+					&& (*patt == *q)) {		\
+					patt++; q++;			\
+				}					\
+				if (!(*patt)) {				\
+					value = (int)((pass == 0)	\
+						? doubles[i].pass1	\
+						: doubles[i].pass2);	\
+					p = (const uchar *) q - 1;	\
+					break;				\
+				}					\
+			}						\
+		}							\
+		p++;							\
+		break;							\
+	}
 
 #define IS_END(p, src, len)	(((char *)p - (char *)src) >= (len))
 
-static int my_strnncoll_win1250ch(CHARSET_INFO *cs __attribute__((unused)),
-                  const uchar *s1, size_t len1,
+static int my_strnncoll_win1250ch(CHARSET_INFO *cs __attribute__((unused)), 
+				  const uchar *s1, size_t len1,
                                   const uchar *s2, size_t len2,
                                   my_bool s2_is_prefix)
 {
@@ -464,14 +470,15 @@ static int my_strnncoll_win1250ch(CHARSET_INFO *cs __attribute__((unused)),
   return 0;
 }
 
+
 /*
   TODO: Has to be fixed as strnncollsp in ctype-simple
 */
 
 static
-int my_strnncollsp_win1250ch(CHARSET_INFO * cs,
-                 const uchar *s, size_t slen,
-                 const uchar *t, size_t tlen,
+int my_strnncollsp_win1250ch(CHARSET_INFO * cs, 
+			     const uchar *s, size_t slen, 
+			     const uchar *t, size_t tlen,
                              my_bool diff_if_only_endspace_difference
                              __attribute__((unused)))
 {
@@ -480,8 +487,9 @@ int my_strnncollsp_win1250ch(CHARSET_INFO * cs,
   return my_strnncoll_win1250ch(cs,s,slen,t,tlen,0);
 }
 
+
 static size_t my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
-                                    uchar *dest, size_t len,
+                                    uchar *dest, size_t len, 
                                     const uchar *src, size_t srclen)
 {
   int value;
@@ -607,12 +615,13 @@ static size_t my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
 
 static my_bool
 my_like_range_win1250ch(CHARSET_INFO *cs __attribute__((unused)),
-            const char *ptr, size_t ptr_length,
-            pbool escape, pbool w_one, pbool w_many,
-            size_t res_length,
-            char *min_str, char *max_str,
-            size_t *min_length, size_t *max_length)
+			const char *ptr, size_t ptr_length,
+			pbool escape, pbool w_one, pbool w_many,
+			size_t res_length,
+			char *min_str, char *max_str,
+			size_t *min_length, size_t *max_length)
 {
+
   int only_min_found= 1;
   const char *end = ptr + ptr_length;
   char *min_org = min_str;
@@ -651,6 +660,7 @@ static size_t my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
   return (only_min_found);
 }
 
+
 static MY_COLLATION_HANDLER my_collation_czech_ci_handler =
 {
   NULL,				/* init */
@@ -666,6 +676,7 @@ static size_t my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
   my_propagate_simple
 };
 
+
 CHARSET_INFO my_charset_cp1250_czech_ci =
 {
   34,0,0,                                     /* number    */
@@ -698,6 +709,7 @@ static size_t my_strnxfrm_win1250ch(CHARSET_INFO * cs  __attribute__((unused)),
   &my_collation_czech_ci_handler
 };
 
+
 #endif /* REAL_MYSQL */
 
-#endif /* HAVE_CHARSET_cp1250 */
\ No newline at end of file
+#endif /* HAVE_CHARSET_cp1250 */
diff --git a/dep/mysqllite/strings/ctype.c b/dep/mysqllite/strings/ctype.c
index 8181b16..91d28d1 100644
--- a/dep/mysqllite/strings/ctype.c
+++ b/dep/mysqllite/strings/ctype.c
@@ -21,22 +21,23 @@
 #include <m_string.h>
 #endif
 
+
 /*
 
   This files implements routines which parse XML based
   character set and collation description files.
-
+  
   Unicode collations are encoded according to
-
+  
     Unicode Technical Standard #35
     Locale Data Markup Language (LDML)
     http://www.unicode.org/reports/tr35/
-
+  
   and converted into ICU string according to
-
+  
     Collation Customization
     http://oss.software.ibm.com/icu/userguide/Collate_Customization.html
-
+  
 */
 
 static char *mstr(char *str,const char *src,size_t l1,size_t l2)
@@ -76,6 +77,7 @@ struct my_cs_file_section_st
 #define	_CS_DIFF3	21
 #define	_CS_IDENTICAL	22
 
+
 static struct my_cs_file_section_st sec[] =
 {
   {_CS_MISC,		"xml"},
@@ -142,13 +144,15 @@ static struct my_cs_file_section_st * cs_file_sec(const char *attr, size_t len)
   int (*add_collation)(CHARSET_INFO *cs);
 } MY_CHARSET_LOADER;
 
+
+
 static int fill_uchar(uchar *a,uint size,const char *str, size_t len)
 {
   uint i= 0;
   const char *s, *b, *e=str+len;
-
+  
   for (s=str ; s < e ; i++)
-  {
+  { 
     for ( ; (s < e) && strchr(" \t\r\n",s[0]); s++) ;
     b=s;
     for ( ; (s < e) && !strchr(" \t\r\n",s[0]); s++) ;
@@ -162,10 +166,10 @@ static int fill_uchar(uchar *a,uint size,const char *str, size_t len)
 static int fill_uint16(uint16 *a,uint size,const char *str, size_t len)
 {
   uint i= 0;
-
+  
   const char *s, *b, *e=str+len;
   for (s=str ; s < e ; i++)
-  {
+  { 
     for ( ; (s < e) && strchr(" \t\r\n",s[0]); s++) ;
     b=s;
     for ( ; (s < e) && !strchr(" \t\r\n",s[0]); s++) ;
@@ -176,27 +180,29 @@ static int fill_uint16(uint16 *a,uint size,const char *str, size_t len)
   return 0;
 }
 
+
 static int cs_enter(MY_XML_PARSER *st,const char *attr, size_t len)
 {
   struct my_cs_file_info *i= (struct my_cs_file_info *)st->user_data;
   struct my_cs_file_section_st *s= cs_file_sec(attr,len);
-
+  
   if ( s && (s->state == _CS_CHARSET))
     bzero(&i->cs,sizeof(i->cs));
-
+  
   if (s && (s->state == _CS_COLLATION))
     i->tailoring_length= 0;
 
   return MY_XML_OK;
 }
 
+
 static int cs_leave(MY_XML_PARSER *st,const char *attr, size_t len)
 {
   struct my_cs_file_info *i= (struct my_cs_file_info *)st->user_data;
   struct my_cs_file_section_st *s= cs_file_sec(attr,len);
   int    state= s ? s->state : 0;
   int    rc;
-
+  
   switch(state){
   case _CS_COLLATION:
     rc= i->add_collation ? i->add_collation(&i->cs) : MY_XML_OK;
@@ -207,13 +213,14 @@ static int cs_leave(MY_XML_PARSER *st,const char *attr, size_t len)
   return rc;
 }
 
+
 static int cs_value(MY_XML_PARSER *st,const char *attr, size_t len)
 {
   struct my_cs_file_info *i= (struct my_cs_file_info *)st->user_data;
   struct my_cs_file_section_st *s;
   int    state= (int)((s=cs_file_sec(st->attr, strlen(st->attr))) ? s->state :
                       0);
-
+  
   switch (state) {
   case _CS_ID:
     i->cs.number= strtol(attr,(char**)NULL,10);
@@ -286,13 +293,14 @@ static int cs_value(MY_XML_PARSER *st,const char *attr, size_t len)
   return MY_XML_OK;
 }
 
+
 my_bool my_parse_charset_xml(const char *buf, size_t len,
                              int (*add_collation)(CHARSET_INFO *cs))
 {
   MY_XML_PARSER p;
   struct my_cs_file_info i;
   my_bool rc;
-
+  
   my_xml_parser_create(&p);
   my_xml_set_enter_handler(&p,cs_enter);
   my_xml_set_value_handler(&p,cs_value);
@@ -304,6 +312,7 @@ my_bool my_parse_charset_xml(const char *buf, size_t len,
   return rc;
 }
 
+
 /*
   Check repertoire: detect pure ascii strings
 */
@@ -334,6 +343,7 @@ my_bool my_parse_charset_xml(const char *buf, size_t len,
   return MY_REPERTOIRE_ASCII;
 }
 
+
 /*
   Returns repertoire for charset
 */
@@ -343,28 +353,29 @@ uint my_charset_repertoire(CHARSET_INFO *cs)
     MY_REPERTOIRE_ASCII : MY_REPERTOIRE_UNICODE30;
 }
 
+
 /*
   Detect whether a character set is ASCII compatible.
 
   Returns TRUE for:
-
+  
   - all 8bit character sets whose Unicode mapping of 0x7B is '{'
     (ignores swe7 which maps 0x7B to "LATIN LETTER A WITH DIAERESIS")
-
+  
   - all multi-byte character sets having mbminlen == 1
     (ignores ucs2 whose mbminlen is 2)
-
+  
   TODO:
-
+  
   When merging to 5.2, this function should be changed
-  to check a new flag MY_CS_NONASCII,
-
+  to check a new flag MY_CS_NONASCII, 
+  
      return (cs->flag & MY_CS_NONASCII) ? 0 : 1;
-
+  
   This flag was previously added into 5.2 under terms
   of WL#3759 "Optimize identifier conversion in client-server protocol"
   especially to mark character sets not compatible with ASCII.
-
+  
   We won't backport this flag to 5.0 or 5.1.
   This function is Ok for 5.0 and 5.1, because we're not going
   to introduce new tricky character sets between 5.0 and 5.2.
@@ -372,11 +383,12 @@ uint my_charset_repertoire(CHARSET_INFO *cs)
 my_bool
 my_charset_is_ascii_based(CHARSET_INFO *cs)
 {
-  return
+  return 
     (cs->mbmaxlen == 1 && cs->tab_to_uni && cs->tab_to_uni['{'] == '{') ||
     (cs->mbminlen == 1 && cs->mbmaxlen > 1);
 }
 
+
 /*
   Detect if a character set is 8bit,
   and it is pure ascii, i.e. doesn't have
@@ -398,6 +410,7 @@ uint my_charset_repertoire(CHARSET_INFO *cs)
   return 1;
 }
 
+
 /*
   Shared function between conf_to_src and mysys.
   Check if a 8bit character set is compatible with
@@ -415,4 +428,4 @@ uint my_charset_repertoire(CHARSET_INFO *cs)
       return 0;
   }
   return 1;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/decimal.c b/dep/mysqllite/strings/decimal.c
index c2fadde..3a17072 100644
--- a/dep/mysqllite/strings/decimal.c
+++ b/dep/mysqllite/strings/decimal.c
@@ -247,6 +247,7 @@ void max_decimal(int precision, int frac, decimal_t *to)
   }
 }
 
+
 static dec1 *remove_leading_zeroes(const decimal_t *from, int *intg_result)
 {
   int intg= from->intg, i;
@@ -269,6 +270,7 @@ static dec1 *remove_leading_zeroes(const decimal_t *from, int *intg_result)
   return buf0;
 }
 
+
 /*
   Count actual length of fraction part (without ending zeroes)
 
@@ -301,6 +303,7 @@ int decimal_actual_fraction(decimal_t *from)
   return frac;
 }
 
+
 /*
   Convert decimal to its printable string representation
 
@@ -429,6 +432,7 @@ int decimal2string(const decimal_t *from, char *to, int *to_len,
   return error;
 }
 
+
 /*
   Return bounds of decimal digits in the number
 
@@ -493,6 +497,7 @@ static void digits_bounds(decimal_t *from, int *start_result, int *end_result)
   *end_result= stop; /* index of position after last decimal digit (from 0) */
 }
 
+
 /*
   Left shift for alignment of data in buffer
 
@@ -522,6 +527,7 @@ void do_mini_left_shift(decimal_t *dec, int shift, int beg, int last)
   *from= (*from % powers10[c_shift]) * powers10[shift];
 }
 
+
 /*
   Right shift for alignment of data in buffer
 
@@ -551,6 +557,7 @@ void do_mini_right_shift(decimal_t *dec, int shift, int beg, int last)
   *from= *from / powers10[shift];
 }
 
+
 /*
   Shift of decimal digits in given number (with rounding if it need)
 
@@ -732,7 +739,7 @@ int decimal_shift(decimal_t *dec, int shift)
   beg= ROUND_UP(beg + 1) - 1;
   end= ROUND_UP(end) - 1;
   DBUG_ASSERT(new_point >= 0);
-
+  
   /* We don't want negative new_point below */
   if (new_point != 0)
     new_point= ROUND_UP(new_point) - 1;
@@ -754,6 +761,7 @@ int decimal_shift(decimal_t *dec, int shift)
   return err;
 }
 
+
 /*
   Convert string to decimal
 
@@ -763,7 +771,7 @@ int decimal_shift(decimal_t *dec, int shift)
       to      - decimal where where the result will be stored
                 to->buf and to->len must be set.
       end     - Pointer to pointer to end of string. Will on return be
-        set to the char after the last used character
+		set to the char after the last used character
       fixed   - use to->intg, to->frac as limits for input number
 
   NOTE
@@ -922,6 +930,7 @@ int decimal_shift(decimal_t *dec, int shift)
   return error;
 }
 
+
 /*
   Convert decimal to double
 
@@ -975,6 +984,7 @@ int double2decimal(double from, decimal_t *to)
   DBUG_RETURN(res);
 }
 
+
 static int ull2dec(ulonglong from, decimal_t *to)
 {
   int intg1, error=E_DEC_OK;
@@ -1141,6 +1151,7 @@ int decimal2longlong(decimal_t *from, longlong *to)
     now, middle decimal_digit_t is full - it stores 9 decimal digits. It goes
     into binary representation as is:
 
+
       ...........  0D-FB-38-D2 ............
 
     First decimal_digit_t has only one decimal digit. We can store one digit in
@@ -1392,11 +1403,18 @@ int bin2decimal(const uchar *from, decimal_t *to, int precision, int scale)
     buf++;
   }
   my_afree(d_copy);
+
+  /*
+    No digits? We have read the number zero, of unspecified precision.
+    Make it a proper zero, with non-zero precision.
+  */
+  if (to->intg == 0 && to->frac == 0)
+    decimal_make_zero(to);
   return error;
 
 err:
   my_afree(d_copy);
-  decimal_make_zero(((decimal_t*) to));
+  decimal_make_zero(to);
   return(E_DEC_BAD_NUM);
 }
 
@@ -1456,9 +1474,8 @@ int decimal_bin_size(int precision, int scale)
 {
   int frac0=scale>0 ? ROUND_UP(scale) : scale/DIG_PER_DEC1,
     frac1=ROUND_UP(from->frac), UNINIT_VAR(round_digit),
-      intg0=ROUND_UP(from->intg), error=E_DEC_OK, len=to->len,
-      intg1=ROUND_UP(from->intg +
-                     (((intg0 + frac0)>0) && (from->buf[0] == DIG_MAX)));
+    intg0=ROUND_UP(from->intg), error=E_DEC_OK, len=to->len;
+
   dec1 *buf0=from->buf, *buf1=to->buf, x, y, carry=0;
   int first_dig;
 
@@ -1473,6 +1490,12 @@ int decimal_bin_size(int precision, int scale)
   default: DBUG_ASSERT(0);
   }
 
+  /*
+    For my_decimal we always use len == DECIMAL_BUFF_LENGTH == 9
+    For internal testing here (ifdef MAIN) we always use len == 100/4
+   */
+  DBUG_ASSERT(from->len == to->len);
+
   if (unlikely(frac0+intg0 > len))
   {
     frac0=len-intg0;
@@ -1486,17 +1509,17 @@ int decimal_bin_size(int precision, int scale)
     return E_DEC_OK;
   }
 
-  if (to != from || intg1>intg0)
+  if (to != from)
   {
     dec1 *p0= buf0+intg0+max(frac1, frac0);
-    dec1 *p1= buf1+intg1+max(frac1, frac0);
+    dec1 *p1= buf1+intg0+max(frac1, frac0);
+
+    DBUG_ASSERT(p0 - buf0 <= len);
+    DBUG_ASSERT(p1 - buf1 <= len);
 
     while (buf0 < p0)
       *(--p1) = *(--p0);
-    if (unlikely(intg1 > intg0))
-      to->buf[0]= 0;
 
-    intg0= intg1;
     buf0=to->buf;
     buf1=to->buf;
     to->sign=from->sign;
@@ -2171,7 +2194,6 @@ static int do_div_mod(const decimal_t *from1, const decimal_t *from2,
   }
   buf0=to->buf;
   stop0=buf0+intg0+frac0;
-  DBUG_ASSERT(stop0 <= &to->buf[to->len]);
   if (likely(div_mod))
     while (dintg++ < 0 && buf0 < &to->buf[to->len])
     {
@@ -2266,7 +2288,10 @@ static int do_div_mod(const decimal_t *from1, const decimal_t *from2,
       }
     }
     if (likely(div_mod))
+    {
+      DBUG_ASSERT(buf0 < to->buf + to->len);
       *buf0=(dec1)guess;
+    }
     dcarry= *start1;
     start1++;
   }
@@ -2401,6 +2426,7 @@ void dump_decimal(decimal_t *d)
   printf("%09d} */ ", d->buf[i]);
 }
 
+
 void check_result_code(int actual, int want)
 {
   if (actual != want)
@@ -2410,6 +2436,7 @@ void check_result_code(int actual, int want)
   }
 }
 
+
 void print_decimal(decimal_t *d, const char *orig, int actual, int want)
 {
   char s[100];
@@ -2703,6 +2730,7 @@ void test_ro(const char *s1, int n, decimal_round_mode mode, const char *orig,
   printf("\n");
 }
 
+
 void test_mx(int precision, int frac, const char *orig)
 {
   char s[100];
@@ -2713,6 +2741,7 @@ void test_mx(int precision, int frac, const char *orig)
   printf("\n");
 }
 
+
 void test_pr(const char *s1, int prec, int dec, char filler, const char *orig,
              int ex)
 {
@@ -2736,6 +2765,7 @@ void test_pr(const char *s1, int prec, int dec, char filler, const char *orig,
   printf("\n");
 }
 
+
 void test_sh(const char *s1, int shift, const char *orig, int ex)
 {
   char s[100], *end;
@@ -2749,6 +2779,7 @@ void test_sh(const char *s1, int shift, const char *orig, int ex)
   printf("\n");
 }
 
+
 void test_fr(const char *s1, const char *orig)
 {
   char s[100], *end;
@@ -2761,6 +2792,7 @@ void test_fr(const char *s1, const char *orig)
   printf("\n");
 }
 
+
 int main()
 {
   a.buf=(void*)buf1;
@@ -2917,6 +2949,7 @@ int main()
   test_d2b2d("000000000.01", 7, 3,"0.010", 0);
   test_d2b2d("123.4", 10, 2, "123.40", 0);
 
+
   printf("==== decimal_cmp ====\n");
   test_dc("12","13",-1);
   test_dc("13","12",1);
@@ -3109,4 +3142,4 @@ int main()
 
   return 0;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/dtoa.c b/dep/mysqllite/strings/dtoa.c
index cc4639e..4086bf4 100644
--- a/dep/mysqllite/strings/dtoa.c
+++ b/dep/mysqllite/strings/dtoa.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+/* Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -46,7 +46,7 @@
      see if it is possible to get rid of malloc().
      this constant is sufficient to avoid malloc() on all inputs I have tried.
 */
-#define DTOA_BUFF_SIZE (420 * sizeof(void *))
+#define DTOA_BUFF_SIZE (460 * sizeof(void *))
 
 /* Magic value returned by dtoa() to indicate overflow */
 #define DTOA_OVERFLOW 9999
@@ -92,7 +92,7 @@ size_t my_fcvt(double x, int precision, char *to, my_bool *error)
   char *res, *src, *end, *dst= to;
   char buf[DTOA_BUFF_SIZE];
   DBUG_ASSERT(precision >= 0 && precision < NOT_FIXED_DEC && to != NULL);
-
+  
   res= dtoa(x, 5, precision, &decpt, &sign, &end, buf, sizeof(buf));
 
   if (decpt == DTOA_OVERFLOW)
@@ -132,11 +132,11 @@ size_t my_fcvt(double x, int precision, char *to, my_bool *error)
   {
     if (len <= decpt)
       *dst++= '.';
-
+    
     for (i= precision - max(0, (len - decpt)); i > 0; i--)
       *dst++= '0';
   }
-
+  
   *dst= '\0';
   if (error != NULL)
     *error= FALSE;
@@ -199,12 +199,12 @@ size_t my_fcvt(double x, int precision, char *to, my_bool *error)
      my_gcvt(55, ..., 1, ...);
 
    We do our best to minimize such cases by:
-
+   
    - passing to dtoa() the field width as the number of significant digits
-
+   
    - removing the sign of the number early (and decreasing the width before
      passing it to dtoa())
-
+   
    - choosing the proper format to preserve the most number of significant
      digits.
 */
@@ -217,7 +217,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
   char buf[DTOA_BUFF_SIZE];
   my_bool have_space, force_e_format;
   DBUG_ASSERT(width > 0 && to != NULL);
-
+  
   /* We want to remove '-' from equations early */
   if (x < 0.)
     width--;
@@ -246,7 +246,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
      to count it here.
    */
   exp_len= 1 + (decpt >= 101 || decpt <= -99) + (decpt >= 11 || decpt <= -9);
-
+  
   /*
      Do we have enough space for all digits in the 'f' format?
      Let 'len' be the number of significant digits returned by dtoa,
@@ -299,7 +299,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
        ((decpt <= width && (decpt >= -1 || (decpt == -2 &&
                                             (len > 1 || !force_e_format)))) &&
          !force_e_format)) &&
-
+      
        /*
          Use the 'e' format in some cases even if we have enough space for the
          'f' one. See comment for MAX_DECPT_FOR_F_FORMAT.
@@ -321,7 +321,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
           *error= TRUE;
         width= decpt;
       }
-
+      
       /*
         We want to truncate (len - width) least significant digits after the
         decimal point. For this we are calling dtoa with mode=5, passing the
@@ -339,7 +339,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
       *dst++= '0';
       goto end;
     }
-
+    
     /*
       At this point we are sure we have enough space to put all digits
       returned by dtoa
@@ -388,7 +388,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
         *error= TRUE;
       width= 0;
     }
-
+      
     /* Do we have to truncate any digits? */
     if (width < len)
     {
@@ -430,6 +430,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
       *dst++= decpt / 10 + '0';
     if (dst < dend)
       *dst++= decpt % 10 + '0';
+
   }
 
 end:
@@ -452,7 +453,7 @@ size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
                   rejected character.
    @param error   Upon return is set to EOVERFLOW in case of underflow or
                   overflow.
-
+   
    @return        The resulting double value. In case of underflow, 0.0 is
                   returned. In case overflow, signed DBL_MAX is returned.
 */
@@ -469,6 +470,7 @@ double my_strtod(const char *str, char **end, int *error)
   return (*error == 0) ? res : (res < 0 ? -DBL_MAX : DBL_MAX);
 }
 
+
 double my_atof(const char *nptr)
 {
   int error;
@@ -476,6 +478,7 @@ double my_atof(const char *nptr)
   return (my_strtod(nptr, (char**) &end, &error));
 }
 
+
 /****************************************************************
  *
  * The author of this software is David M. Gay.
@@ -517,6 +520,7 @@ double my_atof(const char *nptr)
     the one generated on the fly.
 */
 
+
 /*
   On a machine with IEEE extended-precision registers, it is
   necessary to specify double-precision (53-bit) rounding precision
@@ -629,6 +633,7 @@ double my_atof(const char *nptr)
   int wds;                 /* current length in 32-bit words */
 } Bigint;
 
+
 /* A simple stack-memory based allocator for Bigints */
 
 typedef struct Stack_alloc
@@ -643,6 +648,7 @@ double my_atof(const char *nptr)
   Bigint *freelist[Kmax+1];
 } Stack_alloc;
 
+
 /*
   Try to allocate object on stack, and resort to malloc if all
   stack memory is used. Ensure allocated objects to be aligned by the pointer
@@ -653,6 +659,7 @@ double my_atof(const char *nptr)
 static Bigint *Balloc(int k, Stack_alloc *alloc)
 {
   Bigint *rv;
+  DBUG_ASSERT(k <= Kmax);
   if (k <= Kmax &&  alloc->freelist[k])
   {
     rv= alloc->freelist[k];
@@ -681,6 +688,7 @@ static Bigint *Balloc(int k, Stack_alloc *alloc)
   return rv;
 }
 
+
 /*
   If object was allocated on stack, try putting it to the free
   list. Otherwise call free().
@@ -703,6 +711,7 @@ static void Bfree(Bigint *v, Stack_alloc *alloc)
   }
 }
 
+
 /*
   This is to place return value of dtoa in: tries to use stack
   as well, but passes by free lists management and just aligns len by
@@ -724,6 +733,7 @@ static char *dtoa_alloc(int i, Stack_alloc *alloc)
   return rv;
 }
 
+
 /*
   dtoa_free() must be used to free values s returned by dtoa()
   This is the counterpart of dtoa_alloc()
@@ -735,6 +745,7 @@ static void dtoa_free(char *gptr, char *buf, size_t buf_size)
     free(gptr);
 }
 
+
 /* Bigint arithmetic functions */
 
 /* Multiply by m and add a */
@@ -772,6 +783,20 @@ static Bigint *multadd(Bigint *b, int m, int a, Stack_alloc *alloc)
   return b;
 }
 
+/**
+  Converts a string to Bigint.
+  
+  Now we have nd0 digits, starting at s, followed by a
+  decimal point, followed by nd-nd0 digits.  
+  Unless nd0 == nd, in which case we have a number of the form:
+     ".xxxxxx"    or    "xxxxxx."
+
+  @param s     Input string, already partially parsed by my_strtod_int().
+  @param nd0   Number of digits before decimal point.
+  @param nd    Total number of digits.
+  @param y9    Pre-computed value of the first nine digits.
+  @param alloc Stack allocator for Bigints.
+ */
 static Bigint *s2b(const char *s, int nd0, int nd, ULong y9, Stack_alloc *alloc)
 {
   Bigint *b;
@@ -783,7 +808,7 @@ static Bigint *s2b(const char *s, int nd0, int nd, ULong y9, Stack_alloc *alloc)
   b= Balloc(k, alloc);
   b->p.x[0]= y9;
   b->wds= 1;
-
+  
   i= 9;
   if (9 < nd0)
   {
@@ -791,15 +816,17 @@ static Bigint *s2b(const char *s, int nd0, int nd, ULong y9, Stack_alloc *alloc)
     do
       b= multadd(b, 10, *s++ - '0', alloc);
     while (++i < nd0);
-    s++;
+    s++;                                        /* skip '.' */
   }
   else
     s+= 10;
+  /* now do the fractional part */
   for(; i < nd; i++)
     b= multadd(b, 10, *s++ - '0', alloc);
   return b;
 }
 
+
 static int hi0bits(register ULong x)
 {
   register int k= 0;
@@ -833,6 +860,7 @@ static int hi0bits(register ULong x)
   return k;
 }
 
+
 static int lo0bits(ULong *y)
 {
   register int k;
@@ -882,6 +910,7 @@ static int lo0bits(ULong *y)
   return k;
 }
 
+
 /* Convert integer to Bigint number */
 
 static Bigint *i2b(int i, Stack_alloc *alloc)
@@ -894,6 +923,7 @@ static Bigint *i2b(int i, Stack_alloc *alloc)
   return b;
 }
 
+
 /* Multiply two Bigint numbers */
 
 static Bigint *mult(Bigint *a, Bigint *b, Stack_alloc *alloc)
@@ -946,6 +976,7 @@ static Bigint *mult(Bigint *a, Bigint *b, Stack_alloc *alloc)
   return c;
 }
 
+
 /*
   Precalculated array of powers of 5: tested to be enough for
   vasting majority of dtoa_r cases.
@@ -972,6 +1003,7 @@ static Bigint *mult(Bigint *a, Bigint *b, Stack_alloc *alloc)
   2161952759UL, 4100910556UL, 1608314830UL, 349175UL
 };
 
+
 static Bigint p5_a[]=
 {
   /*  { x } - k - maxwds - sign - wds */
@@ -988,9 +1020,10 @@ static Bigint *mult(Bigint *a, Bigint *b, Stack_alloc *alloc)
 
 static Bigint *pow5mult(Bigint *b, int k, Stack_alloc *alloc)
 {
-  Bigint *b1, *p5, *p51;
+  Bigint *b1, *p5, *p51=NULL;
   int i;
   static int p05[3]= { 5, 25, 125 };
+  my_bool overflow= FALSE;
 
   if ((i= k & 3))
     b= multadd(b, p05[i-1], 0, alloc);
@@ -1009,20 +1042,26 @@ static Bigint *pow5mult(Bigint *b, int k, Stack_alloc *alloc)
     if (!(k>>= 1))
       break;
     /* Calculate next power of 5 */
-    if (p5 < p5_a + P5A_MAX)
-      ++p5;
-    else if (p5 == p5_a + P5A_MAX)
-      p5= mult(p5, p5, alloc);
-    else
+    if (overflow)
     {
       p51= mult(p5, p5, alloc);
       Bfree(p5, alloc);
       p5= p51;
     }
+    else if (p5 < p5_a + P5A_MAX)
+      ++p5;
+    else if (p5 == p5_a + P5A_MAX)
+    {
+      p5= mult(p5, p5, alloc);
+      overflow= TRUE;
+    }
   }
+  if (p51)
+    Bfree(p51, alloc);
   return b;
 }
 
+
 static Bigint *lshift(Bigint *b, int k, Stack_alloc *alloc)
 {
   int i, k1, n, n1;
@@ -1062,6 +1101,7 @@ static Bigint *lshift(Bigint *b, int k, Stack_alloc *alloc)
   return b1;
 }
 
+
 static int cmp(Bigint *a, Bigint *b)
 {
   ULong *xa, *xa0, *xb, *xb0;
@@ -1085,6 +1125,7 @@ static int cmp(Bigint *a, Bigint *b)
   return 0;
 }
 
+
 static Bigint *diff(Bigint *a, Bigint *b, Stack_alloc *alloc)
 {
   Bigint *c;
@@ -1138,6 +1179,7 @@ static Bigint *diff(Bigint *a, Bigint *b, Stack_alloc *alloc)
   return c;
 }
 
+
 static double ulp(U *x)
 {
   register Long L;
@@ -1149,6 +1191,7 @@ static double ulp(U *x)
   return dval(&u);
 }
 
+
 static double b2d(Bigint *a, int *e)
 {
   ULong *xa, *xa0, w, y, z;
@@ -1187,6 +1230,7 @@ static double b2d(Bigint *a, int *e)
   return dval(&d);
 }
 
+
 static Bigint *d2b(U *d, int *e, int *bits, Stack_alloc *alloc)
 {
   Bigint *b;
@@ -1236,6 +1280,7 @@ static Bigint *d2b(U *d, int *e, int *bits, Stack_alloc *alloc)
 #undef d1
 }
 
+
 static double ratio(Bigint *a, Bigint *b)
 {
   U da, db;
@@ -1267,7 +1312,7 @@ static double ratio(Bigint *a, Bigint *b)
   9007199254740992.*9007199254740992.e-256 /* = 2^106 * 1e-53 */
 };
 /*
-  The factor of 2^53 in tinytens[4] helps us avoid setting the underflow
+  The factor of 2^53 in tinytens[4] helps us avoid setting the underflow 
   flag unnecessarily.  It leads to a song and dance at the end of strtod.
 */
 #define Scale_Bit 0x10
@@ -1275,16 +1320,16 @@ static double ratio(Bigint *a, Bigint *b)
 
 /*
   strtod for IEEE--arithmetic machines.
-
+ 
   This strtod returns a nearest machine number to the input decimal
   string (or sets errno to EOVERFLOW). Ties are broken by the IEEE round-even
   rule.
-
+ 
   Inspired loosely by William D. Clinger's paper "How to Read Floating
   Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].
-
+ 
   Modifications:
-
+ 
    1. We only require IEEE (not IEEE double-extended).
    2. We get by with floating-point arithmetic in a case that
      Clinger missed -- when we're computing d * 10^n
@@ -1350,7 +1395,7 @@ static double my_strtod_int(const char *s00, char **se, int *error, char *buf, s
  break2:
   if (s >= end)
     goto ret0;
-
+  
   if (*s == '0')
   {
     nz0= 1;
@@ -1371,34 +1416,50 @@ static double my_strtod_int(const char *s00, char **se, int *error, char *buf, s
     c= *++s;
     if (!nd)
     {
-      for (; s < end && c == '0'; c= *++s)
+      for (; s < end; ++s)
+      {
+        c= *s;
+        if (c != '0')
+          break;
         nz++;
+      }
       if (s < end && c > '0' && c <= '9')
       {
         s0= s;
         nf+= nz;
         nz= 0;
-        goto have_dig;
       }
-      goto dig_done;
+      else
+        goto dig_done;
     }
-    for (; s < end && c >= '0' && c <= '9'; c = *++s)
+    for (; s < end; ++s)
     {
- have_dig:
-      nz++;
-      if (c-= '0')
+      c= *s;
+      if (c < '0' || c > '9')
+        break;
+      /*
+        Here we are parsing the fractional part.
+        We can stop counting digits after a while: the extra digits
+        will not contribute to the actual result produced by s2b().
+        We have to continue scanning, in case there is an exponent part.
+       */
+      if (nd < 2 * DBL_DIG)
       {
-        nf+= nz;
-        for (i= 1; i < nz; i++)
+        nz++;
+        if (c-= '0')
+        {
+          nf+= nz;
+          for (i= 1; i < nz; i++)
+            if (nd++ < 9)
+              y*= 10;
+            else if (nd <= DBL_DIG + 1)
+              z*= 10;
           if (nd++ < 9)
-            y*= 10;
+            y= 10*y + c;
           else if (nd <= DBL_DIG + 1)
-            z*= 10;
-        if (nd++ < 9)
-          y= 10*y + c;
-        else if (nd <= DBL_DIG + 1)
-          z= 10*z + c;
-        nz= 0;
+            z= 10*z + c;
+          nz= 0;
+        }
       }
     }
   }
@@ -2013,6 +2074,7 @@ static double my_strtod_int(const char *s00, char **se, int *error, char *buf, s
   return sign ? -dval(&rv) : dval(&rv);
 }
 
+
 static int quorem(Bigint *b, Bigint *S)
 {
   int n;
@@ -2076,6 +2138,7 @@ static int quorem(Bigint *b, Bigint *S)
   return q;
 }
 
+
 /*
    dtoa for IEEE arithmetic (dmg): convert double to ASCII string.
 
@@ -2149,7 +2212,7 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
     to hold the suppressed trailing zeros.
   */
 
-  int bbits, b2, b5, be, dig, i, ieps, UNINIT_VAR(ilim), ilim0,
+  int bbits, b2, b5, be, dig, i, ieps, UNINIT_VAR(ilim), ilim0, 
     UNINIT_VAR(ilim1), j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
     spec_case, try_quick;
   Long L;
@@ -2163,7 +2226,7 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
   int rounding;
 #endif
   Stack_alloc alloc;
-
+  
   alloc.begin= alloc.free= buf;
   alloc.end= buf + buf_size;
   memset(alloc.freelist, 0, sizeof(alloc.freelist));
@@ -2190,7 +2253,7 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
       *rve= res + 1;
     return res;
   }
-
+  
 #ifdef Honor_FLT_ROUNDS
   if ((rounding= Flt_Rounds) >= 2)
   {
@@ -2214,12 +2277,12 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
       log10(x)      =  log(x) / log(10)
                    ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
       log10(d)= (i-Bias)*log(2)/log(10) + log10(d2)
-
+     
       This suggests computing an approximation k to log10(d) by
-
+     
       k= (i - Bias)*0.301029995663981
            + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
-
+     
       We want k to be too large rather than too small.
       The error in the first-order Taylor series approximation
       is in our favor, so we just round up the constant enough
@@ -2561,7 +2624,7 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
   /*
     Arrange for convenient computation of quotients:
     shift left if necessary so divisor has 4 leading 0 bits.
-
+    
     Perhaps we should just compute leading 28 bits of S once
     a nd for all and pass them and a shift to quorem, so it
     can do shifts and ors to compute the numerator for q.
@@ -2764,4 +2827,4 @@ static char *dtoa(double dd, int mode, int ndigits, int *decpt, int *sign,
   if (rve)
     *rve= s;
   return s0;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/int2str.c b/dep/mysqllite/strings/int2str.c
index bb2f160..73a0484 100644
--- a/dep/mysqllite/strings/int2str.c
+++ b/dep/mysqllite/strings/int2str.c
@@ -24,9 +24,10 @@
 char _dig_vec_lower[] =
   "0123456789abcdefghijklmnopqrstuvwxyz";
 
+
 /*
   Convert integer to its string representation in given scale of notation.
-
+   
   SYNOPSIS
     int2str()
       val     - value to convert
@@ -35,10 +36,10 @@
       upcase  - set to 1 if we should use upper-case digits
 
   DESCRIPTION
-    Converts the (long) integer value to its character form and moves it to
-    the destination buffer followed by a terminating NUL.
+    Converts the (long) integer value to its character form and moves it to 
+    the destination buffer followed by a terminating NUL. 
     If radix is -2..-36, val is taken to be SIGNED, if radix is  2..36, val is
-    taken to be UNSIGNED. That is, val is signed if and only if radix is.
+    taken to be UNSIGNED. That is, val is signed if and only if radix is. 
     All other radixes treated as bad and nothing will be changed in this case.
 
     For conversion to decimal representation (radix is -10 or 10) one can use
@@ -47,9 +48,9 @@
   RETURN VALUE
     Pointer to ending NUL character or NullS if radix is bad.
 */
-
+  
 char *
-int2str(register long int val, register char *dst, register int radix,
+int2str(register long int val, register char *dst, register int radix, 
         int upcase)
 {
   char buffer[65];
@@ -110,9 +111,10 @@
   return dst-1;
 }
 
+
 /*
   Converts integer to its string representation in decimal notation.
-
+   
   SYNOPSIS
     int10_to_str()
       val     - value to convert
@@ -121,7 +123,7 @@
 
   DESCRIPTION
     This is version of int2str() function which is optimized for normal case
-    of radix 10/-10. It takes only sign of radix parameter into account and
+    of radix 10/-10. It takes only sign of radix parameter into account and 
     not its absolute value.
 
   RETURN VALUE
@@ -159,4 +161,4 @@ char *int10_to_str(long int val,char *dst,int radix)
   }
   while ((*dst++ = *p++) != 0) ;
   return dst-1;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/is_prefix.c b/dep/mysqllite/strings/is_prefix.c
index bc4ec89..05ca828 100644
--- a/dep/mysqllite/strings/is_prefix.c
+++ b/dep/mysqllite/strings/is_prefix.c
@@ -30,4 +30,4 @@ int is_prefix(register const char *s, register const char *t)
   while (*t)
     if (*s++ != *t++) return 0;
   return 1;					/* WRONG */
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/llstr.c b/dep/mysqllite/strings/llstr.c
index bf2f2b1..5d904af 100644
--- a/dep/mysqllite/strings/llstr.c
+++ b/dep/mysqllite/strings/llstr.c
@@ -24,6 +24,7 @@
   variables with printf() as there is no usable printf() standard one can use.
 */
 
+
 #include <my_global.h>
 #include "m_string.h"
 
@@ -37,4 +38,4 @@ char *ullstr(longlong value,char *buff)
 {
   longlong10_to_str(value,buff,10);
   return buff;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/longlong2str.c b/dep/mysqllite/strings/longlong2str.c
index 6c4cda7..18bc1da 100644
--- a/dep/mysqllite/strings/longlong2str.c
+++ b/dep/mysqllite/strings/longlong2str.c
@@ -34,8 +34,8 @@
   but this is where the code is.
 
   Note: The standard itoa() returns a pointer to the argument, when int2str
-    returns the pointer to the end-null.
-    itoa assumes that 10 -base numbers are allways signed and other arn't.
+	returns the pointer to the end-null.
+	itoa assumes that 10 -base numbers are allways signed and other arn't.
 */
 
 #include <my_global.h>
@@ -141,4 +141,4 @@ char *longlong10_to_str(longlong val,char *dst,int radix)
   while ((*dst++ = *p++) != 0) ;
   return dst-1;
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/dep/mysqllite/strings/my_strchr.c b/dep/mysqllite/strings/my_strchr.c
index 509ae41..df1e852 100644
--- a/dep/mysqllite/strings/my_strchr.c
+++ b/dep/mysqllite/strings/my_strchr.c
@@ -51,6 +51,7 @@
     return (size_t) (ptr_str - (STR));                                  \
   } while (0)
 
+
 /*
   my_strchr(cs, str, end, c) returns a pointer to the first place in
   str where c (1-byte character) occurs, or NULL if c does not occur
@@ -100,4 +101,4 @@ size_t my_strcspn(CHARSET_INFO *cs, const char *str, const char *str_end,
                   const char *reject)
 {
   SCAN_STRING(cs, str, str_end, reject, strlen(reject), EQU);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/my_strtoll10.c b/dep/mysqllite/strings/my_strtoll10.c
index 7f88d18..cde973d 100644
--- a/dep/mysqllite/strings/my_strtoll10.c
+++ b/dep/mysqllite/strings/my_strtoll10.c
@@ -30,14 +30,14 @@
 
 /*
   Convert a string to an to unsigned long long integer value
-
+  
   SYNOPSYS
     my_strtoll10()
       nptr     in       pointer to the string to be converted
       endptr   in/out   pointer to the end of the string/
                         pointer to the stop character
       error    out      returned error code
-
+ 
   DESCRIPTION
     This function takes the decimal representation of integer number
     from string nptr and converts it to an signed or unsigned
@@ -49,7 +49,7 @@
     The function stops reading the string nptr at the first character
     that is not a decimal digit. If endptr is not NULL then the function
     will not read characters after *endptr.
-
+ 
   RETURN VALUES
     Value of string as a signed/unsigned longlong integer
 
@@ -60,16 +60,17 @@
     -1		Number was an ok negative number
     0	 	ok
     ERANGE	If the the value of the converted number exceeded the
-            maximum negative/unsigned long long integer.
-        In this case the return value is ~0 if value was
-        positive and LONGLONG_MIN if value was negative.
+	        maximum negative/unsigned long long integer.
+		In this case the return value is ~0 if value was
+		positive and LONGLONG_MIN if value was negative.
     EDOM	If the string didn't contain any digits. In this case
-            the return value is 0.
+    		the return value is 0.
 
     If endptr is not NULL the function will store the end pointer to
     the stop character here.
 */
 
+
 longlong my_strtoll10(const char *nptr, char **endptr, int *error)
 {
   const char *s, *end, *start, *n_end, *true_end;
@@ -119,7 +120,7 @@ longlong my_strtoll10(const char *nptr, char **endptr, int *error)
     if (*s == '+')
     {
       if (++s == end)
-    goto no_conv;
+	goto no_conv;
     }
     cutoff=  ULONGLONG_MAX / LFACTOR2;
     cutoff2= ULONGLONG_MAX % LFACTOR2 / 100;
@@ -133,7 +134,7 @@ longlong my_strtoll10(const char *nptr, char **endptr, int *error)
     do
     {
       if (++s == end)
-    goto end_i;				/* Return 0 */
+	goto end_i;				/* Return 0 */
     }
     while (*s == '0');
     n_end= s+ INIT_CNT;
@@ -232,4 +233,4 @@ longlong my_strtoll10(const char *nptr, char **endptr, int *error)
   *error= MY_ERRNO_EDOM;
   *endptr= (char *) nptr;
   return 0;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/my_vsnprintf.c b/dep/mysqllite/strings/my_vsnprintf.c
index 9240aa7..73cbf02 100644
--- a/dep/mysqllite/strings/my_vsnprintf.c
+++ b/dep/mysqllite/strings/my_vsnprintf.c
@@ -18,13 +18,14 @@
 #include <stdarg.h>
 #include <m_ctype.h>
 
+
 #define MAX_ARGS 32                           /* max positional args count*/
 #define MAX_PRINT_INFO 32                     /* max print position count */
 
 #define LENGTH_ARG     1
 #define WIDTH_ARG      2
 #define PREZERO_ARG    4
-#define ESCAPED_ARG    8
+#define ESCAPED_ARG    8 
 
 typedef struct pos_arg_info ARGS_INFO;
 typedef struct print_info PRINT_INFO;
@@ -38,6 +39,7 @@ struct pos_arg_info
   double double_arg;                          /* double value of the arg */
 };
 
+
 struct print_info
 {
   char arg_type;                              /* argument type */
@@ -49,6 +51,7 @@ struct print_info
   const char *end;                            /**/
 };
 
+
 /**
   Calculates print length or index of positional argument
 
@@ -71,6 +74,7 @@ static const char *get_length(const char *fmt, size_t *length, uint *pre_zero)
   return fmt;
 }
 
+
 /**
   Calculates print width or index of positional argument
 
@@ -122,6 +126,7 @@ static const char *check_longlong(const char *fmt, uint *have_longlong)
   return fmt;
 }
 
+
 /**
   Returns escaped string
 
@@ -163,7 +168,7 @@ static char *backtick_string(CHARSET_INFO *cs, char *to, char *end,
       goto err;
     start= strnmov(start, par, char_len);
   }
-
+    
   if (start + 1 >= end)
     goto err;
   *start++= quote_char;
@@ -174,6 +179,7 @@ static char *backtick_string(CHARSET_INFO *cs, char *to, char *end,
   return to;
 }
 
+
 /**
   Prints string argument
 */
@@ -198,6 +204,7 @@ static char *process_str_arg(CHARSET_INFO *cs, char *to, char *end,
   return to;
 }
 
+
 /**
   Prints binary argument
 */
@@ -212,6 +219,7 @@ static char *process_bin_arg(char *to, char *end, size_t width, char *par)
   return to;
 }
 
+
 /**
   Prints double or float argument
 */
@@ -224,7 +232,7 @@ static char *process_dbl_arg(char *to, char *end, size_t width,
   else if (width >= NOT_FIXED_DEC)
     width= NOT_FIXED_DEC - 1; /* max.precision for my_fcvt() */
   width= min(width, (size_t)(end-to) - 1);
-
+  
   if (arg_type == 'f')
     to+= my_fcvt(par, (int)width , to, NULL);
   else
@@ -232,6 +240,7 @@ static char *process_dbl_arg(char *to, char *end, size_t width,
   return to;
 }
 
+
 /**
   Prints integer argument
 */
@@ -292,6 +301,7 @@ static char *process_int_arg(char *to, char *end, size_t length,
   return to;
 }
 
+
 /**
   Procesed positional arguments.
 
@@ -327,10 +337,10 @@ static char *process_args(CHARSET_INFO *cs, char *to, char *end,
   print_arr[idx].length= print_arr[idx].width= 0;
   /* Get print length */
   if (*fmt == '*')
-  {
+  {          
     fmt++;
     fmt= get_length(fmt, &print_arr[idx].length, &print_arr[idx].flags);
-    print_arr[idx].length--;
+    print_arr[idx].length--;    
     DBUG_ASSERT(*fmt == '$' && print_arr[idx].length < MAX_ARGS);
     args_arr[print_arr[idx].length].arg_type= 'd';
     print_arr[idx].flags|= LENGTH_ARG;
@@ -339,7 +349,7 @@ static char *process_args(CHARSET_INFO *cs, char *to, char *end,
   }
   else
     fmt= get_length(fmt, &print_arr[idx].length, &print_arr[idx].flags);
-
+  
   if (*fmt == '.')
   {
     fmt++;
@@ -365,7 +375,7 @@ static char *process_args(CHARSET_INFO *cs, char *to, char *end,
   if (*fmt == 'p')
     args_arr[arg_index].have_longlong= (sizeof(void *) == sizeof(longlong));
   args_arr[arg_index].arg_type= print_arr[idx].arg_type= *fmt;
-
+  
   print_arr[idx].arg_idx= arg_index;
   print_arr[idx].begin= ++fmt;
 
@@ -507,6 +517,8 @@ static char *process_args(CHARSET_INFO *cs, char *to, char *end,
   return 0;
 }
 
+
+
 /**
   Produces output string according to a format string
 
@@ -534,7 +546,7 @@ size_t my_vsnprintf_ex(CHARSET_INFO *cs, char *to, size_t n,
     if (*fmt != '%')
     {
       if (to == end)                            /* End of buffer */
-    break;
+	break;
       *to++= *fmt;                            /* Copy ordinary char */
       continue;
     }
@@ -583,7 +595,7 @@ size_t my_vsnprintf_ex(CHARSET_INFO *cs, char *to, size_t n,
         fmt= get_width(fmt, &width);
     }
     else
-      width= SIZE_T_MAX;
+      width= SIZE_T_MAX;   
 
     fmt= check_longlong(fmt, &have_longlong);
 
@@ -605,7 +617,7 @@ size_t my_vsnprintf_ex(CHARSET_INFO *cs, char *to, size_t n,
       to= process_dbl_arg(to, end, width, d, *fmt);
       continue;
     }
-    else if (*fmt == 'd' || *fmt == 'i' || *fmt == 'u' || *fmt == 'x' ||
+    else if (*fmt == 'd' || *fmt == 'i' || *fmt == 'u' || *fmt == 'x' || 
              *fmt == 'X' || *fmt == 'p' || *fmt == 'o')
     {
       /* Integer parameter */
@@ -643,6 +655,7 @@ size_t my_vsnprintf_ex(CHARSET_INFO *cs, char *to, size_t n,
   return (size_t) (to - start);
 }
 
+
 /*
   Limited snprintf() implementations
 
@@ -655,6 +668,7 @@ size_t my_vsnprintf(char *to, size_t n, const char* fmt, va_list ap)
   return my_vsnprintf_ex(&my_charset_latin1, to, n, fmt, ap);
 }
 
+
 size_t my_snprintf(char* to, size_t n, const char* fmt, ...)
 {
   size_t result;
@@ -663,4 +677,5 @@ size_t my_snprintf(char* to, size_t n, const char* fmt, ...)
   result= my_vsnprintf(to, n, fmt, args);
   va_end(args);
   return result;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/strings/str2int.c b/dep/mysqllite/strings/str2int.c
index d84e2ee..6dfa64a 100644
--- a/dep/mysqllite/strings/str2int.c
+++ b/dep/mysqllite/strings/str2int.c
@@ -25,9 +25,9 @@
 
   If an error is detected, the result will be NullS, the value put
   in val will be 0, and errno will be set to
-    EDOM	if there are no digits
-    ERANGE	if the result would overflow or otherwise fail to lie
-        within the specified bounds.
+	EDOM	if there are no digits
+	ERANGE	if the result would overflow or otherwise fail to lie
+		within the specified bounds.
   Check that the bounds are right for your machine.
   This looks amazingly complicated for what you probably thought was an
   easy task.  Coping with integer overflow and the asymmetric range of
@@ -45,12 +45,12 @@
 #include <errno.h>
 
 #define char_val(X) (X >= '0' && X <= '9' ? X-'0' :\
-             X >= 'A' && X <= 'Z' ? X-'A'+10 :\
-             X >= 'a' && X <= 'z' ? X-'a'+10 :\
-             '\177')
+		     X >= 'A' && X <= 'Z' ? X-'A'+10 :\
+		     X >= 'a' && X <= 'z' ? X-'a'+10 :\
+		     '\177')
 
 char *str2int(register const char *src, register int radix, long int lower,
-          long int upper, long int *val)
+	      long int upper, long int *val)
 {
   int sign;			/* is number negative (+1) or positive (-1) */
   int n;			/* number of digits yet to be converted */
@@ -180,7 +180,7 @@ char *str2int(register const char *src, register int radix, long int lower,
   return (char*) src;
 }
 
-    /* Theese are so slow compared with ordinary, optimized atoi */
+	/* Theese are so slow compared with ordinary, optimized atoi */
 
 #ifdef WANT_OUR_ATOI
 
@@ -191,6 +191,7 @@ int atoi(const char *src)
   return (int) val;
 }
 
+
 long atol(const char *src)
 {
   long val;
@@ -198,4 +199,4 @@ long atol(const char *src)
   return val;
 }
 
-#endif /* WANT_OUR_ATOI */
\ No newline at end of file
+#endif /* WANT_OUR_ATOI */
diff --git a/dep/mysqllite/strings/str_alloc.c b/dep/mysqllite/strings/str_alloc.c
index 6715812..5d79a26 100644
--- a/dep/mysqllite/strings/str_alloc.c
+++ b/dep/mysqllite/strings/str_alloc.c
@@ -31,4 +31,4 @@ static void my_str_free_default(void *ptr)
 }
 
 void *(*my_str_malloc)(size_t)= &my_str_malloc_default;
-void (*my_str_free)(void *)= &my_str_free_default;
\ No newline at end of file
+void (*my_str_free)(void *)= &my_str_free_default;
diff --git a/dep/mysqllite/strings/strappend.c b/dep/mysqllite/strings/strappend.c
index ac5eb99..469c03e 100644
--- a/dep/mysqllite/strings/strappend.c
+++ b/dep/mysqllite/strings/strappend.c
@@ -27,6 +27,7 @@
 #include <my_global.h>
 #include "m_string.h"
 
+
 void strappend(register char *s, size_t len, pchar fill)
 {
   register char *endpos;
@@ -36,4 +37,4 @@ void strappend(register char *s, size_t len, pchar fill)
   s--;
   while (s<endpos) *(s++) = fill;
   *(endpos) = '\0';
-} /* strappend */
\ No newline at end of file
+} /* strappend */
diff --git a/dep/mysqllite/strings/strcend.c b/dep/mysqllite/strings/strcend.c
index f975896..76d40dc 100644
--- a/dep/mysqllite/strings/strcend.c
+++ b/dep/mysqllite/strings/strcend.c
@@ -32,4 +32,5 @@ char *strcend(register const char *s, register pchar c)
      if (*s == (char) c) return (char*) s;
      if (!*s++) return (char*) s-1;
   }
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/strings/strcont.c b/dep/mysqllite/strings/strcont.c
index f3f21df..f3baf59 100644
--- a/dep/mysqllite/strings/strcont.c
+++ b/dep/mysqllite/strings/strcont.c
@@ -37,9 +37,9 @@ char * strcont(reg1 const char *str,reg2 const char *set)
     while (*set)
     {
       if (*set++ == *str)
-    return ((char*) str);
+	return ((char*) str);
     }
     set=start; str++;
   }
   return (NullS);
-} /* strcont */
\ No newline at end of file
+} /* strcont */
diff --git a/dep/mysqllite/strings/strend.c b/dep/mysqllite/strings/strend.c
index b94ff73..257ffe9 100644
--- a/dep/mysqllite/strings/strend.c
+++ b/dep/mysqllite/strings/strend.c
@@ -1,15 +1,15 @@
 /* Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
-
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
@@ -33,4 +33,5 @@ char *strend(register const char *s)
 {
   while (*s++);
   return (char*) (s-1);
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/strings/strfill.c b/dep/mysqllite/strings/strfill.c
index f74d5d4..9fbb0c2 100644
--- a/dep/mysqllite/strings/strfill.c
+++ b/dep/mysqllite/strings/strfill.c
@@ -32,4 +32,4 @@ char * strfill(char *s, size_t len, pchar fill)
   while (len--) *s++ = fill;
   *(s) = '\0';
   return(s);
-} /* strfill */
\ No newline at end of file
+} /* strfill */
diff --git a/dep/mysqllite/strings/strmake.c b/dep/mysqllite/strings/strmake.c
index f8644fb..5a062e4 100644
--- a/dep/mysqllite/strings/strmake.c
+++ b/dep/mysqllite/strings/strmake.c
@@ -52,4 +52,4 @@ char *strmake(register char *dst, register const char *src, size_t length)
       return dst-1;
   *dst=0;
   return dst;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/strmov.c b/dep/mysqllite/strings/strmov.c
index 5bca5fa..84dd358 100644
--- a/dep/mysqllite/strings/strmov.c
+++ b/dep/mysqllite/strings/strmov.c
@@ -33,4 +33,5 @@ char *strmov(register char *dst, register const char *src)
 {
   while ((*dst++ = *src++)) ;
   return dst-1;
-}
\ No newline at end of file
+}
+
diff --git a/dep/mysqllite/strings/strnmov.c b/dep/mysqllite/strings/strnmov.c
index c392d40..19f752f 100644
--- a/dep/mysqllite/strings/strnmov.c
+++ b/dep/mysqllite/strings/strnmov.c
@@ -32,4 +32,4 @@ char *strnmov(register char *dst, register const char *src, size_t n)
     }
   }
   return dst;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/strxmov.c b/dep/mysqllite/strings/strxmov.c
index c70350c..de4e2fa 100644
--- a/dep/mysqllite/strings/strxmov.c
+++ b/dep/mysqllite/strings/strxmov.c
@@ -1,16 +1,16 @@
 /* Copyright (c) 2000-2002, 2006 MySQL AB
    Use is subject to license terms.
-
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
@@ -48,4 +48,4 @@ char *strxmov(char *dst,const char *src, ...)
   va_end(pvar);
   *dst = 0;			/* there might have been no sources! */
   return dst;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/strxnmov.c b/dep/mysqllite/strings/strxnmov.c
index 3689b93..5e70b54 100644
--- a/dep/mysqllite/strings/strxnmov.c
+++ b/dep/mysqllite/strings/strxnmov.c
@@ -1,16 +1,16 @@
 /* Copyright (c) 2000-2002, 2005-2007 MySQL AB
    Use is subject to license terms.
-
+   
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; version 2
    of the License.
-
+   
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.
-
+   
    You should have received a copy of the GNU Library General Public
    License along with this library; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
@@ -51,7 +51,7 @@ char *strxnmov(char *dst, size_t len, const char *src, ...)
     do
     {
       if (dst == end_of_dst)
-    goto end;
+	goto end;
     }
     while ((*dst++ = *src++));
     dst--;
@@ -61,4 +61,4 @@ char *strxnmov(char *dst, size_t len, const char *src, ...)
   *dst=0;
   va_end(pvar);
   return dst;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/strings/xml.c b/dep/mysqllite/strings/xml.c
index 8b0cbd2..4735b2d 100644
--- a/dep/mysqllite/strings/xml.c
+++ b/dep/mysqllite/strings/xml.c
@@ -17,6 +17,7 @@
 #include "m_string.h"
 #include "my_xml.h"
 
+
 #define MY_XML_UNKNOWN  'U'
 #define MY_XML_EOF	'E'
 #define MY_XML_STRING	'S'
@@ -37,6 +38,7 @@
   const char *end;
 } MY_XML_ATTR;
 
+
 /*
   XML ctype:
 */
@@ -44,8 +46,9 @@
 #define	MY_XML_ID1  0x02 /* Identifier medial  character */
 #define	MY_XML_SPC  0x08 /* Spacing character */
 
+
 /*
- http://www.w3.org/TR/REC-xml/
+ http://www.w3.org/TR/REC-xml/ 
  [4] NameChar ::= Letter | Digit | '.' | '-' | '_' | ':' |
                   CombiningChar | Extender
  [5] Name ::= (Letter | '_' | ':') (NameChar)*
@@ -75,6 +78,7 @@
 #define my_xml_is_id0(c)    (my_xml_ctype[(uchar) (c)] & MY_XML_ID0)
 #define my_xml_is_id1(c)    (my_xml_ctype[(uchar) (c)] & MY_XML_ID1)
 
+
 static const char *lex2str(int lex)
 {
   switch(lex)
@@ -101,18 +105,20 @@ static void my_xml_norm_text(MY_XML_ATTR *a)
   for ( ; (a->beg < a->end) && my_xml_is_space(a->end[-1]) ; a->end-- );
 }
 
+
 static inline my_bool
 my_xml_parser_prefix_cmp(MY_XML_PARSER *p, const char *s, size_t slen)
 {
   return (p->cur + slen > p->end) || memcmp(p->cur, s, slen);
 }
 
+
 static int my_xml_scan(MY_XML_PARSER *p,MY_XML_ATTR *a)
 {
   int lex;
-
+  
   for (; ( p->cur < p->end) && my_xml_is_space(p->cur[0]) ;  p->cur++);
-
+  
   if (p->cur >= p->end)
   {
     a->beg=p->end;
@@ -120,10 +126,10 @@ static int my_xml_scan(MY_XML_PARSER *p,MY_XML_ATTR *a)
     lex=MY_XML_EOF;
     goto ret;
   }
-
+  
   a->beg=p->cur;
   a->end=p->cur;
-
+  
   if (!my_xml_parser_prefix_cmp(p, C_STRING_WITH_LEN("<!--")))
   {
     for (; p->cur < p->end; p->cur++)
@@ -194,11 +200,13 @@ static int my_xml_scan(MY_XML_PARSER *p,MY_XML_ATTR *a)
   return lex;
 }
 
+
 static int my_xml_value(MY_XML_PARSER *st, const char *str, size_t len)
 {
   return (st->value) ? (st->value)(st,str,len) : MY_XML_OK;
 }
 
+
 static int my_xml_enter(MY_XML_PARSER *st, const char *str, size_t len)
 {
   if ((size_t) (st->attrend-st->attr+len+1) > sizeof(st->attr))
@@ -220,6 +228,7 @@ static int my_xml_enter(MY_XML_PARSER *st, const char *str, size_t len)
     return st->enter ?  st->enter(st,st->attr,st->attrend-st->attr) : MY_XML_OK;
 }
 
+
 static void mstr(char *s,const char *src,size_t l1, size_t l2)
 {
   l1 = l1<l2 ? l1 : l2;
@@ -227,6 +236,7 @@ static void mstr(char *s,const char *src,size_t l1, size_t l2)
   s[l1]='\0';
 }
 
+
 static int my_xml_leave(MY_XML_PARSER *p, const char *str, size_t slen)
 {
   char *e;
@@ -238,7 +248,7 @@ static int my_xml_leave(MY_XML_PARSER *p, const char *str, size_t slen)
   /* Find previous '/' or beginning */
   for (e=p->attrend; (e>p->attr) && (e[0] != '/') ; e--);
   glen = (size_t) ((e[0] == '/') ? (p->attrend-e-1) : p->attrend-e);
-
+  
   if (str && (slen != glen))
   {
     mstr(s,str,sizeof(s)-1,slen);
@@ -251,26 +261,27 @@ static int my_xml_leave(MY_XML_PARSER *p, const char *str, size_t slen)
       sprintf(p->errstr,"'</%s>' unexpected (END-OF-INPUT wanted)", s);
     return MY_XML_ERROR;
   }
-
+  
   if (p->flags & MY_XML_FLAG_RELATIVE_NAMES)
     rc= p->leave_xml ? p->leave_xml(p, str, slen) : MY_XML_OK;
   else
     rc= (p->leave_xml ?  p->leave_xml(p,p->attr,p->attrend-p->attr) :
          MY_XML_OK);
-
+  
   *e='\0';
   p->attrend=e;
-
+  
   return rc;
 }
 
+
 int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
 {
   p->attrend=p->attr;
   p->beg=str;
   p->cur=str;
   p->end=str+len;
-
+  
   while ( p->cur < p->end )
   {
     MY_XML_ATTR a;
@@ -279,12 +290,12 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
       int lex;
       int question=0;
       int exclam=0;
-
+      
       lex=my_xml_scan(p,&a);
-
+      
       if (MY_XML_COMMENT == lex)
         continue;
-
+      
       if (lex == MY_XML_CDATA)
       {
         a.beg+= 9;
@@ -292,9 +303,9 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
         my_xml_value(p, a.beg, (size_t) (a.end-a.beg));
         continue;
       }
-
+      
       lex=my_xml_scan(p,&a);
-
+      
       if (MY_XML_SLASH == lex)
       {
         if (MY_XML_IDENT != (lex=my_xml_scan(p,&a)))
@@ -307,7 +318,7 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
         lex=my_xml_scan(p,&a);
         goto gt;
       }
-
+      
       if (MY_XML_EXCLAM == lex)
       {
         lex=my_xml_scan(p,&a);
@@ -318,7 +329,7 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
         lex=my_xml_scan(p,&a);
         question=1;
       }
-
+      
       if (MY_XML_IDENT == lex)
       {
         p->current_node_type= MY_XML_NODE_TAG;
@@ -328,10 +339,10 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
       else
       {
         sprintf(p->errstr,"%s unexpected (ident or '/' wanted)",
-        lex2str(lex));
+		lex2str(lex));
         return MY_XML_ERROR;
       }
-
+      
       while ((MY_XML_IDENT == (lex=my_xml_scan(p,&a))) ||
              ((MY_XML_STRING == lex && exclam)))
       {
@@ -350,7 +361,7 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
           else
           {
             sprintf(p->errstr,"%s unexpected (ident or string wanted)",
-            lex2str(lex));
+		    lex2str(lex));
             return MY_XML_ERROR;
           }
         }
@@ -373,14 +384,14 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
         else
           break;
       }
-
+      
       if (lex == MY_XML_SLASH)
       {
         if (MY_XML_OK != my_xml_leave(p,NULL,0))
           return MY_XML_ERROR;
         lex=my_xml_scan(p,&a);
       }
-
+      
 gt:
       if (question)
       {
@@ -393,13 +404,13 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
           return MY_XML_ERROR;
         lex=my_xml_scan(p,&a);
       }
-
+      
       if (exclam)
       {
         if (MY_XML_OK != my_xml_leave(p,NULL,0))
           return MY_XML_ERROR;
       }
-
+      
       if (lex != MY_XML_GT)
       {
         sprintf(p->errstr,"%s unexpected ('>' wanted)",lex2str(lex));
@@ -411,7 +422,7 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
       a.beg=p->cur;
       for ( ; (p->cur < p->end) && (p->cur[0] != '<')  ; p->cur++);
       a.end=p->cur;
-
+      
       if (!(p->flags & MY_XML_FLAG_SKIP_TEXT_NORMALIZATION))
         my_xml_norm_text(&a);
       if (a.beg != a.end)
@@ -429,46 +440,53 @@ int my_xml_parse(MY_XML_PARSER *p,const char *str, size_t len)
   return MY_XML_OK;
 }
 
+
 void my_xml_parser_create(MY_XML_PARSER *p)
 {
   bzero((void*)p,sizeof(p[0]));
 }
 
+
 void my_xml_parser_free(MY_XML_PARSER *p  __attribute__((unused)))
 {
 }
 
+
 void my_xml_set_value_handler(MY_XML_PARSER *p,
-                  int (*action)(MY_XML_PARSER *p, const char *s,
-                        size_t l))
+			      int (*action)(MY_XML_PARSER *p, const char *s,
+					    size_t l))
 {
   p->value=action;
 }
 
 void my_xml_set_enter_handler(MY_XML_PARSER *p,
-                  int (*action)(MY_XML_PARSER *p, const char *s,
-                        size_t l))
+			      int (*action)(MY_XML_PARSER *p, const char *s,
+					    size_t l))
 {
   p->enter=action;
 }
 
+
 void my_xml_set_leave_handler(MY_XML_PARSER *p,
-                  int (*action)(MY_XML_PARSER *p, const char *s,
-                        size_t l))
+			      int (*action)(MY_XML_PARSER *p, const char *s,
+					    size_t l))
 {
   p->leave_xml=action;
 }
 
+
 void my_xml_set_user_data(MY_XML_PARSER *p, void *user_data)
 {
   p->user_data=user_data;
 }
 
+
 const char *my_xml_error_string(MY_XML_PARSER *p)
 {
   return p->errstr;
 }
 
+
 size_t my_xml_error_pos(MY_XML_PARSER *p)
 {
   const char *beg=p->beg;
@@ -491,4 +509,4 @@ uint my_xml_error_lineno(MY_XML_PARSER *p)
       res++;
   }
   return res;
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/vio/vio.c b/dep/mysqllite/vio/vio.c
index 2fbef16..b8bc7bd 100644
--- a/dep/mysqllite/vio/vio.c
+++ b/dep/mysqllite/vio/vio.c
@@ -98,7 +98,7 @@ static void vio_init(Vio* vio, enum enum_vio_type type,
     DBUG_VOID_RETURN;
   }
 #endif
-#ifdef HAVE_SMEM
+#ifdef HAVE_SMEM 
   if (type == VIO_TYPE_SHARED_MEMORY)
   {
     vio->viodelete	=vio_delete;
@@ -119,14 +119,14 @@ static void vio_init(Vio* vio, enum enum_vio_type type,
     vio->has_data       =has_no_data;
 
     /* Currently, shared memory is on Windows only, hence the below is ok*/
-    vio->timeout= vio_win32_timeout;
+    vio->timeout= vio_win32_timeout; 
     /* Set default timeout */
     vio->read_timeout_ms= INFINITE;
     vio->write_timeout_ms= INFINITE;
     DBUG_VOID_RETURN;
   }
-#endif
-#ifdef HAVE_OPENSSL
+#endif   
+#ifdef HAVE_OPENSSL 
   if (type == VIO_TYPE_SSL)
   {
     vio->viodelete	=vio_ssl_delete;
@@ -168,6 +168,7 @@ static void vio_init(Vio* vio, enum enum_vio_type type,
   DBUG_VOID_RETURN;
 }
 
+
 /* Reset initialized VIO to use with another transport type */
 
 void vio_reset(Vio* vio, enum enum_vio_type type,
@@ -177,6 +178,7 @@ void vio_reset(Vio* vio, enum enum_vio_type type,
   vio_init(vio, type, sd, hPipe, flags);
 }
 
+
 /* Open the socket or TCP/IP connection and read the fnctl() status */
 
 Vio *vio_new(my_socket sd, enum enum_vio_type type, uint flags)
@@ -188,8 +190,8 @@ Vio *vio_new(my_socket sd, enum enum_vio_type type, uint flags)
   {
     vio_init(vio, type, sd, 0, flags);
     sprintf(vio->desc,
-        (vio->type == VIO_TYPE_SOCKET ? "socket (%d)" : "TCP/IP (%d)"),
-        vio->sd);
+	    (vio->type == VIO_TYPE_SOCKET ? "socket (%d)" : "TCP/IP (%d)"),
+	    vio->sd);
 #if !defined(__WIN__)
 #if !defined(NO_FCNTL_NONBLOCK)
     /*
@@ -221,6 +223,7 @@ Vio *vio_new(my_socket sd, enum enum_vio_type type, uint flags)
   DBUG_RETURN(vio);
 }
 
+
 #ifdef __WIN__
 
 Vio *vio_new_win32pipe(HANDLE hPipe)
@@ -262,6 +265,7 @@ Vio *vio_new_win32shared_memory(HANDLE handle_file_map, HANDLE handle_map,
 #endif
 #endif
 
+
 void vio_delete(Vio* vio)
 {
   if (!vio)
@@ -273,6 +277,7 @@ void vio_delete(Vio* vio)
   my_free(vio);
 }
 
+
 /*
   Cleanup memory allocated by vio or the
   components below it when application finish
@@ -283,4 +288,4 @@ void vio_end(void)
 #ifdef HAVE_YASSL
   yaSSL_CleanUp();
 #endif
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/vio/viosocket.c b/dep/mysqllite/vio/viosocket.c
index e674ad3..56aa84d 100644
--- a/dep/mysqllite/vio/viosocket.c
+++ b/dep/mysqllite/vio/viosocket.c
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+   Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
 
    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
@@ -23,6 +23,11 @@
   the file descriptior.
 */
 
+#ifdef __WIN__
+  #include <winsock2.h>
+  #include <MSWSock.h>
+  #pragma comment(lib, "ws2_32.lib")
+#endif
 #include "vio_priv.h"
 
 #ifdef FIONREAD_IN_SYS_FILIO
@@ -34,6 +39,7 @@ int vio_errno(Vio *vio __attribute__((unused)))
   return socket_errno;		/* On Win32 this mapped to WSAGetLastError() */
 }
 
+
 size_t vio_read(Vio * vio, uchar* buf, size_t size)
 {
   size_t r;
@@ -59,6 +65,7 @@ size_t vio_read(Vio * vio, uchar* buf, size_t size)
   DBUG_RETURN(r);
 }
 
+
 /*
   Buffered read: if average read size is small it may
   reduce number of syscalls.
@@ -130,14 +137,14 @@ size_t vio_write(Vio * vio, const uchar* buf, size_t size)
 }
 
 int vio_blocking(Vio * vio __attribute__((unused)), my_bool set_blocking_mode,
-         my_bool *old_mode)
+		 my_bool *old_mode)
 {
   int r=0;
   DBUG_ENTER("vio_blocking");
 
   *old_mode= test(!(vio->fcntl_mode & O_NONBLOCK));
   DBUG_PRINT("enter", ("set_blocking_mode: %d  old_mode: %d",
-               (int) set_blocking_mode, (int) *old_mode));
+		       (int) set_blocking_mode, (int) *old_mode));
 
 #if !defined(__WIN__)
 #if !defined(NO_FCNTL_NONBLOCK)
@@ -163,7 +170,7 @@ int vio_blocking(Vio * vio __attribute__((unused)), my_bool set_blocking_mode,
 #endif /* !defined(NO_FCNTL_NONBLOCK) */
 #else /* !defined(__WIN__) */
   if (vio->type != VIO_TYPE_NAMEDPIPE && vio->type != VIO_TYPE_SHARED_MEMORY)
-  {
+  { 
     ulong arg;
     int old_fcntl=vio->fcntl_mode;
     if (set_blocking_mode)
@@ -196,6 +203,7 @@ int vio_blocking(Vio * vio __attribute__((unused)), my_bool set_blocking_mode,
   DBUG_RETURN(r);
 }
 
+
 int vio_fastsend(Vio * vio __attribute__((unused)))
 {
   int r=0;
@@ -218,6 +226,7 @@ int vio_fastsend(Vio * vio __attribute__((unused)))
     r= setsockopt(vio->sd, IPPROTO_TCP, TCP_NODELAY,
                   IF_WIN((const char*), (void*)) &nodelay,
                   sizeof(nodelay));
+
   }
   if (r)
   {
@@ -234,17 +243,18 @@ int vio_keepalive(Vio* vio, my_bool set_keep_alive)
   uint opt = 0;
   DBUG_ENTER("vio_keepalive");
   DBUG_PRINT("enter", ("sd: %d  set_keep_alive: %d", vio->sd, (int)
-               set_keep_alive));
+		       set_keep_alive));
   if (vio->type != VIO_TYPE_NAMEDPIPE)
   {
     if (set_keep_alive)
       opt = 1;
     r = setsockopt(vio->sd, SOL_SOCKET, SO_KEEPALIVE, (char *) &opt,
-           sizeof(opt));
+		   sizeof(opt));
   }
   DBUG_RETURN(r);
 }
 
+
 my_bool
 vio_should_retry(Vio * vio)
 {
@@ -262,14 +272,47 @@ int vio_keepalive(Vio* vio, my_bool set_keep_alive)
             (en == SOCKET_EAGAIN || en == SOCKET_EWOULDBLOCK));
 }
 
+
 my_bool
 vio_was_interrupted(Vio *vio __attribute__((unused)))
 {
   int en= socket_errno;
   return (en == SOCKET_EAGAIN || en == SOCKET_EINTR ||
-      en == SOCKET_EWOULDBLOCK || en == SOCKET_ETIMEDOUT);
+	  en == SOCKET_EWOULDBLOCK || en == SOCKET_ETIMEDOUT);
+}
+
+
+int
+mysql_socket_shutdown(my_socket mysql_socket, int how)
+{
+  int result;
+
+#ifdef __WIN__
+  static LPFN_DISCONNECTEX DisconnectEx = NULL;
+  if (DisconnectEx == NULL)
+  {
+    DWORD dwBytesReturned;
+    GUID guidDisconnectEx = WSAID_DISCONNECTEX;
+    WSAIoctl(mysql_socket, SIO_GET_EXTENSION_FUNCTION_POINTER,
+             &guidDisconnectEx, sizeof(GUID),
+             &DisconnectEx, sizeof(DisconnectEx), 
+             &dwBytesReturned, NULL, NULL);
+  }
+#endif
+
+  /* Non instrumented code */
+#ifdef __WIN__
+  if (DisconnectEx)
+    result= (DisconnectEx(mysql_socket, (LPOVERLAPPED) NULL,
+                          (DWORD) 0, (DWORD) 0) == TRUE) ? 0 : -1;
+  else
+#endif
+    result= shutdown(mysql_socket, how);
+
+  return result;
 }
 
+
 int vio_close(Vio * vio)
 {
   int r=0;
@@ -282,7 +325,7 @@ int vio_close(Vio * vio)
       vio->type == VIO_TYPE_SSL);
 
     DBUG_ASSERT(vio->sd >= 0);
-    if (shutdown(vio->sd, SHUT_RDWR))
+    if (mysql_socket_shutdown(vio->sd, SHUT_RDWR))
       r= -1;
     if (closesocket(vio->sd))
       r= -1;
@@ -297,6 +340,7 @@ int vio_close(Vio * vio)
   DBUG_RETURN(r);
 }
 
+
 const char *vio_description(Vio * vio)
 {
   return vio->desc;
@@ -389,6 +433,7 @@ static void vio_get_normalized_ip(const struct sockaddr *src,
   }
 }
 
+
 /**
   Return the normalized IP address string for a sock-address.
 
@@ -434,6 +479,7 @@ my_bool vio_get_normalized_ip_string(const struct sockaddr *addr,
   return TRUE;
 }
 
+
 /**
   Return IP address and port of a VIO client socket.
 
@@ -515,6 +561,7 @@ my_bool vio_peer_addr(Vio *vio, char *ip_buffer, uint16 *port,
   DBUG_RETURN(FALSE);
 }
 
+
 /**
   Indicate whether there is data to read on a given socket.
 
@@ -566,6 +613,7 @@ static my_bool socket_poll_read(my_socket sd, uint timeout)
 #endif
 }
 
+
 /**
   Retrieve the amount of data that can be read from a socket.
 
@@ -600,6 +648,7 @@ static my_bool socket_peek_read(Vio *vio, uint *bytes)
 #endif
 }
 
+
 /**
   Indicate whether there is data to read on a given socket.
 
@@ -623,6 +672,7 @@ my_bool vio_poll_read(Vio *vio, uint timeout)
   DBUG_RETURN(socket_poll_read(sd, timeout));
 }
 
+
 /**
   Determine if the endpoint of a connection is still available.
 
@@ -669,6 +719,7 @@ my_bool vio_is_connected(Vio *vio)
   DBUG_RETURN(bytes ? TRUE : FALSE);
 }
 
+
 void vio_timeout(Vio *vio, uint which, uint timeout)
 {
 #if defined(SO_SNDTIMEO) && defined(SO_RCVTIMEO)
@@ -689,6 +740,7 @@ void vio_timeout(Vio *vio, uint which, uint timeout)
   r= setsockopt(vio->sd, SOL_SOCKET, which ? SO_SNDTIMEO : SO_RCVTIMEO,
                 IF_WIN((const char*), (const void*))&wait_timeout,
                 sizeof(wait_timeout));
+
   }
 
   if (r != 0)
@@ -703,6 +755,7 @@ void vio_timeout(Vio *vio, uint which, uint timeout)
 #endif
 }
 
+
 #ifdef __WIN__
 
 /*
@@ -729,7 +782,7 @@ static size_t pipe_complete_io(Vio* vio, char* buf, size_t size, DWORD timeout_m
 
   if (!GetOverlappedResult(vio->hPipe,&(vio->pipe_overlapped),&length, FALSE))
   {
-    DBUG_PRINT("error",("GetOverlappedResult() returned last error  %d",
+    DBUG_PRINT("error",("GetOverlappedResult() returned last error  %d", 
       GetLastError()));
     DBUG_RETURN((size_t)-1);
   }
@@ -737,6 +790,7 @@ static size_t pipe_complete_io(Vio* vio, char* buf, size_t size, DWORD timeout_m
   DBUG_RETURN(length);
 }
 
+
 size_t vio_read_pipe(Vio * vio, uchar *buf, size_t size)
 {
   DWORD bytes_read;
@@ -765,6 +819,7 @@ size_t vio_read_pipe(Vio * vio, uchar *buf, size_t size)
   DBUG_RETURN(retval);
 }
 
+
 size_t vio_write_pipe(Vio * vio, const uchar* buf, size_t size)
 {
   DWORD bytes_written;
@@ -773,7 +828,7 @@ size_t vio_write_pipe(Vio * vio, const uchar* buf, size_t size)
   DBUG_PRINT("enter", ("sd: %d  buf: 0x%lx  size: %u", vio->sd, (long) buf,
                        (uint) size));
 
-  if (WriteFile(vio->hPipe, buf, (DWORD)size, &bytes_written,
+  if (WriteFile(vio->hPipe, buf, (DWORD)size, &bytes_written, 
       &(vio->pipe_overlapped)))
   {
     retval= bytes_written;
@@ -793,6 +848,7 @@ size_t vio_write_pipe(Vio * vio, const uchar* buf, size_t size)
   DBUG_RETURN(retval);
 }
 
+
 my_bool vio_is_connected_pipe(Vio *vio)
 {
   if (PeekNamedPipe(vio->hPipe, NULL, 0, NULL, NULL, NULL))
@@ -801,6 +857,7 @@ my_bool vio_is_connected_pipe(Vio *vio)
     return (GetLastError() != ERROR_BROKEN_PIPE);
 }
 
+
 int vio_close_pipe(Vio * vio)
 {
   int r;
@@ -820,11 +877,12 @@ int vio_close_pipe(Vio * vio)
   DBUG_RETURN(r);
 }
 
+
 void vio_win32_timeout(Vio *vio, uint which , uint timeout_sec)
 {
     DWORD timeout_ms;
     /*
-      Windows is measuring timeouts in milliseconds. Check for possible int
+      Windows is measuring timeouts in milliseconds. Check for possible int 
       overflow.
     */
     if (timeout_sec > UINT_MAX/1000)
@@ -839,6 +897,7 @@ void vio_win32_timeout(Vio *vio, uint which , uint timeout_sec)
       vio->read_timeout_ms= timeout_ms;
 }
 
+
 #ifdef HAVE_SMEM
 
 size_t vio_read_shared_memory(Vio * vio, uchar* buf, size_t size)
@@ -866,7 +925,7 @@ size_t vio_read_shared_memory(Vio * vio, uchar* buf, size_t size)
         WaitForMultipleObjects can return next values:
          WAIT_OBJECT_0+0 - event from vio->event_server_wrote
          WAIT_OBJECT_0+1 - event from vio->event_conn_closed. We can't read
-                   anything
+		           anything
          WAIT_ABANDONED_0 and WAIT_TIMEOUT - fail.  We can't read anything
       */
       if (WaitForMultipleObjects(array_elements(events), events, FALSE,
@@ -906,6 +965,7 @@ size_t vio_read_shared_memory(Vio * vio, uchar* buf, size_t size)
   DBUG_RETURN(length);
 }
 
+
 size_t vio_write_shared_memory(Vio * vio, const uchar* buf, size_t size)
 {
   size_t length, remain, sz;
@@ -948,11 +1008,13 @@ size_t vio_write_shared_memory(Vio * vio, const uchar* buf, size_t size)
   DBUG_RETURN(length);
 }
 
+
 my_bool vio_is_connected_shared_memory(Vio *vio)
 {
   return (WaitForSingleObject(vio->event_conn_closed, 0) != WAIT_OBJECT_0);
 }
 
+
 /**
  Close shared memory and DBUG_PRINT any errors that happen on closing.
  @return Zero if all closing functions succeed, and nonzero otherwise.
@@ -972,7 +1034,7 @@ int vio_close_shared_memory(Vio * vio)
       Close all handlers. UnmapViewOfFile and CloseHandle return non-zero
       result if they are success.
     */
-    if (UnmapViewOfFile(vio->handle_map) == 0)
+    if (UnmapViewOfFile(vio->handle_map) == 0) 
     {
       error_count++;
       DBUG_PRINT("vio_error", ("UnmapViewOfFile() failed"));
@@ -1015,6 +1077,7 @@ int vio_close_shared_memory(Vio * vio)
 #endif /* HAVE_SMEM */
 #endif /* __WIN__ */
 
+
 /**
   Number of bytes in the read buffer.
 
@@ -1038,6 +1101,7 @@ ssize_t vio_pending(Vio *vio)
   return 0;
 }
 
+
 /**
   Checks if the error code, returned by vio_getnameinfo(), means it was the
   "No-name" error.
@@ -1065,6 +1129,7 @@ my_bool vio_is_no_name_error(int err_code)
 #endif
 }
 
+
 /**
   This is a wrapper for the system getnameinfo(), because different OS
   differ in the getnameinfo() implementation:
@@ -1103,4 +1168,4 @@ int vio_getnameinfo(const struct sockaddr *sa,
                      hostname, hostname_size,
                      port, port_size,
                      flags);
-}
\ No newline at end of file
+}
diff --git a/dep/mysqllite/vio/viossl.c b/dep/mysqllite/vio/viossl.c
index cf84972..e7ab7e4 100644
--- a/dep/mysqllite/vio/viossl.c
+++ b/dep/mysqllite/vio/viossl.c
@@ -40,7 +40,7 @@
   while ((l= ERR_get_error_line_data(&file,&line,&data,&flags)))
   {
     DBUG_PRINT("error", ("OpenSSL: %s:%s:%d:%s\n", ERR_error_string(l,buf),
-             file,line,(flags&ERR_TXT_STRING)?data:"")) ;
+			 file,line,(flags&ERR_TXT_STRING)?data:"")) ;
   }
 
   if (ssl)
@@ -53,12 +53,13 @@
 
 #endif
 
+
 size_t vio_ssl_read(Vio *vio, uchar* buf, size_t size)
 {
   size_t r;
   DBUG_ENTER("vio_ssl_read");
   DBUG_PRINT("enter", ("sd: %d  buf: 0x%lx  size: %u  ssl: 0x%lx",
-               vio->sd, (long) buf, (uint) size, (long) vio->ssl_arg));
+		       vio->sd, (long) buf, (uint) size, (long) vio->ssl_arg));
 
   r= SSL_read((SSL*) vio->ssl_arg, buf, size);
 #ifndef DBUG_OFF
@@ -69,6 +70,7 @@ size_t vio_ssl_read(Vio *vio, uchar* buf, size_t size)
   DBUG_RETURN(r);
 }
 
+
 size_t vio_ssl_write(Vio *vio, const uchar* buf, size_t size)
 {
   size_t r;
@@ -85,6 +87,7 @@ size_t vio_ssl_write(Vio *vio, const uchar* buf, size_t size)
   DBUG_RETURN(r);
 }
 
+
 int vio_ssl_close(Vio *vio)
 {
   int r= 0;
@@ -101,8 +104,8 @@ int vio_ssl_close(Vio *vio)
     describing with length, we aren't vunerable to these attacks. Therefore,
     we just shutdown by closing the socket (quiet shutdown).
     */
-    SSL_set_quiet_shutdown(ssl, 1);
-
+    SSL_set_quiet_shutdown(ssl, 1); 
+    
     switch ((r= SSL_shutdown(ssl))) {
     case 1:
       /* Shutdown successful */
@@ -123,6 +126,7 @@ int vio_ssl_close(Vio *vio)
   DBUG_RETURN(vio_close(vio));
 }
 
+
 void vio_ssl_delete(Vio *vio)
 {
   if (!vio)
@@ -140,6 +144,7 @@ void vio_ssl_delete(Vio *vio)
   vio_delete(vio);
 }
 
+
 static int ssl_do(struct st_VioSSLFd *ptr, Vio *vio, long timeout,
                   int (*connect_accept_func)(SSL*), unsigned long *errptr)
 {
@@ -217,21 +222,24 @@ static int ssl_do(struct st_VioSSLFd *ptr, Vio *vio, long timeout,
   DBUG_RETURN(0);
 }
 
+
 int sslaccept(struct st_VioSSLFd *ptr, Vio *vio, long timeout, unsigned long *errptr)
 {
   DBUG_ENTER("sslaccept");
   DBUG_RETURN(ssl_do(ptr, vio, timeout, SSL_accept, errptr));
 }
 
+
 int sslconnect(struct st_VioSSLFd *ptr, Vio *vio, long timeout, unsigned long *errptr)
 {
   DBUG_ENTER("sslconnect");
   DBUG_RETURN(ssl_do(ptr, vio, timeout, SSL_connect, errptr));
 }
 
+
 int vio_ssl_blocking(Vio *vio __attribute__((unused)),
-             my_bool set_blocking_mode,
-             my_bool *old_mode)
+		     my_bool set_blocking_mode,
+		     my_bool *old_mode)
 {
   /* Mode is always blocking */
   *old_mode= 1;
@@ -244,4 +252,4 @@ my_bool vio_ssl_has_data(Vio *vio)
   return SSL_pending(vio->ssl_arg) > 0 ? TRUE : FALSE;
 }
 
-#endif /* HAVE_OPENSSL */
\ No newline at end of file
+#endif /* HAVE_OPENSSL */
diff --git a/dep/mysqllite/vio/viosslfactories.c b/dep/mysqllite/vio/viosslfactories.c
index 46f44a4..43975b9 100644
--- a/dep/mysqllite/vio/viosslfactories.c
+++ b/dep/mysqllite/vio/viosslfactories.c
@@ -50,6 +50,7 @@ static DH *get_dh512(void)
   return(dh);
 }
 
+
 static void
 report_errors()
 {
@@ -65,14 +66,14 @@ static DH *get_dh512(void)
 #ifndef DBUG_OFF				/* Avoid warning */
     char buf[200];
     DBUG_PRINT("error", ("OpenSSL: %s:%s:%d:%s\n", ERR_error_string(l,buf),
-             file,line,(flags & ERR_TXT_STRING) ? data : "")) ;
+			 file,line,(flags & ERR_TXT_STRING) ? data : "")) ;
 #endif
   }
   DBUG_VOID_RETURN;
 }
 
 static const char*
-ssl_error_string[] =
+ssl_error_string[] = 
 {
   "No error",
   "Unable to get certificate",
@@ -96,51 +97,56 @@ static DH *get_dh512(void)
 {
   DBUG_ENTER("vio_set_cert_stuff");
   DBUG_PRINT("enter", ("ctx: 0x%lx  cert_file: %s  key_file: %s",
-               (long) ctx, cert_file, key_file));
-  if (cert_file)
-  {
-    if (SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
-    {
-      *error= SSL_INITERR_CERT;
-      DBUG_PRINT("error",("%s from file '%s'", sslGetErrString(*error), cert_file));
-      DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
-      fprintf(stderr, "SSL error: %s from '%s'\n", sslGetErrString(*error),
-              cert_file);
-      fflush(stderr);
-      DBUG_RETURN(1);
-    }
+		       (long) ctx, cert_file, key_file));
 
-    if (!key_file)
-      key_file= cert_file;
+  if (!cert_file &&  key_file)
+    cert_file= key_file;
+  
+  if (!key_file &&  cert_file)
+    key_file= cert_file;
 
-    if (SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
-    {
-      *error= SSL_INITERR_KEY;
-      DBUG_PRINT("error", ("%s from file '%s'", sslGetErrString(*error), key_file));
-      DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
-      fprintf(stderr, "SSL error: %s from '%s'\n", sslGetErrString(*error),
-              key_file);
-      fflush(stderr);
-      DBUG_RETURN(1);
-    }
+  if (cert_file &&
+      SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0)
+  {
+    *error= SSL_INITERR_CERT;
+    DBUG_PRINT("error",("%s from file '%s'", sslGetErrString(*error), cert_file));
+    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
+    fprintf(stderr, "SSL error: %s from '%s'\n", sslGetErrString(*error),
+            cert_file);
+    fflush(stderr);
+    DBUG_RETURN(1);
+  }
 
-    /*
-      If we are using DSA, we can copy the parameters from the private key
-      Now we know that a key and cert have been set against the SSL context
-    */
-    if (!SSL_CTX_check_private_key(ctx))
-    {
-      *error= SSL_INITERR_NOMATCH;
-      DBUG_PRINT("error", ("%s",sslGetErrString(*error)));
-      DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
-      fprintf(stderr, "SSL error: %s\n", sslGetErrString(*error));
-      fflush(stderr);
-      DBUG_RETURN(1);
-    }
+  if (key_file &&
+      SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0)
+  {
+    *error= SSL_INITERR_KEY;
+    DBUG_PRINT("error", ("%s from file '%s'", sslGetErrString(*error), key_file));
+    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
+    fprintf(stderr, "SSL error: %s from '%s'\n", sslGetErrString(*error),
+            key_file);
+    fflush(stderr);
+    DBUG_RETURN(1);
+  }
+
+  /*
+    If we are using DSA, we can copy the parameters from the private key
+    Now we know that a key and cert have been set against the SSL context
+  */
+  if (cert_file && !SSL_CTX_check_private_key(ctx))
+  {
+    *error= SSL_INITERR_NOMATCH;
+    DBUG_PRINT("error", ("%s",sslGetErrString(*error)));
+    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
+    fprintf(stderr, "SSL error: %s\n", sslGetErrString(*error));
+    fflush(stderr);
+    DBUG_RETURN(1);
   }
+
   DBUG_RETURN(0);
 }
 
+
 static void check_ssl_init()
 {
   if (!ssl_algorithms_added)
@@ -148,6 +154,7 @@ static void check_ssl_init()
     ssl_algorithms_added= TRUE;
     SSL_library_init();
     OpenSSL_add_all_algorithms();
+
   }
 
   if (!ssl_error_strings_loaded)
@@ -161,8 +168,8 @@ static void check_ssl_init()
 static struct st_VioSSLFd *
 new_VioSSLFd(const char *key_file, const char *cert_file,
              const char *ca_file, const char *ca_path,
-             const char *cipher, SSL_METHOD *method,
-             enum enum_ssl_init_error *error)
+             const char *cipher, my_bool is_client_method,
+             enum enum_ssl_init_error* error)
 {
   DH *dh;
   struct st_VioSSLFd *ssl_fd;
@@ -182,7 +189,9 @@ static void check_ssl_init()
                  my_malloc(sizeof(struct st_VioSSLFd),MYF(0)))))
     DBUG_RETURN(0);
 
-  if (!(ssl_fd->ssl_context= SSL_CTX_new(method)))
+  if (!(ssl_fd->ssl_context= SSL_CTX_new(is_client_method ? 
+                                         TLSv1_client_method() :
+                                         TLSv1_server_method())))
   {
     *error= SSL_INITERR_MEMFAIL;
     DBUG_PRINT("error", ("%s", sslGetErrString(*error)));
@@ -211,6 +220,20 @@ static void check_ssl_init()
   if (SSL_CTX_load_verify_locations(ssl_fd->ssl_context, ca_file, ca_path) == 0)
   {
     DBUG_PRINT("warning", ("SSL_CTX_load_verify_locations failed"));
+    if (ca_file || ca_path)
+    {
+      /* fail only if ca file or ca path were supplied and looking into 
+         them fails. */
+      *error= SSL_INITERR_BAD_PATHS;
+      DBUG_PRINT("error", ("SSL_CTX_load_verify_locations failed : %s", 
+                 sslGetErrString(*error)));
+      report_errors();
+      SSL_CTX_free(ssl_fd->ssl_context);
+      my_free(ssl_fd);
+      DBUG_RETURN(0);
+    }
+
+    /* otherwise go use the defaults */
     if (SSL_CTX_set_default_verify_paths(ssl_fd->ssl_context) == 0)
     {
       *error= SSL_INITERR_BAD_PATHS;
@@ -241,6 +264,7 @@ static void check_ssl_init()
   DBUG_RETURN(ssl_fd);
 }
 
+
 /************************ VioSSLConnectorFd **********************************/
 struct st_VioSSLFd *
 new_VioSSLConnectorFd(const char *key_file, const char *cert_file,
@@ -258,7 +282,7 @@ struct st_VioSSLFd *
     verify= SSL_VERIFY_NONE;
 
   if (!(ssl_fd= new_VioSSLFd(key_file, cert_file, ca_file,
-                             ca_path, cipher, TLSv1_client_method(), error)))
+                             ca_path, cipher, TRUE, error)))
   {
     return 0;
   }
@@ -270,16 +294,17 @@ struct st_VioSSLFd *
   return ssl_fd;
 }
 
+
 /************************ VioSSLAcceptorFd **********************************/
 struct st_VioSSLFd *
 new_VioSSLAcceptorFd(const char *key_file, const char *cert_file,
-             const char *ca_file, const char *ca_path,
-             const char *cipher, enum enum_ssl_init_error* error)
+		     const char *ca_file, const char *ca_path,
+		     const char *cipher, enum enum_ssl_init_error* error)
 {
   struct st_VioSSLFd *ssl_fd;
   int verify= SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
   if (!(ssl_fd= new_VioSSLFd(key_file, cert_file, ca_file,
-                             ca_path, cipher, TLSv1_server_method(), error)))
+                             ca_path, cipher, FALSE, error)))
   {
     return 0;
   }
@@ -295,8 +320,8 @@ struct st_VioSSLFd *
     Use the ssl_fd pointer
    */
   SSL_CTX_set_session_id_context(ssl_fd->ssl_context,
-                 (const unsigned char *)ssl_fd,
-                 sizeof(ssl_fd));
+				 (const unsigned char *)ssl_fd,
+				 sizeof(ssl_fd));
 
   return ssl_fd;
 }
@@ -306,4 +331,4 @@ void free_vio_ssl_acceptor_fd(struct st_VioSSLFd *fd)
   SSL_CTX_free(fd->ssl_context);
   my_free(fd);
 }
-#endif /* HAVE_OPENSSL */
\ No newline at end of file
+#endif /* HAVE_OPENSSL */
-- 
1.7.10
